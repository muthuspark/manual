{"title":"qiankun - Documentation","markdown":{"yaml":{"title":"qiankun - Documentation","categories":["JavaScript Libraries and Functions"]},"headingText":"What is Qiankun?","containsRefs":false,"markdown":"\n\n\n\nQiankun (乾坤, meaning \"Heaven and Earth\" in Chinese) is a powerful and versatile micro-frontend solution built on top of Single-SPA.  It simplifies the development and integration of multiple independent applications (micro-frontends) into a single, cohesive user experience.  Unlike many other micro-frontend approaches, Qiankun emphasizes ease of use and seamless integration with existing applications, allowing you to gradually adopt a micro-frontend architecture without requiring extensive refactoring.  It provides a standardized API to handle the lifecycle of your sub-applications, managing their loading, mounting, and unmounting within the main application (the \"container\" application).  This allows developers to work on individual applications independently and deploy them autonomously, fostering faster iteration cycles and improved team collaboration.\n\n\n### Key Concepts and Terminology\n\n* **Container Application (Main Application):** The overarching application responsible for hosting and managing the micro-frontends.  It acts as the entry point for the user and provides the infrastructure for the sub-applications to operate.\n\n* **Sub-application (Micro-frontend):** An independent application that is integrated into the container application.  It can be built using any framework (React, Vue, Angular, etc.) and deployed independently.\n\n* **Lifecycle Hooks:** Events triggered at various stages of a sub-application's lifecycle (e.g., `bootstrap`, `mount`, `unmount`).  These hooks allow you to perform actions such as initializing the application, rendering it to the DOM, and cleaning up resources after unmounting.\n\n* **Active Sub-application:** The currently displayed and interactive sub-application within the container.\n\n* **Remote Entry:** The entry point of a sub-application which is usually a JavaScript file exported from the sub application's build process.  It exposes the necessary functions for Qiankun to bootstrap, mount, and unmount the application.\n\n* **Sandbox:** Qiankun's isolation mechanism, ensuring that the sub-applications run in their own isolated environments, preventing conflicts between different JavaScript libraries or global variables.  The default sandbox uses a proxy to achieve isolation of global variables.\n\n\n### Benefits of Using Qiankun\n\n* **Independent Development and Deployment:** Teams can work on sub-applications in parallel without impacting each other.  Independent deployments enable faster release cycles and improved agility.\n\n* **Technology Agnostic:**  Sub-applications can be built using any framework or library, allowing you to leverage existing technology stacks and expertise.\n\n* **Simplified Integration:** Qiankun provides a straightforward API for integrating sub-applications, minimizing boilerplate code.\n\n* **Improved Performance:**  Lazy loading of sub-applications reduces the initial load time of the main application.\n\n* **Enhanced Maintainability and Scalability:**  A modular architecture makes the application easier to maintain and scale over time.\n\n* **Gradual Adoption:** You can gradually migrate existing applications to a micro-frontend architecture without needing a complete rewrite.\n\n\n### Comparison with Other Microfrontend Solutions\n\nQiankun distinguishes itself from other micro-frontend solutions by its simplicity, ease of use, and strong emphasis on integration with existing projects. While other solutions might offer more advanced features or focus on specific architectural patterns, Qiankun prioritizes developer experience and a low barrier to entry.  This makes it particularly well-suited for teams looking to quickly adopt a micro-frontend strategy without significant upfront investment or architectural overhaul.  Compared to solutions requiring extensive configuration or custom infrastructure, Qiankun offers a streamlined approach with minimal overhead, facilitating faster development and easier maintenance.  The default sandbox also provides a relatively simple but effective way to isolate sub-applications from each other.\n\n\n## Setting up a Qiankun Project\n\n### Project Initialization\n\nBefore starting, ensure you have Node.js and npm (or yarn) installed.  We'll assume you're using a create-react-app based main application for this example, but Qiankun supports various frameworks.  You can adapt these instructions to your preferred setup.  Begin by creating a new React application using:\n\n```bash\nnpx create-react-app my-qiankun-app\ncd my-qiankun-app\n```\n\nThis command creates the base structure for your main (container) application.  You can name it differently if you prefer.  We will refer to this directory as `my-qiankun-app` throughout this section.  You will also need to create separate projects for each of your sub-applications, using your framework of choice (e.g., another `create-react-app`, a Vue project, etc.).\n\n\n### Installing Necessary Packages\n\nNavigate to your `my-qiankun-app` directory and install Qiankun:\n\n```bash\nnpm install @qiankun/react @qiankun/runtime\n```\n\nor if using yarn:\n\n```bash\nyarn add @qiankun/react @qiankun/runtime\n```\n\n`@qiankun/react` provides React-specific integration helpers, while `@qiankun/runtime` contains the core Qiankun functionalities.  You will install framework-specific packages in your sub-applications (e.g., `@qiankun/vue` for Vue sub-applications).\n\n\n### Configuring the Main Application\n\n1.  **Import and Register Sub-applications:**  In your main application's entry point (usually `src/index.js` or `src/App.js`), import `registerMicroApps` from `@qiankun/react` and configure it to register your sub-applications.  This involves specifying the sub-application's name, entry URL (the `remoteEntry` URL), and active rule (used to determine when to mount the sub-application).  Example:\n\n```javascript\nimport { registerMicroApps, start } from 'qiankun';\n\nregisterMicroApps([\n  {\n    name: 'sub-app-1',\n    entry: '//localhost:8080', // Replace with your sub-app's URL\n    container: '#sub-app-container', // Replace with a div ID in your main app\n    activeRule: '/sub-app-1',\n  },\n  {\n    name: 'sub-app-2',\n    entry: '//localhost:8081', // Replace with your sub-app's URL\n    container: '#sub-app-container',\n    activeRule: '/sub-app-2',\n  },\n]);\n\nstart();\n```\n\n2.  **Create Container Element:**  Add a `<div>` element with the ID specified in the `container` property in your main application's component tree. This div will act as a placeholder for your sub-applications.\n\n\n### Creating Sub-applications\n\nCreate separate projects for each sub-application using your preferred framework.  For example, if using React, you would create another `create-react-app` project.  Then, install the corresponding Qiankun package (e.g., `@qiankun/react`).  In your sub-application's entry point, export the necessary bootstrap, mount, and unmount functions as required by Qiankun's runtime.  A basic example (using React):\n\n```javascript\n// sub-app/src/index.js\nimport { render } from 'react-dom';\nimport App from './App';\nimport { createRoot } from 'react-dom/client';\n\nexport async function bootstrap() {\n  console.log('react app bootstrapped');\n}\n\nexport async function mount(props) {\n  console.log('props from main framework', props);\n  const root = createRoot(props.container);\n  render(<App {...props} />, root);\n}\n\nexport async function unmount(props) {\n  console.log('unmount');\n  ReactDOM.unmountComponentAtNode(props.container);\n}\n```\n\nThis exposes the required functions to the container application.  Remember to configure your build process to generate a `remoteEntry.js` file (or a similar file) which acts as your sub-application's entry point.  The location of this file should be reflected in the `entry` field of your main application's configuration.\n\n\n### Running the Application\n\nStart your sub-applications independently (e.g., `npm start` within each sub-application directory).  Then, start your main application using  `npm start` in the `my-qiankun-app` directory.  Navigate to different routes (defined in the `activeRule`) to load and interact with the corresponding sub-application.  Remember to replace placeholder URLs with the actual URLs where your sub-applications are running.  These are typically development server URLs while developing.  In production, these would be your deployment URLs.\n\n\n## Developing Sub-applications\n\n### Creating a Sub-application\n\nCreating a sub-application involves setting up a new project using your preferred framework (React, Vue, Angular, etc.).  The process largely depends on the chosen framework; however, the key is to structure the project to export the necessary lifecycle functions that Qiankun expects.  These functions are `bootstrap`, `mount`, and `unmount`.  This export is usually handled through a dedicated entry point file (often named `index.html` or similar for simpler applications, or a Javascript entry point generated as part of the build process for larger applications).\n\nThe sub-application should be developed independently and built as a separate entity.  The build process should generate a specific output file (usually named `remoteEntry.js` although this is configurable) that exports these lifecycle functions.  This `remoteEntry.js` file contains the necessary information for Qiankun to load and manage the sub-application within the main application.\n\nEnsure that your build configuration includes a proper output path and filename so the main application can correctly load the `remoteEntry.js` file.\n\n### Registering Sub-applications\n\nSub-applications are registered within the main application using the `registerMicroApps` function from `@qiankun/react` (or the equivalent function for other frameworks). The registration process involves providing an object for each sub-application. This object must contain at least the following properties:\n\n*   `name`: A unique identifier for the sub-application.\n*   `entry`: The URL of the sub-application's `remoteEntry.js` file.  This should typically be a full URL, including the protocol (`http` or `https`) and port number. In development, this is usually a URL pointing to your local development server.\n*   `container`: A CSS selector targeting a container element in the main application's DOM where the sub-application will be rendered. This element should already exist in the main application's HTML.\n*   `activeRule`:  A route or URL pattern that determines when the sub-application should be active (mounted).  This can be a simple string or a more complex regular expression.\n\nExample:\n\n```javascript\nregisterMicroApps([\n  {\n    name: 'sub-app-one',\n    entry: 'http://localhost:8080/remoteEntry.js', // Adjust for your specific build output\n    container: '#subapp-container',\n    activeRule: '/sub-app-one',\n  },\n  // ... more sub-applications\n]);\n```\n\n\n### Lifecycle Hooks\n\nQiankun provides crucial lifecycle hooks for each sub-application:\n\n*   `bootstrap`: Called when the sub-application is loaded but not yet mounted. This is a good place for initializing resources but should avoid DOM manipulation.\n\n*   `mount`: Called when the sub-application should be mounted and rendered into the designated container. The `props` object passed to this function contains important information including the container element (`container`).\n\n*   `unmount`: Called when the sub-application should be unmounted and removed from the DOM. This is crucial for cleaning up resources and preventing memory leaks.\n\nProper implementation of these hooks is vital for ensuring seamless integration and a smooth user experience.\n\n\n### Communication Between Sub-applications and Main Application\n\nCommunication between sub-applications and the main application can be achieved through several mechanisms:\n\n*   **Global Event Bus:**  A simple approach is to use a global event bus (e.g., custom events, browser's `postMessage`) to broadcast events between the main application and sub-applications.\n\n*   **Props:** Qiankun passes props to the sub-application's `mount` function, allowing the main application to pass data to the sub-application during the mounting process.\n\n*   **Shared State Management:**  Employ a shared state management solution (like Redux, Vuex, or a centralized data store) accessible to both the main application and sub-applications.  However, ensure careful isolation to prevent unintended side effects.\n\n\n### Data Sharing and Communication\n\nFor more complex scenarios, a more structured approach might be necessary.  Consider using a dedicated communication mechanism like a message bus, a centralized state management solution, or a dedicated API layer.  The chosen method should balance efficiency and maintainability, while keeping in mind the independence of sub-applications.  Over-reliance on global state can lead to tightly-coupled and difficult-to-maintain systems.\n\n### Handling Sub-application Errors\n\nImplement proper error handling within each sub-application and within the main application's integration logic.  The main application should gracefully handle errors that occur during sub-application loading, mounting, or unmounting. This may involve displaying informative error messages to the user or logging detailed error reports for debugging purposes. Use `try...catch` blocks appropriately within lifecycle hooks and other error-prone parts of the code.  Consider centralized error reporting mechanisms to aggregate errors from various sub-applications.\n\n\n## Advanced Configuration\n\n### Customizing the Qiankun Sandbox\n\nQiankun's default sandbox provides basic isolation, but for more stringent requirements or specific needs, you can customize the sandbox behavior. Qiankun allows you to provide a custom sandbox implementation.  This is particularly useful when dealing with conflicting libraries or global variables between sub-applications. A custom sandbox function receives the sub-application's entry point (`entry`) and the container element (`container`) as parameters and returns an object containing the `proxy` and `patch` functions.  These functions allow you to intercept and control access to global variables and the DOM.  Refer to the Qiankun documentation for detailed examples and instructions on how to implement a custom sandbox.  Careful consideration should be given to performance implications when implementing a custom sandbox, as overzealous sandboxing can lead to performance bottlenecks.\n\n\n### Asynchronous Loading of Sub-applications\n\nBy default, Qiankun loads sub-applications synchronously, meaning the main application waits for the sub-application to load before proceeding. For improved performance, especially in scenarios with many sub-applications or large sub-applications, you can implement asynchronous loading. This involves optimizing the network requests for the `remoteEntry.js` files and potentially using techniques like code-splitting or pre-fetching to pre-load resources.  However, be mindful of the added complexity asynchronous loading introduces to the overall architecture.\n\n\n### Using Different Frameworks for Sub-applications\n\nOne of Qiankun's significant strengths is its framework-agnostic nature. You can easily integrate sub-applications built with different frameworks (React, Vue, Angular, etc.) within a single main application.  The key is to ensure that each sub-application exports the correct lifecycle methods (`bootstrap`, `mount`, `unmount`) as expected by Qiankun's runtime. You might need to install framework-specific Qiankun packages (e.g., `@qiankun/vue` for Vue sub-applications) to ensure smooth integration.\n\n\n### Pre-loading Sub-applications\n\nPre-loading sub-applications can significantly improve perceived performance by loading resources before they're actually needed.  This can be implemented by fetching the necessary assets (e.g., JavaScript bundles) in the background while the user is interacting with other parts of the application.  Qiankun doesn't directly handle pre-loading, but you can implement this using browser APIs like `fetch` or other techniques such as resource hints (`<link rel=\"preload\">`).  Strategic implementation of pre-loading requires careful consideration to avoid excessive resource consumption and negatively impacting the user experience.\n\n\n### Implementing Custom Error Handling\n\nWhile Qiankun provides basic error handling, you can enhance it by implementing custom error-handling mechanisms.  This may involve creating custom error boundaries within the main application or individual sub-applications to catch and handle exceptions gracefully.  For instance, you could display informative error messages to the user, log errors to a centralized logging service, or implement fallback mechanisms.  Comprehensive error handling is crucial for building robust and reliable micro-frontend applications.\n\n\n### Performance Optimization Strategies\n\nPerformance optimization is crucial for large micro-frontend applications.  Strategies include:\n\n*   **Lazy Loading:** Load sub-applications only when they're needed, avoiding unnecessary resource loading.\n*   **Code Splitting:** Divide sub-application code into smaller chunks to optimize loading times.\n*   **Caching:** Utilize browser caching mechanisms to reduce repeated downloads.\n*   **Resource Hints:** Use `preload` and `prefetch` resource hints to proactively load assets.\n*   **Compression:** Optimize your application's assets using compression techniques (e.g., gzip).\n*   **Efficient Sandbox:** Consider the performance implications of custom sandboxing implementations.  Overly restrictive sandboxes can have a detrimental effect on performance.\n*   **Monitoring and Profiling:** Use browser developer tools and performance monitoring services to identify performance bottlenecks and optimize accordingly.\n\n\n\n\n## Deployment and Scaling\n\n### Deploying the Main Application\n\nDeploying the main application involves standard deployment procedures for your chosen framework and hosting platform.  This typically involves building the application (often creating a production-optimized build) and deploying the resulting artifacts (HTML, CSS, JavaScript, and assets) to a web server.  Ensure the server is configured correctly to serve the necessary files and handle routing to the various sub-applications based on the `activeRule` configuration within your main application.  The deployment process might involve using CI/CD pipelines to automate the build and deployment steps.  Consider using a reverse proxy or load balancer to manage incoming requests and distribute traffic effectively, especially as your application grows.\n\n\n### Deploying Sub-applications\n\nSub-applications are deployed independently, similar to the main application.  Each sub-application has its own build process and deployment pipeline.  The key difference is that the deployment target for each sub-application only needs to expose the `remoteEntry.js` file (or equivalent). This file serves as the entry point for Qiankun to load and mount the sub-application. The URL of this `remoteEntry.js` file needs to be accurately specified in the main application's configuration (`registerMicroApps`).  Deploying sub-applications independently allows for faster iteration cycles and parallel deployments.\n\n\n### Scaling Strategies\n\nScaling a micro-frontend application built with Qiankun involves scaling both the main application and the individual sub-applications.  Strategies include:\n\n*   **Horizontal Scaling:**  Deploy multiple instances of both the main application and sub-applications across multiple servers.  This distributes the load and enhances availability.  Consider using load balancers to distribute incoming traffic across the various instances.\n\n*   **Vertical Scaling:**  Increase the resources (CPU, memory, etc.) allocated to the servers hosting the main application and sub-applications.  This is suitable for handling increased load without deploying additional instances.\n\n*   **Database Scaling:**  If your application relies on a database, you might need to scale the database independently, potentially using techniques such as database sharding or replication.\n\n*   **Content Delivery Network (CDN):**  Using a CDN to cache static assets (e.g., JavaScript, CSS, images) can significantly reduce latency and improve performance, particularly for users located geographically distant from your servers.\n\nThe optimal scaling strategy depends on the specific requirements of your application, the anticipated load, and your budget.  Careful monitoring and performance analysis are crucial for making informed scaling decisions.\n\n\n### Monitoring and Logging\n\nImplementing robust monitoring and logging is essential for maintaining and scaling a micro-frontend application.  Consider using dedicated monitoring tools to track key metrics such as:\n\n*   **Application Performance:**  Track response times, error rates, and resource utilization.\n*   **Sub-application Performance:**  Monitor the performance of individual sub-applications to pinpoint bottlenecks or issues.\n*   **Network Requests:**  Analyze network requests to identify slowdowns or errors.\n*   **Error Logs:**  Aggregate error logs from the main application and all sub-applications for easier debugging.\n*   **Resource Usage:**  Monitor CPU, memory, and disk usage to ensure resources are used efficiently.\n\nCentralized logging and monitoring systems allow you to gain a holistic view of your application's health and performance.  This enables proactive identification and resolution of issues, ensuring a high level of availability and a positive user experience.\n\n\n## Best Practices and Troubleshooting\n\n### Code Organization and Maintainability\n\nMaintaining a clean and well-organized codebase is crucial for the long-term success of any project, especially a micro-frontend application.  For Qiankun projects, consider these best practices:\n\n*   **Modular Design:**  Structure your sub-applications and the main application using a modular design.  Break down large components into smaller, more manageable modules with well-defined interfaces.\n\n*   **Consistent Coding Style:**  Enforce a consistent coding style across all sub-applications and the main application using linters and formatters.\n\n*   **Version Control:**  Utilize a version control system (e.g., Git) to track changes, manage code branches, and facilitate collaboration.\n\n*   **Documentation:**  Write clear and concise documentation for each sub-application and the main application.  This will make it easier for developers to understand and maintain the code.\n\n*   **Clear Communication:**  Establish clear communication channels between teams working on different sub-applications.  This will prevent conflicts and ensure consistency.\n\n*   **Dependency Management:**  Manage dependencies effectively using package managers (e.g., npm, yarn) and consider using a monorepo if appropriate.  This simplifies dependency management and reduces conflicts.\n\n\n### Testing Strategies\n\nA robust testing strategy is essential for ensuring the quality and reliability of your Qiankun application.  Consider incorporating these testing approaches:\n\n*   **Unit Testing:**  Test individual components and modules in isolation.  This helps to identify bugs early in the development process.\n\n*   **Integration Testing:**  Test the interaction between different sub-applications and the main application.  This ensures that the different parts of the system work together correctly.\n\n*   **End-to-End (E2E) Testing:**  Test the entire application from the user's perspective.  This simulates real-world usage scenarios and helps to identify issues that might not be apparent during unit or integration testing.\n\n*   **Automated Testing:**  Automate your tests as much as possible. This will save time and ensure that your tests are run consistently.  CI/CD pipelines are excellent for integrating automated testing.\n\n*   **Test-Driven Development (TDD):**  Consider using TDD, where tests are written before the code, to guide the development process and improve code quality.\n\n\n### Common Issues and Solutions\n\nSome common issues encountered while working with Qiankun include:\n\n*   **Conflicts between JavaScript libraries:**  Use Qiankun's sandbox feature to isolate sub-applications and prevent conflicts between libraries.  Consider using custom sandboxes for more complex scenarios.\n\n*   **Communication problems between sub-applications and the main application:** Ensure you use appropriate communication mechanisms (e.g., `postMessage`, event bus, shared state management) and follow a consistent approach across the application.\n\n*   **Performance issues:**  Optimize the application's performance by implementing strategies like lazy loading, code splitting, and caching.\n\n*   **Deployment problems:**  Ensure you follow the correct deployment procedures for both the main application and the sub-applications.  Use CI/CD pipelines to automate the process and reduce errors.\n\n*   **Error handling issues:**  Implement comprehensive error handling mechanisms to gracefully handle exceptions and provide informative error messages to the user.\n\nConsult the Qiankun documentation and online resources for detailed solutions to specific issues.\n\n\n### Security Considerations\n\nSecurity is paramount in any software project. When using Qiankun, keep these considerations in mind:\n\n*   **Input Validation:**  Validate all user inputs to prevent cross-site scripting (XSS) attacks and other vulnerabilities.\n\n*   **Authentication and Authorization:**  Implement secure authentication and authorization mechanisms to protect sensitive data and resources.\n\n*   **Data Protection:**  Protect sensitive data using appropriate encryption and access control measures.\n\n*   **Regular Security Audits:** Conduct regular security audits to identify and address potential vulnerabilities.\n\n*   **Secure Deployment Practices:** Follow secure deployment practices to protect your application from attacks.\n\n*   **Sub-application Security:**  Ensure that each sub-application follows secure coding practices and implements appropriate security measures.\n\n*   **Dependency Security:**  Regularly scan your dependencies for known vulnerabilities and upgrade to the latest versions promptly.  Use tools like `npm audit` or similar for dependency scanning.  Consider using a dependency management tool with built-in security scanning.\n\n\n## API Reference\n\nThis section provides a concise overview of the core Qiankun APIs.  For detailed information and examples, refer to the official Qiankun documentation.  Note that the exact API might change slightly depending on the Qiankun version.\n\n### `registerMicroApps`\n\nThis function registers the micro-applications (sub-applications) with Qiankun.  It takes an array of application configurations as input and returns nothing.  Each configuration object must include at least the following properties:\n\n*   `name`: (string) A unique identifier for the micro-application.\n*   `entry`: (string) The URL of the micro-application's entry point (usually `remoteEntry.js`).\n*   `container`: (string | HTMLElement) A CSS selector or an HTMLElement that specifies where the micro-application will be rendered.\n*   `activeRule`: (string | RegExp) A rule (string or regular expression) that determines when the micro-application should be active.  This usually relates to URL routing in the main application.\n*   `props?`: (object) Optional props that will be passed to the micro-application's `mount` lifecycle function.  This is how you typically pass data from the main application to the sub-application.\n\n\nExample:\n\n```javascript\nregisterMicroApps([\n  {\n    name: 'app1',\n    entry: '//localhost:8000',\n    container: '#container',\n    activeRule: '/app1',\n  },\n]);\n```\n\n### `start`\n\nThis function starts Qiankun's lifecycle management.  It begins monitoring the URL and updates the active micro-applications accordingly.  It takes an optional configuration object as a parameter.  This allows for options such as setting the `prefetch` (whether to prefetch micro-applications), and `sandbox` settings. Calling `start()` is crucial after registering micro-apps via `registerMicroApps()`.\n\nExample:\n\n```javascript\nstart(); // Starts Qiankun\n```\n\n### `loadMicroApp`\n\nThis function loads a specific micro-application asynchronously.  It takes a configuration object similar to `registerMicroApps`, but only needs to specify a single sub-application. It returns a promise that resolves when the micro-application has successfully loaded and is ready to mount. Useful when you want to load a sub-application dynamically based on some other event outside of the initial routing.\n\nExample:\n\n```javascript\nloadMicroApp({\n    name: 'app1',\n    entry: '//localhost:8000',\n    container: '#container',\n}).then(() => console.log('app1 loaded'))\n```\n\n### `unmountRootParcel`\n\nThis function unmounts the specified micro-application.  This removes the sub-application from the DOM and performs the sub-application's `unmount` lifecycle method.  Takes the name of the application as an argument.  It's important for cleaning up resources.\n\nExample:\n\n```javascript\nunmountRootParcel('app1');\n```\n\n### `sandbox` (Custom Sandbox)\n\nWhile not a standalone function, the `sandbox` option within the `start()` function or within individual micro-application registrations lets you customize Qiankun's isolation mechanism.  By default, Qiankun uses a proxy-based sandbox.  You can provide a custom sandbox implementation to fine-tune the isolation level and control how the micro-application interacts with the global environment of the main application.  This requires a detailed understanding of Qiankun's internal mechanisms and is generally needed only in advanced scenarios.\n\n\n### `qiankun.initGlobalState`\n\nThis function initializes a global state instance.  This state can then be used for communication and data sharing between the main application and sub-applications.  It takes an initial state object as an argument and returns a global state instance.  The instance provides methods to access and update the shared state.  The global state is typically used to transmit data and update application settings.\n\nExample:\n\n```javascript\nconst globalState = qiankun.initGlobalState({ count: 0 });\n```\n\n\n### `qiankun.getGlobalState`\n\nThis function retrieves the global state instance initialized by `qiankun.initGlobalState`. This provides a way for any part of the micro-frontend application (both main application and sub-applications) to access the global state and retrieve information.\n\nExample:\n\n```javascript\nconst globalState = qiankun.getGlobalState();\n```\n\nRemember that while these functions provide a simplified overview, referring to the official Qiankun documentation is crucial for more detailed information, including advanced options and error handling.\n\n\n## Examples and Use Cases\n\n### Simple Example: Two Sub-applications\n\nThis example demonstrates a simple setup with two sub-applications.  Assume you have two React applications: `app1` and `app2`.  Each is a standard Create React App project, but they have been modified to export the Qiankun lifecycle methods (`bootstrap`, `mount`, `unmount`).  They also have been built to output a `remoteEntry.js` file containing this export.\n\n**Main Application (`index.js`):**\n\n```javascript\nimport { registerMicroApps, start } from 'qiankun';\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n\n\nregisterMicroApps([\n  {\n    name: 'app1',\n    entry: '//localhost:8080/remoteEntry.js',  // Replace with your app1 URL\n    container: '#subapp',\n    activeRule: '/app1',\n  },\n  {\n    name: 'app2',\n    entry: '//localhost:8081/remoteEntry.js',  // Replace with your app2 URL\n    container: '#subapp',\n    activeRule: '/app2',\n  },\n]);\n\nstart();\n\nreportWebVitals();\n```\n\n**Main Application (`App.js`):**\n\n```javascript\nimport React from 'react';\nimport { Link } from 'react-router-dom';\nimport { BrowserRouter as Router, Route, Routes } from 'react-router-dom';\n\n\nfunction App() {\n  return (\n    <Router>\n      <div>\n        <nav>\n          <Link to=\"/app1\">App 1</Link>{' '}\n          <Link to=\"/app2\">App 2</Link>\n        </nav>\n        <div id=\"subapp\"></div>\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n```\n\nRemember that you need a `<div id=\"subapp\"></div>` in your main application's HTML.  This is where the sub-applications will be rendered.  App1 and App2 need to have their own routing configurations within the `remoteEntry.js` build output.\n\n\n### Complex Example: Multiple Sub-applications and Data Sharing\n\nFor more complex scenarios with numerous sub-applications and data sharing, consider using a centralized state management solution like Redux or Zustand.  The global state provided by Qiankun (`qiankun.initGlobalState` and `qiankun.getGlobalState`) can also be a solution, but for larger applications, a more robust solution may be needed to avoid unexpected behavior.  Sub-applications can access and update this shared state, enabling communication and data exchange.  The main application might also act as a central hub, coordinating data flow between sub-applications.\n\n\n### Real-world Use Cases\n\nQiankun is suitable for various real-world scenarios:\n\n*   **Large-scale enterprise applications:**  Breaking down monolithic applications into smaller, independently deployable units.\n\n*   **Legacy system modernization:**  Gradually migrating legacy systems to a modern micro-frontend architecture.\n\n*   **Team collaboration:**  Enabling teams to work independently on different parts of an application.\n\n*   **A/B testing:**  Deploying different versions of sub-applications for A/B testing purposes.\n\n*   **Third-party integrations:**  Integrating third-party applications as sub-applications.\n\n\n### Integrating with Other Libraries\n\nQiankun can be integrated with various libraries to enhance functionality:\n\n*   **Routing libraries:**  Libraries like React Router or Vue Router can be used to manage navigation within the main application and sub-applications.\n\n*   **State management libraries:**  Libraries like Redux, Vuex, or MobX can be used for state management within sub-applications and to facilitate data sharing.\n\n*   **UI libraries:**  Any UI library (e.g., Material-UI, Ant Design, Element UI) can be used within the sub-applications.\n\n*   **Testing libraries:**  Integration with testing libraries like Jest and Cypress helps in building a robust testing strategy.\n\nThe choice of libraries depends on the specific requirements and preferences of your project.  Ensure compatibility between the libraries and Qiankun.\n\n\n\n","srcMarkdownNoYaml":"\n\n\n### What is Qiankun?\n\nQiankun (乾坤, meaning \"Heaven and Earth\" in Chinese) is a powerful and versatile micro-frontend solution built on top of Single-SPA.  It simplifies the development and integration of multiple independent applications (micro-frontends) into a single, cohesive user experience.  Unlike many other micro-frontend approaches, Qiankun emphasizes ease of use and seamless integration with existing applications, allowing you to gradually adopt a micro-frontend architecture without requiring extensive refactoring.  It provides a standardized API to handle the lifecycle of your sub-applications, managing their loading, mounting, and unmounting within the main application (the \"container\" application).  This allows developers to work on individual applications independently and deploy them autonomously, fostering faster iteration cycles and improved team collaboration.\n\n\n### Key Concepts and Terminology\n\n* **Container Application (Main Application):** The overarching application responsible for hosting and managing the micro-frontends.  It acts as the entry point for the user and provides the infrastructure for the sub-applications to operate.\n\n* **Sub-application (Micro-frontend):** An independent application that is integrated into the container application.  It can be built using any framework (React, Vue, Angular, etc.) and deployed independently.\n\n* **Lifecycle Hooks:** Events triggered at various stages of a sub-application's lifecycle (e.g., `bootstrap`, `mount`, `unmount`).  These hooks allow you to perform actions such as initializing the application, rendering it to the DOM, and cleaning up resources after unmounting.\n\n* **Active Sub-application:** The currently displayed and interactive sub-application within the container.\n\n* **Remote Entry:** The entry point of a sub-application which is usually a JavaScript file exported from the sub application's build process.  It exposes the necessary functions for Qiankun to bootstrap, mount, and unmount the application.\n\n* **Sandbox:** Qiankun's isolation mechanism, ensuring that the sub-applications run in their own isolated environments, preventing conflicts between different JavaScript libraries or global variables.  The default sandbox uses a proxy to achieve isolation of global variables.\n\n\n### Benefits of Using Qiankun\n\n* **Independent Development and Deployment:** Teams can work on sub-applications in parallel without impacting each other.  Independent deployments enable faster release cycles and improved agility.\n\n* **Technology Agnostic:**  Sub-applications can be built using any framework or library, allowing you to leverage existing technology stacks and expertise.\n\n* **Simplified Integration:** Qiankun provides a straightforward API for integrating sub-applications, minimizing boilerplate code.\n\n* **Improved Performance:**  Lazy loading of sub-applications reduces the initial load time of the main application.\n\n* **Enhanced Maintainability and Scalability:**  A modular architecture makes the application easier to maintain and scale over time.\n\n* **Gradual Adoption:** You can gradually migrate existing applications to a micro-frontend architecture without needing a complete rewrite.\n\n\n### Comparison with Other Microfrontend Solutions\n\nQiankun distinguishes itself from other micro-frontend solutions by its simplicity, ease of use, and strong emphasis on integration with existing projects. While other solutions might offer more advanced features or focus on specific architectural patterns, Qiankun prioritizes developer experience and a low barrier to entry.  This makes it particularly well-suited for teams looking to quickly adopt a micro-frontend strategy without significant upfront investment or architectural overhaul.  Compared to solutions requiring extensive configuration or custom infrastructure, Qiankun offers a streamlined approach with minimal overhead, facilitating faster development and easier maintenance.  The default sandbox also provides a relatively simple but effective way to isolate sub-applications from each other.\n\n\n## Setting up a Qiankun Project\n\n### Project Initialization\n\nBefore starting, ensure you have Node.js and npm (or yarn) installed.  We'll assume you're using a create-react-app based main application for this example, but Qiankun supports various frameworks.  You can adapt these instructions to your preferred setup.  Begin by creating a new React application using:\n\n```bash\nnpx create-react-app my-qiankun-app\ncd my-qiankun-app\n```\n\nThis command creates the base structure for your main (container) application.  You can name it differently if you prefer.  We will refer to this directory as `my-qiankun-app` throughout this section.  You will also need to create separate projects for each of your sub-applications, using your framework of choice (e.g., another `create-react-app`, a Vue project, etc.).\n\n\n### Installing Necessary Packages\n\nNavigate to your `my-qiankun-app` directory and install Qiankun:\n\n```bash\nnpm install @qiankun/react @qiankun/runtime\n```\n\nor if using yarn:\n\n```bash\nyarn add @qiankun/react @qiankun/runtime\n```\n\n`@qiankun/react` provides React-specific integration helpers, while `@qiankun/runtime` contains the core Qiankun functionalities.  You will install framework-specific packages in your sub-applications (e.g., `@qiankun/vue` for Vue sub-applications).\n\n\n### Configuring the Main Application\n\n1.  **Import and Register Sub-applications:**  In your main application's entry point (usually `src/index.js` or `src/App.js`), import `registerMicroApps` from `@qiankun/react` and configure it to register your sub-applications.  This involves specifying the sub-application's name, entry URL (the `remoteEntry` URL), and active rule (used to determine when to mount the sub-application).  Example:\n\n```javascript\nimport { registerMicroApps, start } from 'qiankun';\n\nregisterMicroApps([\n  {\n    name: 'sub-app-1',\n    entry: '//localhost:8080', // Replace with your sub-app's URL\n    container: '#sub-app-container', // Replace with a div ID in your main app\n    activeRule: '/sub-app-1',\n  },\n  {\n    name: 'sub-app-2',\n    entry: '//localhost:8081', // Replace with your sub-app's URL\n    container: '#sub-app-container',\n    activeRule: '/sub-app-2',\n  },\n]);\n\nstart();\n```\n\n2.  **Create Container Element:**  Add a `<div>` element with the ID specified in the `container` property in your main application's component tree. This div will act as a placeholder for your sub-applications.\n\n\n### Creating Sub-applications\n\nCreate separate projects for each sub-application using your preferred framework.  For example, if using React, you would create another `create-react-app` project.  Then, install the corresponding Qiankun package (e.g., `@qiankun/react`).  In your sub-application's entry point, export the necessary bootstrap, mount, and unmount functions as required by Qiankun's runtime.  A basic example (using React):\n\n```javascript\n// sub-app/src/index.js\nimport { render } from 'react-dom';\nimport App from './App';\nimport { createRoot } from 'react-dom/client';\n\nexport async function bootstrap() {\n  console.log('react app bootstrapped');\n}\n\nexport async function mount(props) {\n  console.log('props from main framework', props);\n  const root = createRoot(props.container);\n  render(<App {...props} />, root);\n}\n\nexport async function unmount(props) {\n  console.log('unmount');\n  ReactDOM.unmountComponentAtNode(props.container);\n}\n```\n\nThis exposes the required functions to the container application.  Remember to configure your build process to generate a `remoteEntry.js` file (or a similar file) which acts as your sub-application's entry point.  The location of this file should be reflected in the `entry` field of your main application's configuration.\n\n\n### Running the Application\n\nStart your sub-applications independently (e.g., `npm start` within each sub-application directory).  Then, start your main application using  `npm start` in the `my-qiankun-app` directory.  Navigate to different routes (defined in the `activeRule`) to load and interact with the corresponding sub-application.  Remember to replace placeholder URLs with the actual URLs where your sub-applications are running.  These are typically development server URLs while developing.  In production, these would be your deployment URLs.\n\n\n## Developing Sub-applications\n\n### Creating a Sub-application\n\nCreating a sub-application involves setting up a new project using your preferred framework (React, Vue, Angular, etc.).  The process largely depends on the chosen framework; however, the key is to structure the project to export the necessary lifecycle functions that Qiankun expects.  These functions are `bootstrap`, `mount`, and `unmount`.  This export is usually handled through a dedicated entry point file (often named `index.html` or similar for simpler applications, or a Javascript entry point generated as part of the build process for larger applications).\n\nThe sub-application should be developed independently and built as a separate entity.  The build process should generate a specific output file (usually named `remoteEntry.js` although this is configurable) that exports these lifecycle functions.  This `remoteEntry.js` file contains the necessary information for Qiankun to load and manage the sub-application within the main application.\n\nEnsure that your build configuration includes a proper output path and filename so the main application can correctly load the `remoteEntry.js` file.\n\n### Registering Sub-applications\n\nSub-applications are registered within the main application using the `registerMicroApps` function from `@qiankun/react` (or the equivalent function for other frameworks). The registration process involves providing an object for each sub-application. This object must contain at least the following properties:\n\n*   `name`: A unique identifier for the sub-application.\n*   `entry`: The URL of the sub-application's `remoteEntry.js` file.  This should typically be a full URL, including the protocol (`http` or `https`) and port number. In development, this is usually a URL pointing to your local development server.\n*   `container`: A CSS selector targeting a container element in the main application's DOM where the sub-application will be rendered. This element should already exist in the main application's HTML.\n*   `activeRule`:  A route or URL pattern that determines when the sub-application should be active (mounted).  This can be a simple string or a more complex regular expression.\n\nExample:\n\n```javascript\nregisterMicroApps([\n  {\n    name: 'sub-app-one',\n    entry: 'http://localhost:8080/remoteEntry.js', // Adjust for your specific build output\n    container: '#subapp-container',\n    activeRule: '/sub-app-one',\n  },\n  // ... more sub-applications\n]);\n```\n\n\n### Lifecycle Hooks\n\nQiankun provides crucial lifecycle hooks for each sub-application:\n\n*   `bootstrap`: Called when the sub-application is loaded but not yet mounted. This is a good place for initializing resources but should avoid DOM manipulation.\n\n*   `mount`: Called when the sub-application should be mounted and rendered into the designated container. The `props` object passed to this function contains important information including the container element (`container`).\n\n*   `unmount`: Called when the sub-application should be unmounted and removed from the DOM. This is crucial for cleaning up resources and preventing memory leaks.\n\nProper implementation of these hooks is vital for ensuring seamless integration and a smooth user experience.\n\n\n### Communication Between Sub-applications and Main Application\n\nCommunication between sub-applications and the main application can be achieved through several mechanisms:\n\n*   **Global Event Bus:**  A simple approach is to use a global event bus (e.g., custom events, browser's `postMessage`) to broadcast events between the main application and sub-applications.\n\n*   **Props:** Qiankun passes props to the sub-application's `mount` function, allowing the main application to pass data to the sub-application during the mounting process.\n\n*   **Shared State Management:**  Employ a shared state management solution (like Redux, Vuex, or a centralized data store) accessible to both the main application and sub-applications.  However, ensure careful isolation to prevent unintended side effects.\n\n\n### Data Sharing and Communication\n\nFor more complex scenarios, a more structured approach might be necessary.  Consider using a dedicated communication mechanism like a message bus, a centralized state management solution, or a dedicated API layer.  The chosen method should balance efficiency and maintainability, while keeping in mind the independence of sub-applications.  Over-reliance on global state can lead to tightly-coupled and difficult-to-maintain systems.\n\n### Handling Sub-application Errors\n\nImplement proper error handling within each sub-application and within the main application's integration logic.  The main application should gracefully handle errors that occur during sub-application loading, mounting, or unmounting. This may involve displaying informative error messages to the user or logging detailed error reports for debugging purposes. Use `try...catch` blocks appropriately within lifecycle hooks and other error-prone parts of the code.  Consider centralized error reporting mechanisms to aggregate errors from various sub-applications.\n\n\n## Advanced Configuration\n\n### Customizing the Qiankun Sandbox\n\nQiankun's default sandbox provides basic isolation, but for more stringent requirements or specific needs, you can customize the sandbox behavior. Qiankun allows you to provide a custom sandbox implementation.  This is particularly useful when dealing with conflicting libraries or global variables between sub-applications. A custom sandbox function receives the sub-application's entry point (`entry`) and the container element (`container`) as parameters and returns an object containing the `proxy` and `patch` functions.  These functions allow you to intercept and control access to global variables and the DOM.  Refer to the Qiankun documentation for detailed examples and instructions on how to implement a custom sandbox.  Careful consideration should be given to performance implications when implementing a custom sandbox, as overzealous sandboxing can lead to performance bottlenecks.\n\n\n### Asynchronous Loading of Sub-applications\n\nBy default, Qiankun loads sub-applications synchronously, meaning the main application waits for the sub-application to load before proceeding. For improved performance, especially in scenarios with many sub-applications or large sub-applications, you can implement asynchronous loading. This involves optimizing the network requests for the `remoteEntry.js` files and potentially using techniques like code-splitting or pre-fetching to pre-load resources.  However, be mindful of the added complexity asynchronous loading introduces to the overall architecture.\n\n\n### Using Different Frameworks for Sub-applications\n\nOne of Qiankun's significant strengths is its framework-agnostic nature. You can easily integrate sub-applications built with different frameworks (React, Vue, Angular, etc.) within a single main application.  The key is to ensure that each sub-application exports the correct lifecycle methods (`bootstrap`, `mount`, `unmount`) as expected by Qiankun's runtime. You might need to install framework-specific Qiankun packages (e.g., `@qiankun/vue` for Vue sub-applications) to ensure smooth integration.\n\n\n### Pre-loading Sub-applications\n\nPre-loading sub-applications can significantly improve perceived performance by loading resources before they're actually needed.  This can be implemented by fetching the necessary assets (e.g., JavaScript bundles) in the background while the user is interacting with other parts of the application.  Qiankun doesn't directly handle pre-loading, but you can implement this using browser APIs like `fetch` or other techniques such as resource hints (`<link rel=\"preload\">`).  Strategic implementation of pre-loading requires careful consideration to avoid excessive resource consumption and negatively impacting the user experience.\n\n\n### Implementing Custom Error Handling\n\nWhile Qiankun provides basic error handling, you can enhance it by implementing custom error-handling mechanisms.  This may involve creating custom error boundaries within the main application or individual sub-applications to catch and handle exceptions gracefully.  For instance, you could display informative error messages to the user, log errors to a centralized logging service, or implement fallback mechanisms.  Comprehensive error handling is crucial for building robust and reliable micro-frontend applications.\n\n\n### Performance Optimization Strategies\n\nPerformance optimization is crucial for large micro-frontend applications.  Strategies include:\n\n*   **Lazy Loading:** Load sub-applications only when they're needed, avoiding unnecessary resource loading.\n*   **Code Splitting:** Divide sub-application code into smaller chunks to optimize loading times.\n*   **Caching:** Utilize browser caching mechanisms to reduce repeated downloads.\n*   **Resource Hints:** Use `preload` and `prefetch` resource hints to proactively load assets.\n*   **Compression:** Optimize your application's assets using compression techniques (e.g., gzip).\n*   **Efficient Sandbox:** Consider the performance implications of custom sandboxing implementations.  Overly restrictive sandboxes can have a detrimental effect on performance.\n*   **Monitoring and Profiling:** Use browser developer tools and performance monitoring services to identify performance bottlenecks and optimize accordingly.\n\n\n\n\n## Deployment and Scaling\n\n### Deploying the Main Application\n\nDeploying the main application involves standard deployment procedures for your chosen framework and hosting platform.  This typically involves building the application (often creating a production-optimized build) and deploying the resulting artifacts (HTML, CSS, JavaScript, and assets) to a web server.  Ensure the server is configured correctly to serve the necessary files and handle routing to the various sub-applications based on the `activeRule` configuration within your main application.  The deployment process might involve using CI/CD pipelines to automate the build and deployment steps.  Consider using a reverse proxy or load balancer to manage incoming requests and distribute traffic effectively, especially as your application grows.\n\n\n### Deploying Sub-applications\n\nSub-applications are deployed independently, similar to the main application.  Each sub-application has its own build process and deployment pipeline.  The key difference is that the deployment target for each sub-application only needs to expose the `remoteEntry.js` file (or equivalent). This file serves as the entry point for Qiankun to load and mount the sub-application. The URL of this `remoteEntry.js` file needs to be accurately specified in the main application's configuration (`registerMicroApps`).  Deploying sub-applications independently allows for faster iteration cycles and parallel deployments.\n\n\n### Scaling Strategies\n\nScaling a micro-frontend application built with Qiankun involves scaling both the main application and the individual sub-applications.  Strategies include:\n\n*   **Horizontal Scaling:**  Deploy multiple instances of both the main application and sub-applications across multiple servers.  This distributes the load and enhances availability.  Consider using load balancers to distribute incoming traffic across the various instances.\n\n*   **Vertical Scaling:**  Increase the resources (CPU, memory, etc.) allocated to the servers hosting the main application and sub-applications.  This is suitable for handling increased load without deploying additional instances.\n\n*   **Database Scaling:**  If your application relies on a database, you might need to scale the database independently, potentially using techniques such as database sharding or replication.\n\n*   **Content Delivery Network (CDN):**  Using a CDN to cache static assets (e.g., JavaScript, CSS, images) can significantly reduce latency and improve performance, particularly for users located geographically distant from your servers.\n\nThe optimal scaling strategy depends on the specific requirements of your application, the anticipated load, and your budget.  Careful monitoring and performance analysis are crucial for making informed scaling decisions.\n\n\n### Monitoring and Logging\n\nImplementing robust monitoring and logging is essential for maintaining and scaling a micro-frontend application.  Consider using dedicated monitoring tools to track key metrics such as:\n\n*   **Application Performance:**  Track response times, error rates, and resource utilization.\n*   **Sub-application Performance:**  Monitor the performance of individual sub-applications to pinpoint bottlenecks or issues.\n*   **Network Requests:**  Analyze network requests to identify slowdowns or errors.\n*   **Error Logs:**  Aggregate error logs from the main application and all sub-applications for easier debugging.\n*   **Resource Usage:**  Monitor CPU, memory, and disk usage to ensure resources are used efficiently.\n\nCentralized logging and monitoring systems allow you to gain a holistic view of your application's health and performance.  This enables proactive identification and resolution of issues, ensuring a high level of availability and a positive user experience.\n\n\n## Best Practices and Troubleshooting\n\n### Code Organization and Maintainability\n\nMaintaining a clean and well-organized codebase is crucial for the long-term success of any project, especially a micro-frontend application.  For Qiankun projects, consider these best practices:\n\n*   **Modular Design:**  Structure your sub-applications and the main application using a modular design.  Break down large components into smaller, more manageable modules with well-defined interfaces.\n\n*   **Consistent Coding Style:**  Enforce a consistent coding style across all sub-applications and the main application using linters and formatters.\n\n*   **Version Control:**  Utilize a version control system (e.g., Git) to track changes, manage code branches, and facilitate collaboration.\n\n*   **Documentation:**  Write clear and concise documentation for each sub-application and the main application.  This will make it easier for developers to understand and maintain the code.\n\n*   **Clear Communication:**  Establish clear communication channels between teams working on different sub-applications.  This will prevent conflicts and ensure consistency.\n\n*   **Dependency Management:**  Manage dependencies effectively using package managers (e.g., npm, yarn) and consider using a monorepo if appropriate.  This simplifies dependency management and reduces conflicts.\n\n\n### Testing Strategies\n\nA robust testing strategy is essential for ensuring the quality and reliability of your Qiankun application.  Consider incorporating these testing approaches:\n\n*   **Unit Testing:**  Test individual components and modules in isolation.  This helps to identify bugs early in the development process.\n\n*   **Integration Testing:**  Test the interaction between different sub-applications and the main application.  This ensures that the different parts of the system work together correctly.\n\n*   **End-to-End (E2E) Testing:**  Test the entire application from the user's perspective.  This simulates real-world usage scenarios and helps to identify issues that might not be apparent during unit or integration testing.\n\n*   **Automated Testing:**  Automate your tests as much as possible. This will save time and ensure that your tests are run consistently.  CI/CD pipelines are excellent for integrating automated testing.\n\n*   **Test-Driven Development (TDD):**  Consider using TDD, where tests are written before the code, to guide the development process and improve code quality.\n\n\n### Common Issues and Solutions\n\nSome common issues encountered while working with Qiankun include:\n\n*   **Conflicts between JavaScript libraries:**  Use Qiankun's sandbox feature to isolate sub-applications and prevent conflicts between libraries.  Consider using custom sandboxes for more complex scenarios.\n\n*   **Communication problems between sub-applications and the main application:** Ensure you use appropriate communication mechanisms (e.g., `postMessage`, event bus, shared state management) and follow a consistent approach across the application.\n\n*   **Performance issues:**  Optimize the application's performance by implementing strategies like lazy loading, code splitting, and caching.\n\n*   **Deployment problems:**  Ensure you follow the correct deployment procedures for both the main application and the sub-applications.  Use CI/CD pipelines to automate the process and reduce errors.\n\n*   **Error handling issues:**  Implement comprehensive error handling mechanisms to gracefully handle exceptions and provide informative error messages to the user.\n\nConsult the Qiankun documentation and online resources for detailed solutions to specific issues.\n\n\n### Security Considerations\n\nSecurity is paramount in any software project. When using Qiankun, keep these considerations in mind:\n\n*   **Input Validation:**  Validate all user inputs to prevent cross-site scripting (XSS) attacks and other vulnerabilities.\n\n*   **Authentication and Authorization:**  Implement secure authentication and authorization mechanisms to protect sensitive data and resources.\n\n*   **Data Protection:**  Protect sensitive data using appropriate encryption and access control measures.\n\n*   **Regular Security Audits:** Conduct regular security audits to identify and address potential vulnerabilities.\n\n*   **Secure Deployment Practices:** Follow secure deployment practices to protect your application from attacks.\n\n*   **Sub-application Security:**  Ensure that each sub-application follows secure coding practices and implements appropriate security measures.\n\n*   **Dependency Security:**  Regularly scan your dependencies for known vulnerabilities and upgrade to the latest versions promptly.  Use tools like `npm audit` or similar for dependency scanning.  Consider using a dependency management tool with built-in security scanning.\n\n\n## API Reference\n\nThis section provides a concise overview of the core Qiankun APIs.  For detailed information and examples, refer to the official Qiankun documentation.  Note that the exact API might change slightly depending on the Qiankun version.\n\n### `registerMicroApps`\n\nThis function registers the micro-applications (sub-applications) with Qiankun.  It takes an array of application configurations as input and returns nothing.  Each configuration object must include at least the following properties:\n\n*   `name`: (string) A unique identifier for the micro-application.\n*   `entry`: (string) The URL of the micro-application's entry point (usually `remoteEntry.js`).\n*   `container`: (string | HTMLElement) A CSS selector or an HTMLElement that specifies where the micro-application will be rendered.\n*   `activeRule`: (string | RegExp) A rule (string or regular expression) that determines when the micro-application should be active.  This usually relates to URL routing in the main application.\n*   `props?`: (object) Optional props that will be passed to the micro-application's `mount` lifecycle function.  This is how you typically pass data from the main application to the sub-application.\n\n\nExample:\n\n```javascript\nregisterMicroApps([\n  {\n    name: 'app1',\n    entry: '//localhost:8000',\n    container: '#container',\n    activeRule: '/app1',\n  },\n]);\n```\n\n### `start`\n\nThis function starts Qiankun's lifecycle management.  It begins monitoring the URL and updates the active micro-applications accordingly.  It takes an optional configuration object as a parameter.  This allows for options such as setting the `prefetch` (whether to prefetch micro-applications), and `sandbox` settings. Calling `start()` is crucial after registering micro-apps via `registerMicroApps()`.\n\nExample:\n\n```javascript\nstart(); // Starts Qiankun\n```\n\n### `loadMicroApp`\n\nThis function loads a specific micro-application asynchronously.  It takes a configuration object similar to `registerMicroApps`, but only needs to specify a single sub-application. It returns a promise that resolves when the micro-application has successfully loaded and is ready to mount. Useful when you want to load a sub-application dynamically based on some other event outside of the initial routing.\n\nExample:\n\n```javascript\nloadMicroApp({\n    name: 'app1',\n    entry: '//localhost:8000',\n    container: '#container',\n}).then(() => console.log('app1 loaded'))\n```\n\n### `unmountRootParcel`\n\nThis function unmounts the specified micro-application.  This removes the sub-application from the DOM and performs the sub-application's `unmount` lifecycle method.  Takes the name of the application as an argument.  It's important for cleaning up resources.\n\nExample:\n\n```javascript\nunmountRootParcel('app1');\n```\n\n### `sandbox` (Custom Sandbox)\n\nWhile not a standalone function, the `sandbox` option within the `start()` function or within individual micro-application registrations lets you customize Qiankun's isolation mechanism.  By default, Qiankun uses a proxy-based sandbox.  You can provide a custom sandbox implementation to fine-tune the isolation level and control how the micro-application interacts with the global environment of the main application.  This requires a detailed understanding of Qiankun's internal mechanisms and is generally needed only in advanced scenarios.\n\n\n### `qiankun.initGlobalState`\n\nThis function initializes a global state instance.  This state can then be used for communication and data sharing between the main application and sub-applications.  It takes an initial state object as an argument and returns a global state instance.  The instance provides methods to access and update the shared state.  The global state is typically used to transmit data and update application settings.\n\nExample:\n\n```javascript\nconst globalState = qiankun.initGlobalState({ count: 0 });\n```\n\n\n### `qiankun.getGlobalState`\n\nThis function retrieves the global state instance initialized by `qiankun.initGlobalState`. This provides a way for any part of the micro-frontend application (both main application and sub-applications) to access the global state and retrieve information.\n\nExample:\n\n```javascript\nconst globalState = qiankun.getGlobalState();\n```\n\nRemember that while these functions provide a simplified overview, referring to the official Qiankun documentation is crucial for more detailed information, including advanced options and error handling.\n\n\n## Examples and Use Cases\n\n### Simple Example: Two Sub-applications\n\nThis example demonstrates a simple setup with two sub-applications.  Assume you have two React applications: `app1` and `app2`.  Each is a standard Create React App project, but they have been modified to export the Qiankun lifecycle methods (`bootstrap`, `mount`, `unmount`).  They also have been built to output a `remoteEntry.js` file containing this export.\n\n**Main Application (`index.js`):**\n\n```javascript\nimport { registerMicroApps, start } from 'qiankun';\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n\n\nregisterMicroApps([\n  {\n    name: 'app1',\n    entry: '//localhost:8080/remoteEntry.js',  // Replace with your app1 URL\n    container: '#subapp',\n    activeRule: '/app1',\n  },\n  {\n    name: 'app2',\n    entry: '//localhost:8081/remoteEntry.js',  // Replace with your app2 URL\n    container: '#subapp',\n    activeRule: '/app2',\n  },\n]);\n\nstart();\n\nreportWebVitals();\n```\n\n**Main Application (`App.js`):**\n\n```javascript\nimport React from 'react';\nimport { Link } from 'react-router-dom';\nimport { BrowserRouter as Router, Route, Routes } from 'react-router-dom';\n\n\nfunction App() {\n  return (\n    <Router>\n      <div>\n        <nav>\n          <Link to=\"/app1\">App 1</Link>{' '}\n          <Link to=\"/app2\">App 2</Link>\n        </nav>\n        <div id=\"subapp\"></div>\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n```\n\nRemember that you need a `<div id=\"subapp\"></div>` in your main application's HTML.  This is where the sub-applications will be rendered.  App1 and App2 need to have their own routing configurations within the `remoteEntry.js` build output.\n\n\n### Complex Example: Multiple Sub-applications and Data Sharing\n\nFor more complex scenarios with numerous sub-applications and data sharing, consider using a centralized state management solution like Redux or Zustand.  The global state provided by Qiankun (`qiankun.initGlobalState` and `qiankun.getGlobalState`) can also be a solution, but for larger applications, a more robust solution may be needed to avoid unexpected behavior.  Sub-applications can access and update this shared state, enabling communication and data exchange.  The main application might also act as a central hub, coordinating data flow between sub-applications.\n\n\n### Real-world Use Cases\n\nQiankun is suitable for various real-world scenarios:\n\n*   **Large-scale enterprise applications:**  Breaking down monolithic applications into smaller, independently deployable units.\n\n*   **Legacy system modernization:**  Gradually migrating legacy systems to a modern micro-frontend architecture.\n\n*   **Team collaboration:**  Enabling teams to work independently on different parts of an application.\n\n*   **A/B testing:**  Deploying different versions of sub-applications for A/B testing purposes.\n\n*   **Third-party integrations:**  Integrating third-party applications as sub-applications.\n\n\n### Integrating with Other Libraries\n\nQiankun can be integrated with various libraries to enhance functionality:\n\n*   **Routing libraries:**  Libraries like React Router or Vue Router can be used to manage navigation within the main application and sub-applications.\n\n*   **State management libraries:**  Libraries like Redux, Vuex, or MobX can be used for state management within sub-applications and to facilitate data sharing.\n\n*   **UI libraries:**  Any UI library (e.g., Material-UI, Ant Design, Element UI) can be used within the sub-applications.\n\n*   **Testing libraries:**  Integration with testing libraries like Jest and Cypress helps in building a robust testing strategy.\n\nThe choice of libraries depends on the specific requirements and preferences of your project.  Ensure compatibility between the libraries and Qiankun.\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["../../styles.css"],"html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"},"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"},"../../footer.html"],"output-file":"qiankun.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"license":"MIT","author-meta":"Muthukrishnan","title":"qiankun - Documentation","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}