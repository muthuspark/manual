{"title":"URI.js - A Developer's Handbook","markdown":{"yaml":{"title":"URI.js - A Developer's Handbook","categories":["JavaScript Libraries and Functions"]},"headingText":"Introduction to URI.js","containsRefs":false,"markdown":"\n\n### What is URI.js?\n\nURI.js is a lightweight, robust, and versatile JavaScript library for parsing, manipulating, and serializing URIs (Uniform Resource Identifiers), including URLs (Uniform Resource Locators). It provides a consistent and easy-to-use interface for working with the various components of a URI, such as scheme, host, port, path, query, and fragment.  Unlike many other libraries that focus solely on URLs, URI.js handles the broader scope of URIs, supporting a wider range of URI schemes.\n\n### Why use URI.js?\n\nURI.js offers several advantages over manually parsing and manipulating URIs:\n\n* **Robustness:**  Handles edge cases and malformed URIs gracefully, providing sensible defaults and error handling.\n* **Consistency:** Ensures consistent URI handling across different browsers and environments.\n* **Ease of Use:**  Provides a simple and intuitive API for common URI manipulation tasks.\n* **Feature-Rich:** Supports a wide range of URI schemes and features, including percent-encoding and normalization.\n* **Lightweight:**  Has a small footprint, minimizing the impact on your application's performance.\n* **Extensible:** Offers flexibility to work with custom URI schemes and components.\n\n### Installation and Setup\n\nURI.js can be installed via several methods:\n\n* **npm:**\n  ```bash\n  npm install uri-js\n  ```\n\n* **yarn:**\n  ```bash\n  yarn add uri-js\n  ```\n\n* **CDN (e.g., jsDelivr):** Include the library directly in your HTML using a `<script>` tag:\n  ```html\n  <script src=\"https://cdn.jsdelivr.net/npm/uri-js@latest/src/URI.min.js\"></script>\n  ```\n\nAfter installation, you can import and use URI.js in your JavaScript code:\n\n\n* **ES Modules (if using npm or yarn):**\n\n```javascript\nimport URI from 'uri-js';\n// or\nimport { URI } from 'uri-js';\n```\n\n* **CommonJS (if using npm or yarn):**\n\n```javascript\nconst URI = require('uri-js');\n```\n\n* **Global Variable (if using CDN):**  The `URI` constructor will be available globally.\n\n\n### Basic Usage Examples\n\nHere are some basic examples demonstrating the core functionality of URI.js:\n\n\n**Creating a URI:**\n\n```javascript\nconst uri = new URI('http://example.com/path?query=string#fragment');\nconsole.log(uri.toString()); // Output: http://example.com/path?query=string#fragment\n```\n\n**Accessing URI components:**\n\n```javascript\nconsole.log(uri.protocol());  // Output: http\nconsole.log(uri.hostname()); // Output: example.com\nconsole.log(uri.path());     // Output: /path\nconsole.log(uri.query());    // Output: query=string\nconsole.log(uri.fragment()); // Output: fragment\n```\n\n**Modifying URI components:**\n\n```javascript\nuri.path('/new/path');\nuri.query({ newQuery: 'value' });\nuri.fragment('newFragment');\nconsole.log(uri.toString()); // Output: http://example.com/new/path?newQuery=value#newFragment\n\n```\n\n**Parsing a URI string:**\n\n```javascript\nconst parsedUri = URI.parse('ftp://user:password@host:port/path');\nconsole.log(parsedUri); // Output: Object containing parsed URI components\n```\n\n**Resolve a relative URI:**\n\n```javascript\nconst baseUri = new URI(\"http://example.org/dir1/dir2/\");\nconst relativeUri = new URI(\"./file.txt\");\nconst resolvedUri = baseUri.resolve(relativeUri);\nconsole.log(resolvedUri.toString()); //Output: http://example.org/dir1/dir2/file.txt\n\n```\n\nThese examples illustrate the basic capabilities.  The URI.js API provides many more methods for advanced URI manipulation.  Refer to the full API documentation for comprehensive details.\n\n\n## Core Functionality\n\n### Creating URIs\n\nURI.js offers several ways to create URI objects:\n\n**1. Using the constructor with a string:**\n\nThe most common method is to pass a URI string directly to the constructor:\n\n```javascript\nconst uri = new URI('https://example.com/path?param=value#fragment');\nconsole.log(uri.toString()); // Output: https://example.com/path?param=value#fragment\n```\n\nThis handles various URI formats, including those with or without components.  If an invalid URI string is provided, URI.js will attempt to create a URI object representing what it can parse, potentially leaving certain components undefined.\n\n**2. Using the constructor with an object:**\n\nYou can also create a URI object from a JavaScript object containing URI components:\n\n```javascript\nconst uri = new URI({\n  scheme: 'ftp',\n  username: 'user',\n  password: 'password',\n  host: 'example.org',\n  port: 21,\n  path: '/path/to/file',\n  query: {param1: 'value1', param2: 'value2'},\n  fragment: 'anchor'\n});\nconsole.log(uri.toString());\n//Output: ftp://user:password@example.org:21/path/to/file?param1=value1&param2=value2#anchor\n```\n\nThis approach is useful for programmatically constructing URIs.  Note that not all components are required.\n\n**3. Using `URI.create`:**\n\nThe static method `URI.create` provides a convenient alternative to the constructor. It accepts the same arguments:\n\n```javascript\nconst uri = URI.create('http://example.net');\nconsole.log(uri.toString()); // Output: http://example.net\n```\n\n\n\n### Parsing URIs\n\nURI.js provides the `URI.parse` method for parsing a URI string into a JavaScript object representing its components:\n\n\n```javascript\nconst parsedUri = URI.parse('mailto:someone@example.com?subject=Hello');\nconsole.log(parsedUri);\n// Output: { scheme: 'mailto', userInfo: 'someone', host: 'example.com', path: '', query: { subject: 'Hello' } }\n```\n\nThe resulting object contains properties like `scheme`, `host`, `path`, `query`, etc.  `URI.parse` doesn't throw errors for malformed URIs; it handles them gracefully,  returning an object with as much information as possible and leaving unspecified components undefined.\n\n\n### Accessing URI Components\n\nOnce you have a URI object, you can access its individual components using various getter methods:\n\n```javascript\nconst uri = new URI('https://user:pass@www.example.com:8080/path/to/file?query=string#fragment');\n\nconsole.log(uri.scheme());      // Output: https\nconsole.log(uri.username());    // Output: user\nconsole.log(uri.password());    // Output: pass\nconsole.log(uri.host());       // Output: www.example.com\nconsole.log(uri.port());       // Output: 8080\nconsole.log(uri.hostname());   //Output: www.example.com\nconsole.log(uri.path());       // Output: /path/to/file\nconsole.log(uri.query());      // Output: query=string  (String representation)\nconsole.log(uri.query(true)); // Output: { query: 'string' } (Object representation)\nconsole.log(uri.fragment());   // Output: fragment\n```\n\n\nThe `query()` method allows accessing the query string as either a string or a parsed object (using `query(true)`).  Methods like `authority()`, `origin()` and `toString()` provide convenient access to composite parts of the URI.\n\n### Modifying URI Components\n\nURI.js allows you to modify URI components using various setter methods:\n\n```javascript\nlet uri = new URI('http://example.com/oldPath');\n\nuri.scheme('https');\nuri.host('newExample.com');\nuri.path('/newPath');\nuri.query({ newParam: 'newValue' }); // sets a new query parameter\nuri.fragment('newFragment');\n\nconsole.log(uri.toString());\n// Output: https://newExample.com/newPath?newParam=newValue#newFragment\n```\n\nYou can also use methods such as `addQuery`, `removeQuery` for more fine-grained control over query parameters.  Additionally, methods exist for manipulating the path component, such as `addPath` and `removePath`.\n\n\n### Stringifying URIs\n\nThe `toString()` method converts a URI object back into its string representation:\n\n```javascript\nconst uri = new URI({ scheme: 'sftp', host: 'example.org', path: '/file.txt' });\nconsole.log(uri.toString()); // Output: sftp://example.org/file.txt\n```\n\nThis method automatically handles the correct formatting and escaping of URI components.  You can optionally specify a `serializeQuery` parameter to control how the query string is serialized.\n\n\n## Advanced Usage\n\n### Working with Query Parameters\n\nURI.js provides robust methods for manipulating query parameters.  Beyond simple setting with `uri.query({key: 'value'})`,  you can:\n\n* **Add parameters:** Use `addQuery(key, value)` to add individual parameters, or `addQuery(queryObject)` to add multiple parameters from a key-value object.\n\n* **Remove parameters:** Use `removeQuery(key)` to remove a specific parameter or `removeQuery()` with no arguments to clear all query parameters.\n\n* **Get individual parameters:** Access individual parameters using `query(true)[key]` to safely access a specific query parameter (handling cases where it might not exist).\n\n* **Iterate over parameters:** Use a `for...in` loop on `uri.query(true)` to iterate over all query parameters,  handling the parsed object representation.\n\n```javascript\nlet uri = new URI('https://example.com/path?param1=value1');\n\nuri.addQuery('param2', 'value2');\nuri.addQuery({ param3: 'value3' });\nconsole.log(uri.toString()); // Output: https://example.com/path?param1=value1&param2=value2&param3=value3\n\nuri.removeQuery('param1');\nconsole.log(uri.toString()); // Output: https://example.com/path?param2=value2&param3=value3\n\nconsole.log(uri.query(true).param2); //Output: value2\n\nfor (const key in uri.query(true)) {\n  console.log(key, uri.query(true)[key]);\n}\n```\n\n\n### Handling Fragments\n\nThe fragment component (the part after the `#` symbol) can be accessed and modified using the `fragment()` method.\n\n```javascript\nlet uri = new URI('https://example.com/page#section1');\nconsole.log(uri.fragment()); // Output: section1\n\nuri.fragment('section2');\nconsole.log(uri.toString()); // Output: https://example.com/page#section2\n\nuri.fragment(''); // Clear the fragment\nconsole.log(uri.toString()); // Output: https://example.com/page\n```\n\nNote that URI.js handles the proper encoding/decoding of fragment identifiers.\n\n\n### Encoding and Decoding\n\nURI.js uses the `encodeComponent` and `decodeComponent` methods to encode and decode URI components according to RFC3986. This ensures that special characters are properly escaped and unescaped within the URI.\n\n```javascript\nlet encoded = URI.encodeComponent('Space+Chars?'); // Output: Space%2BChars%3F\nlet decoded = URI.decodeComponent(encoded);     // Output: Space+Chars?\n```\nThese methods are crucial when dealing with dynamic content or user-provided input within URIs, preventing issues caused by unescaped characters.  Remember to appropriately encode components before including them in a URI object.\n\n### Relative vs. Absolute URIs\n\nURI.js can handle both relative and absolute URIs.  The `isAbsolute()` method checks if a given URI is absolute. The `resolve()` method allows you to resolve a relative URI against a base URI.\n\n```javascript\nconst base = new URI('https://example.com/base/path');\nconst relative = new URI('../relative/path');\nconst resolved = base.resolve(relative);\nconsole.log(resolved.toString()); //Output: https://example.com/relative/path\n```\n\nUnderstanding this distinction is critical for correct URI manipulation, especially when working with links and paths in web applications.\n\n\n### Normalization and Resolution\n\nURI.js performs normalization automatically when creating and manipulating URIs. This includes simplifying paths (removing redundant `.` and `..` segments) and ensuring consistent representation.  The `normalize()` method can be called explicitly if needed. The `resolve` method, shown above, handles relative URI resolution correctly, accounting for path normalization and base URI components.\n\n### Custom Schemes and Protocols\n\nWhile URI.js primarily focuses on standard URI schemes, it provides some flexibility for handling custom schemes.  The core functionality for parsing and manipulating components remains consistent even with non-standard schemes. However, you'll need to manage the specific behavior and semantics associated with your custom scheme within your application logic.  URI.js won't inherently understand the meaning or processing requirements of a non-standard scheme; it simply handles the URI structure itself.\n\n\n## Error Handling and Best Practices\n\n### Common Errors and Troubleshooting\n\nMost errors with URI.js stem from incorrect input or unexpected URI formats. Here's a breakdown of common issues:\n\n* **Invalid URI strings:** Passing an invalid URI string to the constructor or `URI.parse` won't throw exceptions, but may result in an object with incomplete or undefined components.  Always validate user-provided URIs before processing.\n\n* **Encoding issues:**  Incorrectly encoded or decoded components can lead to unexpected behavior. Ensure that you use `URI.encodeComponent` and `URI.decodeComponent` where needed, especially when dealing with user input.\n\n* **Path manipulation:**  Incorrect use of path manipulation methods (`addPath`, `removePath`, etc.) can lead to unexpected path structures. Be mindful of relative vs. absolute paths.\n\n* **Query parameter handling:**  Errors occur if you try to access non-existent query parameters. Always check for the existence of parameters before accessing them.\n\nDebugging:  Use `console.log` to inspect the URI object's components at various stages to identify errors.  Also, carefully review the return values from methods to ensure they are as expected.  Consider using a linter to help with static code analysis.\n\n\n### Security Considerations\n\n* **Input sanitization:** Always sanitize user-provided URI strings before using them. This prevents potential injection attacks or unexpected behavior from malformed URIs.  Never directly trust user input when constructing URIs.\n\n* **Output encoding:** Ensure proper encoding of URI components, especially when generating URLs or links to be displayed to users.  This prevents XSS vulnerabilities.\n\n* **Avoid direct manipulation of the URI object's internal properties:**  Use the provided methods for modification. Direct manipulation can bypass important checks and validation, leading to inconsistencies and security risks.\n\n* **Use of the `toString()` method:**  Use the `toString()` method for serialization; don’t attempt to manually reconstruct the URI string from components. This ensures proper encoding and formatting.\n\n\n### Performance Optimization\n\nURI.js is already quite efficient.  However, for optimal performance in large-scale applications:\n\n* **Avoid unnecessary object creation:**  If you're performing many operations on the same URI, reuse the existing URI object instead of constantly creating new ones.\n\n* **Use appropriate methods:** Choose the most efficient method for the task.  Using `addQuery` is better than recreating the entire query string for a minor change.\n\n* **Cache parsed URIs:** In scenarios with a fixed set of URIs, consider pre-parsing and caching them to avoid repeated parsing overhead.\n\n* **Batch operations:** When you need to perform multiple operations on a URI, combine them into a single operation whenever possible. This reduces the number of object manipulations.\n\n\n### Working with Different Browsers and Environments\n\nURI.js is designed to work consistently across different browsers and environments. It handles inconsistencies in browser implementations and provides a uniform API.  However:\n\n* **Compatibility testing:** It's always recommended to test your application with different browsers and versions to ensure compatibility.\n\n* **Polyfills:** While URI.js itself doesn't require any polyfills for modern browsers, if you are targeting very old browsers you may need to ensure your environment includes appropriate polyfills for the JavaScript features it uses.\n\n* **Node.js compatibility:** URI.js works seamlessly in Node.js environments through `npm` or `yarn` installation.  No browser-specific adjustments are needed.\n\n\n\n\n## API Reference\n\nThis section provides a comprehensive reference for the URI.js API.  Note that the exact methods and properties might vary slightly depending on the version of URI.js you are using.  Always refer to the latest documentation on the project's website for the most up-to-date information.\n\n\n### URI Object\n\nThe core of URI.js is the `URI` object.  It's created using the `new URI(uriString)` constructor or `URI.create(uriString or uriObject)` method.  This object represents a parsed URI and provides methods for accessing and manipulating its components.  The `URI` object does *not* inherit from any specific JavaScript prototype.\n\n### Methods and Properties\n\nThe `URI` object exposes numerous methods for accessing and modifying URI components.  Key methods include (but are not limited to):\n\n* **`scheme()`**: Getter and setter for the URI scheme (e.g., `http`, `https`, `ftp`).\n\n* **`username()`**, **`password()`**: Getters and setters for the username and password components of the URI's authority (often used with `ftp` and other protocols).\n\n* **`host()`**: Getter and setter for the host component (hostname or IP address).\n\n* **`hostname()`**: Getter for the hostname, separated from the port.\n\n* **`port()`**: Getter and setter for the port number.\n\n* **`path()`**: Getter and setter for the path component.  Several methods help manipulate paths, such as `addPath()`, `removePath()`.\n\n* **`query()`**: Getter and setter for the query component.  It accepts a boolean argument: `true` returns a parsed object of query parameters, `false` (default) returns a string. Methods like `addQuery()`, `removeQuery()` facilitate fine-grained control of parameters.\n\n* **`fragment()`**: Getter and setter for the fragment component.\n\n* **`authority()`**: Getter for the `username:password@host:port` component.\n\n* **`origin()`**: Getter for the origin (`scheme://host:port`).\n\n* **`toString()`**: Converts the URI object back into its string representation.\n\n* **`isAbsolute()`**:  Checks if the URI is an absolute URI.\n\n* **`normalize()`**: Normalizes the URI (e.g., simplifying the path).\n\n* **`resolve(relativeUri)`**:  Resolves a relative URI against the current URI.\n\n\n* **`equals(otherUri)`**: Checks if two URI objects are equal.\n\nFor a complete list and detailed descriptions, always consult the official API documentation.  The exact syntax and capabilities may evolve with URI.js updates.\n\n\n### Static Methods\n\nURI.js provides several static methods, primarily `URI.parse()` and `URI.create()`.\n\n* **`URI.parse(uriString)`**: Parses a URI string and returns an object representing its components.  It is more lenient about malformed input than the constructor.\n\n* **`URI.encodeComponent(component)`**:  Percent-encodes a URI component string.\n\n* **`URI.decodeComponent(component)`**:  Percent-decodes a URI component string.\n\n\n### Events (if applicable)\n\nURI.js itself does not have an event system.  It's a utility library focused on URI manipulation; any events would be handled within the application using the modified URI objects.  There are no built-in events triggered by the library's methods.\n\n\n## Contributing to URI.js\n\nThis section outlines how to contribute to the URI.js project.  Contributions are welcome and appreciated!  Before contributing, please take some time to familiarize yourself with the project's guidelines and coding style.\n\n### Code Style Guide\n\nURI.js follows a consistent coding style to ensure readability and maintainability.  The primary style guide is generally consistent with standard JavaScript conventions, emphasizing clarity and simplicity.\n\n* **Indentation:** Use 2 spaces for indentation.\n\n* **Line length:** Keep lines under 80 characters.\n\n* **Semicolons:** Use semicolons consistently to terminate statements.\n\n* **Variable naming:** Use descriptive and consistent variable names (camelCase).\n\n* **Comments:** Write clear and concise comments explaining complex logic or non-obvious code sections.\n\nSpecific style preferences might be documented within the project's source code or in a separate style guide file.  It's recommended to review the existing codebase to understand the preferred style before making any changes.\n\n\n### Testing and Debugging\n\nURI.js utilizes a comprehensive test suite.  All contributions should include corresponding tests to ensure correctness and prevent regressions.  The tests are typically written using a unit testing framework (check the project's documentation for specifics on the testing framework used).  To run the tests:\n\n1. **Clone the repository:** Obtain a local copy of the URI.js repository.\n\n2. **Install dependencies:**  Install the project's dependencies (e.g., using npm or yarn).\n\n3. **Run the tests:** Execute the test runner command (instructions will be in the project's README or contributing guide).\n\nDebugging can be done using standard JavaScript debugging tools in your IDE or browser's developer console.  Use `console.log` strategically to inspect variable values and the flow of execution during testing and development.\n\n\n### Submitting Pull Requests\n\n1. **Fork the repository:** Create a fork of the main URI.js repository on GitHub.\n\n2. **Create a branch:** Create a new branch for your changes. Use descriptive branch names (e.g., `fix/bug-123` or `feature/new-method`).\n\n3. **Make your changes:** Implement your changes and write comprehensive tests. Ensure your code adheres to the project's code style guide.\n\n4. **Commit your changes:** Commit your changes with clear and concise messages describing your modifications.\n\n5. **Push your branch:** Push your branch to your forked repository.\n\n6. **Create a pull request:**  Submit a pull request to the main URI.js repository.  Provide a detailed description of your changes and their purpose in the pull request description.\n\n\n### Community Support\n\nFor questions, discussions, or help with using URI.js, please use the project's designated channels for community support (e.g., GitHub Issues, a forum, a dedicated chat channel).  Be sure to check the project's documentation and existing issues before posting to avoid duplicates.  Respectful and constructive communication is essential when interacting with the project's maintainers and other community members.  Provide clear and concise descriptions of your questions or problems, including relevant code snippets and error messages.\n\n","srcMarkdownNoYaml":"\n## Introduction to URI.js\n\n### What is URI.js?\n\nURI.js is a lightweight, robust, and versatile JavaScript library for parsing, manipulating, and serializing URIs (Uniform Resource Identifiers), including URLs (Uniform Resource Locators). It provides a consistent and easy-to-use interface for working with the various components of a URI, such as scheme, host, port, path, query, and fragment.  Unlike many other libraries that focus solely on URLs, URI.js handles the broader scope of URIs, supporting a wider range of URI schemes.\n\n### Why use URI.js?\n\nURI.js offers several advantages over manually parsing and manipulating URIs:\n\n* **Robustness:**  Handles edge cases and malformed URIs gracefully, providing sensible defaults and error handling.\n* **Consistency:** Ensures consistent URI handling across different browsers and environments.\n* **Ease of Use:**  Provides a simple and intuitive API for common URI manipulation tasks.\n* **Feature-Rich:** Supports a wide range of URI schemes and features, including percent-encoding and normalization.\n* **Lightweight:**  Has a small footprint, minimizing the impact on your application's performance.\n* **Extensible:** Offers flexibility to work with custom URI schemes and components.\n\n### Installation and Setup\n\nURI.js can be installed via several methods:\n\n* **npm:**\n  ```bash\n  npm install uri-js\n  ```\n\n* **yarn:**\n  ```bash\n  yarn add uri-js\n  ```\n\n* **CDN (e.g., jsDelivr):** Include the library directly in your HTML using a `<script>` tag:\n  ```html\n  <script src=\"https://cdn.jsdelivr.net/npm/uri-js@latest/src/URI.min.js\"></script>\n  ```\n\nAfter installation, you can import and use URI.js in your JavaScript code:\n\n\n* **ES Modules (if using npm or yarn):**\n\n```javascript\nimport URI from 'uri-js';\n// or\nimport { URI } from 'uri-js';\n```\n\n* **CommonJS (if using npm or yarn):**\n\n```javascript\nconst URI = require('uri-js');\n```\n\n* **Global Variable (if using CDN):**  The `URI` constructor will be available globally.\n\n\n### Basic Usage Examples\n\nHere are some basic examples demonstrating the core functionality of URI.js:\n\n\n**Creating a URI:**\n\n```javascript\nconst uri = new URI('http://example.com/path?query=string#fragment');\nconsole.log(uri.toString()); // Output: http://example.com/path?query=string#fragment\n```\n\n**Accessing URI components:**\n\n```javascript\nconsole.log(uri.protocol());  // Output: http\nconsole.log(uri.hostname()); // Output: example.com\nconsole.log(uri.path());     // Output: /path\nconsole.log(uri.query());    // Output: query=string\nconsole.log(uri.fragment()); // Output: fragment\n```\n\n**Modifying URI components:**\n\n```javascript\nuri.path('/new/path');\nuri.query({ newQuery: 'value' });\nuri.fragment('newFragment');\nconsole.log(uri.toString()); // Output: http://example.com/new/path?newQuery=value#newFragment\n\n```\n\n**Parsing a URI string:**\n\n```javascript\nconst parsedUri = URI.parse('ftp://user:password@host:port/path');\nconsole.log(parsedUri); // Output: Object containing parsed URI components\n```\n\n**Resolve a relative URI:**\n\n```javascript\nconst baseUri = new URI(\"http://example.org/dir1/dir2/\");\nconst relativeUri = new URI(\"./file.txt\");\nconst resolvedUri = baseUri.resolve(relativeUri);\nconsole.log(resolvedUri.toString()); //Output: http://example.org/dir1/dir2/file.txt\n\n```\n\nThese examples illustrate the basic capabilities.  The URI.js API provides many more methods for advanced URI manipulation.  Refer to the full API documentation for comprehensive details.\n\n\n## Core Functionality\n\n### Creating URIs\n\nURI.js offers several ways to create URI objects:\n\n**1. Using the constructor with a string:**\n\nThe most common method is to pass a URI string directly to the constructor:\n\n```javascript\nconst uri = new URI('https://example.com/path?param=value#fragment');\nconsole.log(uri.toString()); // Output: https://example.com/path?param=value#fragment\n```\n\nThis handles various URI formats, including those with or without components.  If an invalid URI string is provided, URI.js will attempt to create a URI object representing what it can parse, potentially leaving certain components undefined.\n\n**2. Using the constructor with an object:**\n\nYou can also create a URI object from a JavaScript object containing URI components:\n\n```javascript\nconst uri = new URI({\n  scheme: 'ftp',\n  username: 'user',\n  password: 'password',\n  host: 'example.org',\n  port: 21,\n  path: '/path/to/file',\n  query: {param1: 'value1', param2: 'value2'},\n  fragment: 'anchor'\n});\nconsole.log(uri.toString());\n//Output: ftp://user:password@example.org:21/path/to/file?param1=value1&param2=value2#anchor\n```\n\nThis approach is useful for programmatically constructing URIs.  Note that not all components are required.\n\n**3. Using `URI.create`:**\n\nThe static method `URI.create` provides a convenient alternative to the constructor. It accepts the same arguments:\n\n```javascript\nconst uri = URI.create('http://example.net');\nconsole.log(uri.toString()); // Output: http://example.net\n```\n\n\n\n### Parsing URIs\n\nURI.js provides the `URI.parse` method for parsing a URI string into a JavaScript object representing its components:\n\n\n```javascript\nconst parsedUri = URI.parse('mailto:someone@example.com?subject=Hello');\nconsole.log(parsedUri);\n// Output: { scheme: 'mailto', userInfo: 'someone', host: 'example.com', path: '', query: { subject: 'Hello' } }\n```\n\nThe resulting object contains properties like `scheme`, `host`, `path`, `query`, etc.  `URI.parse` doesn't throw errors for malformed URIs; it handles them gracefully,  returning an object with as much information as possible and leaving unspecified components undefined.\n\n\n### Accessing URI Components\n\nOnce you have a URI object, you can access its individual components using various getter methods:\n\n```javascript\nconst uri = new URI('https://user:pass@www.example.com:8080/path/to/file?query=string#fragment');\n\nconsole.log(uri.scheme());      // Output: https\nconsole.log(uri.username());    // Output: user\nconsole.log(uri.password());    // Output: pass\nconsole.log(uri.host());       // Output: www.example.com\nconsole.log(uri.port());       // Output: 8080\nconsole.log(uri.hostname());   //Output: www.example.com\nconsole.log(uri.path());       // Output: /path/to/file\nconsole.log(uri.query());      // Output: query=string  (String representation)\nconsole.log(uri.query(true)); // Output: { query: 'string' } (Object representation)\nconsole.log(uri.fragment());   // Output: fragment\n```\n\n\nThe `query()` method allows accessing the query string as either a string or a parsed object (using `query(true)`).  Methods like `authority()`, `origin()` and `toString()` provide convenient access to composite parts of the URI.\n\n### Modifying URI Components\n\nURI.js allows you to modify URI components using various setter methods:\n\n```javascript\nlet uri = new URI('http://example.com/oldPath');\n\nuri.scheme('https');\nuri.host('newExample.com');\nuri.path('/newPath');\nuri.query({ newParam: 'newValue' }); // sets a new query parameter\nuri.fragment('newFragment');\n\nconsole.log(uri.toString());\n// Output: https://newExample.com/newPath?newParam=newValue#newFragment\n```\n\nYou can also use methods such as `addQuery`, `removeQuery` for more fine-grained control over query parameters.  Additionally, methods exist for manipulating the path component, such as `addPath` and `removePath`.\n\n\n### Stringifying URIs\n\nThe `toString()` method converts a URI object back into its string representation:\n\n```javascript\nconst uri = new URI({ scheme: 'sftp', host: 'example.org', path: '/file.txt' });\nconsole.log(uri.toString()); // Output: sftp://example.org/file.txt\n```\n\nThis method automatically handles the correct formatting and escaping of URI components.  You can optionally specify a `serializeQuery` parameter to control how the query string is serialized.\n\n\n## Advanced Usage\n\n### Working with Query Parameters\n\nURI.js provides robust methods for manipulating query parameters.  Beyond simple setting with `uri.query({key: 'value'})`,  you can:\n\n* **Add parameters:** Use `addQuery(key, value)` to add individual parameters, or `addQuery(queryObject)` to add multiple parameters from a key-value object.\n\n* **Remove parameters:** Use `removeQuery(key)` to remove a specific parameter or `removeQuery()` with no arguments to clear all query parameters.\n\n* **Get individual parameters:** Access individual parameters using `query(true)[key]` to safely access a specific query parameter (handling cases where it might not exist).\n\n* **Iterate over parameters:** Use a `for...in` loop on `uri.query(true)` to iterate over all query parameters,  handling the parsed object representation.\n\n```javascript\nlet uri = new URI('https://example.com/path?param1=value1');\n\nuri.addQuery('param2', 'value2');\nuri.addQuery({ param3: 'value3' });\nconsole.log(uri.toString()); // Output: https://example.com/path?param1=value1&param2=value2&param3=value3\n\nuri.removeQuery('param1');\nconsole.log(uri.toString()); // Output: https://example.com/path?param2=value2&param3=value3\n\nconsole.log(uri.query(true).param2); //Output: value2\n\nfor (const key in uri.query(true)) {\n  console.log(key, uri.query(true)[key]);\n}\n```\n\n\n### Handling Fragments\n\nThe fragment component (the part after the `#` symbol) can be accessed and modified using the `fragment()` method.\n\n```javascript\nlet uri = new URI('https://example.com/page#section1');\nconsole.log(uri.fragment()); // Output: section1\n\nuri.fragment('section2');\nconsole.log(uri.toString()); // Output: https://example.com/page#section2\n\nuri.fragment(''); // Clear the fragment\nconsole.log(uri.toString()); // Output: https://example.com/page\n```\n\nNote that URI.js handles the proper encoding/decoding of fragment identifiers.\n\n\n### Encoding and Decoding\n\nURI.js uses the `encodeComponent` and `decodeComponent` methods to encode and decode URI components according to RFC3986. This ensures that special characters are properly escaped and unescaped within the URI.\n\n```javascript\nlet encoded = URI.encodeComponent('Space+Chars?'); // Output: Space%2BChars%3F\nlet decoded = URI.decodeComponent(encoded);     // Output: Space+Chars?\n```\nThese methods are crucial when dealing with dynamic content or user-provided input within URIs, preventing issues caused by unescaped characters.  Remember to appropriately encode components before including them in a URI object.\n\n### Relative vs. Absolute URIs\n\nURI.js can handle both relative and absolute URIs.  The `isAbsolute()` method checks if a given URI is absolute. The `resolve()` method allows you to resolve a relative URI against a base URI.\n\n```javascript\nconst base = new URI('https://example.com/base/path');\nconst relative = new URI('../relative/path');\nconst resolved = base.resolve(relative);\nconsole.log(resolved.toString()); //Output: https://example.com/relative/path\n```\n\nUnderstanding this distinction is critical for correct URI manipulation, especially when working with links and paths in web applications.\n\n\n### Normalization and Resolution\n\nURI.js performs normalization automatically when creating and manipulating URIs. This includes simplifying paths (removing redundant `.` and `..` segments) and ensuring consistent representation.  The `normalize()` method can be called explicitly if needed. The `resolve` method, shown above, handles relative URI resolution correctly, accounting for path normalization and base URI components.\n\n### Custom Schemes and Protocols\n\nWhile URI.js primarily focuses on standard URI schemes, it provides some flexibility for handling custom schemes.  The core functionality for parsing and manipulating components remains consistent even with non-standard schemes. However, you'll need to manage the specific behavior and semantics associated with your custom scheme within your application logic.  URI.js won't inherently understand the meaning or processing requirements of a non-standard scheme; it simply handles the URI structure itself.\n\n\n## Error Handling and Best Practices\n\n### Common Errors and Troubleshooting\n\nMost errors with URI.js stem from incorrect input or unexpected URI formats. Here's a breakdown of common issues:\n\n* **Invalid URI strings:** Passing an invalid URI string to the constructor or `URI.parse` won't throw exceptions, but may result in an object with incomplete or undefined components.  Always validate user-provided URIs before processing.\n\n* **Encoding issues:**  Incorrectly encoded or decoded components can lead to unexpected behavior. Ensure that you use `URI.encodeComponent` and `URI.decodeComponent` where needed, especially when dealing with user input.\n\n* **Path manipulation:**  Incorrect use of path manipulation methods (`addPath`, `removePath`, etc.) can lead to unexpected path structures. Be mindful of relative vs. absolute paths.\n\n* **Query parameter handling:**  Errors occur if you try to access non-existent query parameters. Always check for the existence of parameters before accessing them.\n\nDebugging:  Use `console.log` to inspect the URI object's components at various stages to identify errors.  Also, carefully review the return values from methods to ensure they are as expected.  Consider using a linter to help with static code analysis.\n\n\n### Security Considerations\n\n* **Input sanitization:** Always sanitize user-provided URI strings before using them. This prevents potential injection attacks or unexpected behavior from malformed URIs.  Never directly trust user input when constructing URIs.\n\n* **Output encoding:** Ensure proper encoding of URI components, especially when generating URLs or links to be displayed to users.  This prevents XSS vulnerabilities.\n\n* **Avoid direct manipulation of the URI object's internal properties:**  Use the provided methods for modification. Direct manipulation can bypass important checks and validation, leading to inconsistencies and security risks.\n\n* **Use of the `toString()` method:**  Use the `toString()` method for serialization; don’t attempt to manually reconstruct the URI string from components. This ensures proper encoding and formatting.\n\n\n### Performance Optimization\n\nURI.js is already quite efficient.  However, for optimal performance in large-scale applications:\n\n* **Avoid unnecessary object creation:**  If you're performing many operations on the same URI, reuse the existing URI object instead of constantly creating new ones.\n\n* **Use appropriate methods:** Choose the most efficient method for the task.  Using `addQuery` is better than recreating the entire query string for a minor change.\n\n* **Cache parsed URIs:** In scenarios with a fixed set of URIs, consider pre-parsing and caching them to avoid repeated parsing overhead.\n\n* **Batch operations:** When you need to perform multiple operations on a URI, combine them into a single operation whenever possible. This reduces the number of object manipulations.\n\n\n### Working with Different Browsers and Environments\n\nURI.js is designed to work consistently across different browsers and environments. It handles inconsistencies in browser implementations and provides a uniform API.  However:\n\n* **Compatibility testing:** It's always recommended to test your application with different browsers and versions to ensure compatibility.\n\n* **Polyfills:** While URI.js itself doesn't require any polyfills for modern browsers, if you are targeting very old browsers you may need to ensure your environment includes appropriate polyfills for the JavaScript features it uses.\n\n* **Node.js compatibility:** URI.js works seamlessly in Node.js environments through `npm` or `yarn` installation.  No browser-specific adjustments are needed.\n\n\n\n\n## API Reference\n\nThis section provides a comprehensive reference for the URI.js API.  Note that the exact methods and properties might vary slightly depending on the version of URI.js you are using.  Always refer to the latest documentation on the project's website for the most up-to-date information.\n\n\n### URI Object\n\nThe core of URI.js is the `URI` object.  It's created using the `new URI(uriString)` constructor or `URI.create(uriString or uriObject)` method.  This object represents a parsed URI and provides methods for accessing and manipulating its components.  The `URI` object does *not* inherit from any specific JavaScript prototype.\n\n### Methods and Properties\n\nThe `URI` object exposes numerous methods for accessing and modifying URI components.  Key methods include (but are not limited to):\n\n* **`scheme()`**: Getter and setter for the URI scheme (e.g., `http`, `https`, `ftp`).\n\n* **`username()`**, **`password()`**: Getters and setters for the username and password components of the URI's authority (often used with `ftp` and other protocols).\n\n* **`host()`**: Getter and setter for the host component (hostname or IP address).\n\n* **`hostname()`**: Getter for the hostname, separated from the port.\n\n* **`port()`**: Getter and setter for the port number.\n\n* **`path()`**: Getter and setter for the path component.  Several methods help manipulate paths, such as `addPath()`, `removePath()`.\n\n* **`query()`**: Getter and setter for the query component.  It accepts a boolean argument: `true` returns a parsed object of query parameters, `false` (default) returns a string. Methods like `addQuery()`, `removeQuery()` facilitate fine-grained control of parameters.\n\n* **`fragment()`**: Getter and setter for the fragment component.\n\n* **`authority()`**: Getter for the `username:password@host:port` component.\n\n* **`origin()`**: Getter for the origin (`scheme://host:port`).\n\n* **`toString()`**: Converts the URI object back into its string representation.\n\n* **`isAbsolute()`**:  Checks if the URI is an absolute URI.\n\n* **`normalize()`**: Normalizes the URI (e.g., simplifying the path).\n\n* **`resolve(relativeUri)`**:  Resolves a relative URI against the current URI.\n\n\n* **`equals(otherUri)`**: Checks if two URI objects are equal.\n\nFor a complete list and detailed descriptions, always consult the official API documentation.  The exact syntax and capabilities may evolve with URI.js updates.\n\n\n### Static Methods\n\nURI.js provides several static methods, primarily `URI.parse()` and `URI.create()`.\n\n* **`URI.parse(uriString)`**: Parses a URI string and returns an object representing its components.  It is more lenient about malformed input than the constructor.\n\n* **`URI.encodeComponent(component)`**:  Percent-encodes a URI component string.\n\n* **`URI.decodeComponent(component)`**:  Percent-decodes a URI component string.\n\n\n### Events (if applicable)\n\nURI.js itself does not have an event system.  It's a utility library focused on URI manipulation; any events would be handled within the application using the modified URI objects.  There are no built-in events triggered by the library's methods.\n\n\n## Contributing to URI.js\n\nThis section outlines how to contribute to the URI.js project.  Contributions are welcome and appreciated!  Before contributing, please take some time to familiarize yourself with the project's guidelines and coding style.\n\n### Code Style Guide\n\nURI.js follows a consistent coding style to ensure readability and maintainability.  The primary style guide is generally consistent with standard JavaScript conventions, emphasizing clarity and simplicity.\n\n* **Indentation:** Use 2 spaces for indentation.\n\n* **Line length:** Keep lines under 80 characters.\n\n* **Semicolons:** Use semicolons consistently to terminate statements.\n\n* **Variable naming:** Use descriptive and consistent variable names (camelCase).\n\n* **Comments:** Write clear and concise comments explaining complex logic or non-obvious code sections.\n\nSpecific style preferences might be documented within the project's source code or in a separate style guide file.  It's recommended to review the existing codebase to understand the preferred style before making any changes.\n\n\n### Testing and Debugging\n\nURI.js utilizes a comprehensive test suite.  All contributions should include corresponding tests to ensure correctness and prevent regressions.  The tests are typically written using a unit testing framework (check the project's documentation for specifics on the testing framework used).  To run the tests:\n\n1. **Clone the repository:** Obtain a local copy of the URI.js repository.\n\n2. **Install dependencies:**  Install the project's dependencies (e.g., using npm or yarn).\n\n3. **Run the tests:** Execute the test runner command (instructions will be in the project's README or contributing guide).\n\nDebugging can be done using standard JavaScript debugging tools in your IDE or browser's developer console.  Use `console.log` strategically to inspect variable values and the flow of execution during testing and development.\n\n\n### Submitting Pull Requests\n\n1. **Fork the repository:** Create a fork of the main URI.js repository on GitHub.\n\n2. **Create a branch:** Create a new branch for your changes. Use descriptive branch names (e.g., `fix/bug-123` or `feature/new-method`).\n\n3. **Make your changes:** Implement your changes and write comprehensive tests. Ensure your code adheres to the project's code style guide.\n\n4. **Commit your changes:** Commit your changes with clear and concise messages describing your modifications.\n\n5. **Push your branch:** Push your branch to your forked repository.\n\n6. **Create a pull request:**  Submit a pull request to the main URI.js repository.  Provide a detailed description of your changes and their purpose in the pull request description.\n\n\n### Community Support\n\nFor questions, discussions, or help with using URI.js, please use the project's designated channels for community support (e.g., GitHub Issues, a forum, a dedicated chat channel).  Be sure to check the project's documentation and existing issues before posting to avoid duplicates.  Respectful and constructive communication is essential when interacting with the project's maintainers and other community members.  Provide clear and concise descriptions of your questions or problems, including relevant code snippets and error messages.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"}],"output-file":"urijs.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"title":"URI.js - A Developer's Handbook","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}