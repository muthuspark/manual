{"title":"PrettyPrint - A Developer's Handbook","markdown":{"yaml":{"title":"PrettyPrint - A Developer's Handbook","categories":["JavaScript Libraries and Functions"]},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n### What is PrettyPrint?\n\nPrettyPrint is a library designed to enhance the readability of various data structures and code by formatting them into a visually appealing and easily understandable representation.  It supports a wide range of input types, including dictionaries, lists, trees, and even custom data structures, transforming them into neatly formatted strings that are suitable for logging, debugging, or simply displaying information to the user.  The library prioritizes clarity and consistency in its output, making complex data easier to digest.\n\n### Why use PrettyPrint?\n\nUsing PrettyPrint offers several key advantages:\n\n* **Improved Readability:**  Transforms complex nested data into a structured and visually appealing format, greatly enhancing readability for both developers and end-users.\n* **Easier Debugging:**  Facilitates the identification of errors and inconsistencies within data structures by presenting them in a clear and organized manner.\n* **Enhanced Logging:** Produces formatted log messages, simplifying the task of analyzing and understanding events within applications.\n* **Flexibility and Customization:** Allows for customization of the output format to meet specific requirements.\n* **Cross-Platform Compatibility:** Designed to work consistently across different operating systems and environments.\n\n\n### Installation and Setup\n\nPrettyPrint can be easily installed using pip:\n\n```bash\npip install prettyprint\n```\n\nNo further setup is typically required.  Simply import the library into your Python scripts to begin using its functionalities.\n\n\n### Basic Usage Example\n\nThis example demonstrates how to use PrettyPrint to format a simple Python dictionary:\n\n```python\nfrom prettyprint import pp\n\ndata = {\n    \"name\": \"Example Data\",\n    \"values\": [1, 2, 3, 4, 5],\n    \"nested\": {\n        \"key1\": \"value1\",\n        \"key2\": [True, False]\n    }\n}\n\npp(data)\n```\n\nThis will output a formatted representation of the `data` dictionary to the console, similar to this (the exact formatting might vary slightly depending on your terminal):\n\n```\n{\n    'name': 'Example Data',\n    'values': [\n        1,\n        2,\n        3,\n        4,\n        5\n    ],\n    'nested': {\n        'key1': 'value1',\n        'key2': [\n            True,\n            False\n        ]\n    }\n}\n```\nThe output clearly shows the structure of the dictionary and its nested elements, improving readability compared to a standard Python `print()` output.\n\n\n## Core Concepts\n\n### Data Structures\n\nPrettyPrint natively supports a wide range of Python data structures, including but not limited to:\n\n* **Dictionaries:**  Nested dictionaries are handled gracefully, with clear indentation to show the hierarchical relationships.  Keys and values are displayed clearly.\n* **Lists:** List elements are displayed in a vertical, easy-to-read format, with each item on a new line.  Nested lists are also supported.\n* **Tuples:** Similar to lists, tuples are presented in a clear, vertically aligned format.\n* **Sets:** Set elements are displayed in a compact, unordered format, using curly braces `{}`.\n* **Strings:** Strings are displayed as they are, without any special formatting unless they contain embedded newlines.\n* **Numbers (int, float, complex):** Numbers are displayed using standard Python number representations.\n* **Booleans:** `True` and `False` are displayed as is.\n* **NoneType:** `None` is displayed as `None`.\n* **Custom Objects:** PrettyPrint can handle custom objects if they implement the `__repr__` method.  This method should return a string representation of the object suitable for display.  The `__str__` method can be also used, if defined.\n\n\n### Formatting Options\n\nWhile PrettyPrint automatically applies sensible formatting,  you can influence the output using various parameters (though most cases require no explicit parameters).  Future versions might offer more explicit configuration options.  Currently, the primary control over formatting comes from the way the input data is structured and the behavior of the `__repr__` and `__str__` methods of any custom classes.  For example, using lists instead of dictionaries will dramatically alter the final format.\n\n\n### Customizing Output\n\nThe most significant way to customize the output is by controlling the `__repr__` or `__str__` methods within your custom classes. By carefully crafting the string returned by these methods, you can dictate exactly how your objects are represented in the PrettyPrint output.\n\n\nFor example:\n\n```python\nclass MyCustomObject:\n    def __init__(self, name, value):\n        self.name = name\n        self.value = value\n\n    def __repr__(self):\n        return f\"<MyCustomObject(name='{self.name}', value={self.value})>\"\n\nmy_object = MyCustomObject(\"Example\", 123)\npp(my_object)\n```\n\nThis will produce an output that reflects the custom `__repr__` method:  `<MyCustomObject(name='Example', value=123)>`.  By designing informative `__repr__` or `__str__` methods, you ensure that your custom objects are displayed in a clear and contextually relevant manner.  If you don't define these methods, the default representation will be used, showing the class name and memory address.\n\n\n## Advanced Usage\n\n### Conditional Formatting\n\nPrettyPrint doesn't directly support conditional formatting based on data values within the library itself.  Conditional formatting would typically be achieved by preprocessing the data *before* passing it to `pp()`.  You can create functions to modify the data structure based on conditions, adding formatting information (e.g., extra strings or specific characters) to indicate different states. This modified data would then be passed to PrettyPrint for its standard formatting.\n\n\nFor example, to highlight values above a certain threshold:\n\n\n```python\nfrom prettyprint import pp\n\ndata = {'a': 10, 'b': 20, 'c': 5}\n\ndef highlight_above_threshold(data, threshold=15):\n    for key, value in data.items():\n        if value > threshold:\n            data[key] = f\"**{value}**\"  # Add visual cues\n    return data\n\nformatted_data = highlight_above_threshold(data)\npp(formatted_data)\n```\n\nThis would output 'b' with visual cues showing it exceeds the threshold.  This approach separates data manipulation from the formatting provided by PrettyPrint.\n\n\n### Handling Complex Data\n\nPrettyPrint handles deeply nested data structures recursively. However, extremely large or complex data structures might lead to very long output. For such scenarios, consider these strategies:\n\n* **Data Sampling:**  Instead of printing the entire dataset, sample a representative subset for analysis and display.\n* **Data Summarization:**  Before printing, summarize the data to highlight key statistics or summaries rather than raw values.\n* **Custom `__repr__` methods:** For your own custom classes with complex internal structures, tailor the `__repr__` method to return a concise summary rather than a complete, verbose representation.\n* **Chunking:** Divide the large dataset into smaller logical chunks.  Print each chunk separately or print summaries of each chunk.\n* **Pagination (Future Enhancement):** Future versions of PrettyPrint might incorporate pagination features to manage very extensive outputs.\n\n### Integrating with other libraries\n\nPrettyPrint is designed to be compatible with other Python libraries.  It works well alongside logging libraries (like `logging`) where its formatted output can enhance the clarity of log messages.   You can seamlessly integrate PrettyPrint into your existing workflows by simply calling `pp()` on data structures generated or processed by other libraries.\n\nExample with logging:\n\n```python\nimport logging\nfrom prettyprint import pp\n\nlogging.basicConfig(level=logging.INFO)\ndata = {'message': 'This is a log message', 'details': {'code': 200, 'timestamp': '2024-10-27'}}\nlogging.info(f\"Event details: {pp(data)}\")\n```\n\n### Performance Optimization\n\nFor large datasets, the performance of PrettyPrint might become noticeable. The `pp()` function generally has a reasonable performance, however for datasets exceeding millions of elements optimization is important.  Consider these techniques for improved performance:\n\n* **Avoid unnecessary calls:** Call `pp()` only when truly needed,  since string formatting and string building have a computational cost.  Batch operations or using buffers can reduce overhead.\n* **Data preprocessing:**  Preprocess large datasets to reduce size or complexity before passing to `pp()`.  For example, filtering or aggregating data.\n* **Use efficient data structures:** Python's built-in data structures are often optimized for efficiency. Use them when possible instead of custom implementations that might be less efficient.\n* **Profiling:** Use Python's profiling tools (`cProfile`, `line_profiler`) to identify performance bottlenecks within your code.  This can pinpoint areas where optimizing calls to `pp()` or preprocessing your data would yield the greatest performance gains.\n\n\n\n\n## API Reference\n\n### PrettyPrint Function\n\nThe core functionality of PrettyPrint is encapsulated within the `pp()` function.\n\n**Signature:**\n\n```python\npp(object, stream=None, indent=4, width=80, depth=None)\n```\n\n**Parameters:**\n\n* `object`: The Python object (dictionary, list, etc.) to be formatted.  This is the only required parameter.\n* `stream`: (Optional) The output stream (e.g., a file object). If `None` (default), the output is printed to standard output (console).\n* `indent`: (Optional) The number of spaces used for indentation. Defaults to 4.\n* `width`: (Optional) The maximum width of the output in characters.  Lines longer than this will be wrapped. Defaults to 80.\n* `depth`: (Optional) The maximum recursion depth.  Defaults to `None` (no limit).  Setting a limit is crucial for preventing infinite recursion with cyclical data structures.\n\n\n**Return Value:**\n\nThe `pp()` function doesn't directly return a value; it prints the formatted output to the specified stream.  If you need to capture the formatted string instead of printing, redirect the output using the `io.StringIO()` object:\n\n\n```python\nimport io\nfrom prettyprint import pp\n\ndata = {'a': 1, 'b': 2}\noutput_buffer = io.StringIO()\npp(data, stream=output_buffer)\nformatted_string = output_buffer.getvalue()\nprint(formatted_string) #Now formatted_string contains the output\n```\n\n\n### Options Object\n\nCurrently, PrettyPrint does not utilize a dedicated \"Options Object\" for configuration.  The parameters directly passed to the `pp()` function control the formatting behavior.  This might change in future versions to provide more fine-grained control and a more object-oriented approach.\n\n\n### Utility Functions\n\nCurrently, PrettyPrint does not provide any additional utility functions beyond the core `pp()` function.  Future versions might include helper functions to support additional formatting options or advanced features.\n\n\n## Troubleshooting\n\n### Common Errors\n\n* **RecursionError:** This error typically occurs when dealing with deeply nested data structures or cyclical references (where an object refers back to itself, directly or indirectly).  To resolve this, limit the recursion depth using the `depth` parameter in the `pp()` function.  For example: `pp(my_data, depth=100)`.  Choose a depth value appropriate for your expected data structures. Carefully examine your data for cycles if the error persists.\n\n* **TypeError:**  This error might arise if you pass an unsupported data type to the `pp()` function.  PrettyPrint primarily supports standard Python data structures (dictionaries, lists, tuples, etc.).  Ensure that your data conforms to these supported types.  For custom objects, implement `__repr__` or `__str__` methods for correct representation.\n\n* **UnicodeEncodeError:** This can happen if the data contains characters that cannot be encoded using your system's default encoding.  Specify the encoding explicitly when writing to a file or ensure your terminal supports the necessary characters.\n\n\n### Debugging Tips\n\n* **Simplify your input:** If you are encountering errors with complex data, try simplifying the input to a minimal example that still reproduces the problem.  This helps isolate the source of the error.\n\n* **Check your data structure:** Verify that your data structure is correctly formed and does not contain any unexpected or invalid values.  Incorrectly structured data can lead to unexpected formatting or errors.\n\n* **Use print statements:** Strategically placed `print()` statements before and after calls to `pp()` can help you track the data's state and identify the point where the error occurs.\n\n* **Inspect the `__repr__` method:** If you are working with custom objects, examine the implementation of the `__repr__` (or `__str__`) method. Errors in this method can directly lead to incorrect or error-causing outputs.\n\n\n### Frequently Asked Questions\n\n* **Can PrettyPrint handle custom classes?**  Yes, but you may need to implement the `__repr__` or `__str__` method for those custom classes to control how they are formatted.  Otherwise, the default representation (including memory address) will be printed.\n\n* **How can I change the indentation level?** Use the `indent` parameter in the `pp()` function.  For example:  `pp(my_data, indent=2)` will use two spaces for indentation.\n\n* **What is the maximum size of data PrettyPrint can handle?** There's no strict size limit, but extremely large datasets might cause performance issues.  For very large datasets, consider sampling, summarizing, or using the `depth` parameter to limit recursion.\n\n* **How can I save the formatted output to a file?** Use a file object as the `stream` parameter in `pp()`:\n\n\n```python\nwith open(\"output.txt\", \"w\") as f:\n    pp(my_data, stream=f)\n```\n\n* **Why am I getting a `RecursionError`?**  This usually means you have a deeply nested or cyclical data structure. Use the `depth` parameter to limit recursion or examine your data for cycles.\n\n* **My output is not as expected. How can I debug it?** Start by simplifying your input and systematically using `print()` statements to trace the data at various points.   Review your custom `__repr__` and `__str__` method implementations if used.\n\n\n\n## Examples\n\n### Basic Examples\n\n**Example 1: Formatting a dictionary:**\n\n```python\nfrom prettyprint import pp\n\ndata = {'name': 'John Doe', 'age': 30, 'city': 'New York'}\npp(data)\n```\n\nOutput:\n\n```\n{\n    'name': 'John Doe',\n    'age': 30,\n    'city': 'New York'\n}\n```\n\n**Example 2: Formatting a list:**\n\n```python\nfrom prettyprint import pp\n\ndata = [1, 2, 3, 4, 5]\npp(data)\n```\n\nOutput:\n\n```\n[\n    1,\n    2,\n    3,\n    4,\n    5\n]\n```\n\n**Example 3: Formatting a nested structure:**\n\n```python\nfrom prettyprint import pp\n\ndata = {\n    'name': 'Jane Doe',\n    'address': {\n        'street': '123 Main St',\n        'city': 'Anytown',\n        'zip': '12345'\n    }\n}\npp(data)\n```\n\nOutput:\n\n```\n{\n    'name': 'Jane Doe',\n    'address': {\n        'street': '123 Main St',\n        'city': 'Anytown',\n        'zip': '12345'\n    }\n}\n```\n\n\n### Advanced Examples\n\n**Example 1: Handling a large list:**  To prevent excessively long output, limit the depth of displayed elements.\n\n```python\nfrom prettyprint import pp\nimport random\n\nlarge_list = [random.randint(1, 100) for _ in range(1000)]\npp(large_list, depth=10) # Show only the first 10 elements\n```\n\n**Example 2: Custom object formatting:**\n\n```python\nfrom prettyprint import pp\n\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def __repr__(self):\n        return f\"Person(name='{self.name}', age={self.age})\"\n\nperson = Person(\"Alice\", 25)\npp(person)\n```\n\nOutput:\n\n```\nPerson(name='Alice', age=25)\n```\n\n**Example 3:  Conditional formatting (pre-processing):**\n\n```python\nfrom prettyprint import pp\n\ndata = {'a': 10, 'b': 20, 'c': 5}\n\ndef highlight_above_threshold(data, threshold=15):\n    for key, value in data.items():\n        if value > threshold:\n            data[key] = f\"**{value}**\"\n    return data\n\nformatted_data = highlight_above_threshold(data)\npp(formatted_data)\n```\n\nOutput:\n\n```\n{\n    'a': 10,\n    'b': '**20**',\n    'c': 5\n}\n```\n\n\n### Real-world Use Cases\n\n* **Logging:**  Include `pp(data)` within log messages to provide clear and formatted context information for debugging purposes.\n\n* **Debugging:**  Print complex data structures during debugging sessions to inspect their contents clearly.\n\n* **Command-line interfaces:** Display formatted data neatly in command-line applications.\n\n* **Web application development:**  When debugging or presenting data in a less technical context, `pp()` can be used within handlers to present relevant information.\n\n* **Data analysis:**  Use `pp()` to explore and visualize data structures during initial analysis, facilitating pattern discovery.  (Note: For large datasets, this may need to be coupled with data sampling/summarization techniques.)\n\n* **Reporting:** Generate well-formatted reports containing complex data that is easily understandable by both technical and non-technical users.\n\n\n\n","srcMarkdownNoYaml":"\n## Introduction\n\n### What is PrettyPrint?\n\nPrettyPrint is a library designed to enhance the readability of various data structures and code by formatting them into a visually appealing and easily understandable representation.  It supports a wide range of input types, including dictionaries, lists, trees, and even custom data structures, transforming them into neatly formatted strings that are suitable for logging, debugging, or simply displaying information to the user.  The library prioritizes clarity and consistency in its output, making complex data easier to digest.\n\n### Why use PrettyPrint?\n\nUsing PrettyPrint offers several key advantages:\n\n* **Improved Readability:**  Transforms complex nested data into a structured and visually appealing format, greatly enhancing readability for both developers and end-users.\n* **Easier Debugging:**  Facilitates the identification of errors and inconsistencies within data structures by presenting them in a clear and organized manner.\n* **Enhanced Logging:** Produces formatted log messages, simplifying the task of analyzing and understanding events within applications.\n* **Flexibility and Customization:** Allows for customization of the output format to meet specific requirements.\n* **Cross-Platform Compatibility:** Designed to work consistently across different operating systems and environments.\n\n\n### Installation and Setup\n\nPrettyPrint can be easily installed using pip:\n\n```bash\npip install prettyprint\n```\n\nNo further setup is typically required.  Simply import the library into your Python scripts to begin using its functionalities.\n\n\n### Basic Usage Example\n\nThis example demonstrates how to use PrettyPrint to format a simple Python dictionary:\n\n```python\nfrom prettyprint import pp\n\ndata = {\n    \"name\": \"Example Data\",\n    \"values\": [1, 2, 3, 4, 5],\n    \"nested\": {\n        \"key1\": \"value1\",\n        \"key2\": [True, False]\n    }\n}\n\npp(data)\n```\n\nThis will output a formatted representation of the `data` dictionary to the console, similar to this (the exact formatting might vary slightly depending on your terminal):\n\n```\n{\n    'name': 'Example Data',\n    'values': [\n        1,\n        2,\n        3,\n        4,\n        5\n    ],\n    'nested': {\n        'key1': 'value1',\n        'key2': [\n            True,\n            False\n        ]\n    }\n}\n```\nThe output clearly shows the structure of the dictionary and its nested elements, improving readability compared to a standard Python `print()` output.\n\n\n## Core Concepts\n\n### Data Structures\n\nPrettyPrint natively supports a wide range of Python data structures, including but not limited to:\n\n* **Dictionaries:**  Nested dictionaries are handled gracefully, with clear indentation to show the hierarchical relationships.  Keys and values are displayed clearly.\n* **Lists:** List elements are displayed in a vertical, easy-to-read format, with each item on a new line.  Nested lists are also supported.\n* **Tuples:** Similar to lists, tuples are presented in a clear, vertically aligned format.\n* **Sets:** Set elements are displayed in a compact, unordered format, using curly braces `{}`.\n* **Strings:** Strings are displayed as they are, without any special formatting unless they contain embedded newlines.\n* **Numbers (int, float, complex):** Numbers are displayed using standard Python number representations.\n* **Booleans:** `True` and `False` are displayed as is.\n* **NoneType:** `None` is displayed as `None`.\n* **Custom Objects:** PrettyPrint can handle custom objects if they implement the `__repr__` method.  This method should return a string representation of the object suitable for display.  The `__str__` method can be also used, if defined.\n\n\n### Formatting Options\n\nWhile PrettyPrint automatically applies sensible formatting,  you can influence the output using various parameters (though most cases require no explicit parameters).  Future versions might offer more explicit configuration options.  Currently, the primary control over formatting comes from the way the input data is structured and the behavior of the `__repr__` and `__str__` methods of any custom classes.  For example, using lists instead of dictionaries will dramatically alter the final format.\n\n\n### Customizing Output\n\nThe most significant way to customize the output is by controlling the `__repr__` or `__str__` methods within your custom classes. By carefully crafting the string returned by these methods, you can dictate exactly how your objects are represented in the PrettyPrint output.\n\n\nFor example:\n\n```python\nclass MyCustomObject:\n    def __init__(self, name, value):\n        self.name = name\n        self.value = value\n\n    def __repr__(self):\n        return f\"<MyCustomObject(name='{self.name}', value={self.value})>\"\n\nmy_object = MyCustomObject(\"Example\", 123)\npp(my_object)\n```\n\nThis will produce an output that reflects the custom `__repr__` method:  `<MyCustomObject(name='Example', value=123)>`.  By designing informative `__repr__` or `__str__` methods, you ensure that your custom objects are displayed in a clear and contextually relevant manner.  If you don't define these methods, the default representation will be used, showing the class name and memory address.\n\n\n## Advanced Usage\n\n### Conditional Formatting\n\nPrettyPrint doesn't directly support conditional formatting based on data values within the library itself.  Conditional formatting would typically be achieved by preprocessing the data *before* passing it to `pp()`.  You can create functions to modify the data structure based on conditions, adding formatting information (e.g., extra strings or specific characters) to indicate different states. This modified data would then be passed to PrettyPrint for its standard formatting.\n\n\nFor example, to highlight values above a certain threshold:\n\n\n```python\nfrom prettyprint import pp\n\ndata = {'a': 10, 'b': 20, 'c': 5}\n\ndef highlight_above_threshold(data, threshold=15):\n    for key, value in data.items():\n        if value > threshold:\n            data[key] = f\"**{value}**\"  # Add visual cues\n    return data\n\nformatted_data = highlight_above_threshold(data)\npp(formatted_data)\n```\n\nThis would output 'b' with visual cues showing it exceeds the threshold.  This approach separates data manipulation from the formatting provided by PrettyPrint.\n\n\n### Handling Complex Data\n\nPrettyPrint handles deeply nested data structures recursively. However, extremely large or complex data structures might lead to very long output. For such scenarios, consider these strategies:\n\n* **Data Sampling:**  Instead of printing the entire dataset, sample a representative subset for analysis and display.\n* **Data Summarization:**  Before printing, summarize the data to highlight key statistics or summaries rather than raw values.\n* **Custom `__repr__` methods:** For your own custom classes with complex internal structures, tailor the `__repr__` method to return a concise summary rather than a complete, verbose representation.\n* **Chunking:** Divide the large dataset into smaller logical chunks.  Print each chunk separately or print summaries of each chunk.\n* **Pagination (Future Enhancement):** Future versions of PrettyPrint might incorporate pagination features to manage very extensive outputs.\n\n### Integrating with other libraries\n\nPrettyPrint is designed to be compatible with other Python libraries.  It works well alongside logging libraries (like `logging`) where its formatted output can enhance the clarity of log messages.   You can seamlessly integrate PrettyPrint into your existing workflows by simply calling `pp()` on data structures generated or processed by other libraries.\n\nExample with logging:\n\n```python\nimport logging\nfrom prettyprint import pp\n\nlogging.basicConfig(level=logging.INFO)\ndata = {'message': 'This is a log message', 'details': {'code': 200, 'timestamp': '2024-10-27'}}\nlogging.info(f\"Event details: {pp(data)}\")\n```\n\n### Performance Optimization\n\nFor large datasets, the performance of PrettyPrint might become noticeable. The `pp()` function generally has a reasonable performance, however for datasets exceeding millions of elements optimization is important.  Consider these techniques for improved performance:\n\n* **Avoid unnecessary calls:** Call `pp()` only when truly needed,  since string formatting and string building have a computational cost.  Batch operations or using buffers can reduce overhead.\n* **Data preprocessing:**  Preprocess large datasets to reduce size or complexity before passing to `pp()`.  For example, filtering or aggregating data.\n* **Use efficient data structures:** Python's built-in data structures are often optimized for efficiency. Use them when possible instead of custom implementations that might be less efficient.\n* **Profiling:** Use Python's profiling tools (`cProfile`, `line_profiler`) to identify performance bottlenecks within your code.  This can pinpoint areas where optimizing calls to `pp()` or preprocessing your data would yield the greatest performance gains.\n\n\n\n\n## API Reference\n\n### PrettyPrint Function\n\nThe core functionality of PrettyPrint is encapsulated within the `pp()` function.\n\n**Signature:**\n\n```python\npp(object, stream=None, indent=4, width=80, depth=None)\n```\n\n**Parameters:**\n\n* `object`: The Python object (dictionary, list, etc.) to be formatted.  This is the only required parameter.\n* `stream`: (Optional) The output stream (e.g., a file object). If `None` (default), the output is printed to standard output (console).\n* `indent`: (Optional) The number of spaces used for indentation. Defaults to 4.\n* `width`: (Optional) The maximum width of the output in characters.  Lines longer than this will be wrapped. Defaults to 80.\n* `depth`: (Optional) The maximum recursion depth.  Defaults to `None` (no limit).  Setting a limit is crucial for preventing infinite recursion with cyclical data structures.\n\n\n**Return Value:**\n\nThe `pp()` function doesn't directly return a value; it prints the formatted output to the specified stream.  If you need to capture the formatted string instead of printing, redirect the output using the `io.StringIO()` object:\n\n\n```python\nimport io\nfrom prettyprint import pp\n\ndata = {'a': 1, 'b': 2}\noutput_buffer = io.StringIO()\npp(data, stream=output_buffer)\nformatted_string = output_buffer.getvalue()\nprint(formatted_string) #Now formatted_string contains the output\n```\n\n\n### Options Object\n\nCurrently, PrettyPrint does not utilize a dedicated \"Options Object\" for configuration.  The parameters directly passed to the `pp()` function control the formatting behavior.  This might change in future versions to provide more fine-grained control and a more object-oriented approach.\n\n\n### Utility Functions\n\nCurrently, PrettyPrint does not provide any additional utility functions beyond the core `pp()` function.  Future versions might include helper functions to support additional formatting options or advanced features.\n\n\n## Troubleshooting\n\n### Common Errors\n\n* **RecursionError:** This error typically occurs when dealing with deeply nested data structures or cyclical references (where an object refers back to itself, directly or indirectly).  To resolve this, limit the recursion depth using the `depth` parameter in the `pp()` function.  For example: `pp(my_data, depth=100)`.  Choose a depth value appropriate for your expected data structures. Carefully examine your data for cycles if the error persists.\n\n* **TypeError:**  This error might arise if you pass an unsupported data type to the `pp()` function.  PrettyPrint primarily supports standard Python data structures (dictionaries, lists, tuples, etc.).  Ensure that your data conforms to these supported types.  For custom objects, implement `__repr__` or `__str__` methods for correct representation.\n\n* **UnicodeEncodeError:** This can happen if the data contains characters that cannot be encoded using your system's default encoding.  Specify the encoding explicitly when writing to a file or ensure your terminal supports the necessary characters.\n\n\n### Debugging Tips\n\n* **Simplify your input:** If you are encountering errors with complex data, try simplifying the input to a minimal example that still reproduces the problem.  This helps isolate the source of the error.\n\n* **Check your data structure:** Verify that your data structure is correctly formed and does not contain any unexpected or invalid values.  Incorrectly structured data can lead to unexpected formatting or errors.\n\n* **Use print statements:** Strategically placed `print()` statements before and after calls to `pp()` can help you track the data's state and identify the point where the error occurs.\n\n* **Inspect the `__repr__` method:** If you are working with custom objects, examine the implementation of the `__repr__` (or `__str__`) method. Errors in this method can directly lead to incorrect or error-causing outputs.\n\n\n### Frequently Asked Questions\n\n* **Can PrettyPrint handle custom classes?**  Yes, but you may need to implement the `__repr__` or `__str__` method for those custom classes to control how they are formatted.  Otherwise, the default representation (including memory address) will be printed.\n\n* **How can I change the indentation level?** Use the `indent` parameter in the `pp()` function.  For example:  `pp(my_data, indent=2)` will use two spaces for indentation.\n\n* **What is the maximum size of data PrettyPrint can handle?** There's no strict size limit, but extremely large datasets might cause performance issues.  For very large datasets, consider sampling, summarizing, or using the `depth` parameter to limit recursion.\n\n* **How can I save the formatted output to a file?** Use a file object as the `stream` parameter in `pp()`:\n\n\n```python\nwith open(\"output.txt\", \"w\") as f:\n    pp(my_data, stream=f)\n```\n\n* **Why am I getting a `RecursionError`?**  This usually means you have a deeply nested or cyclical data structure. Use the `depth` parameter to limit recursion or examine your data for cycles.\n\n* **My output is not as expected. How can I debug it?** Start by simplifying your input and systematically using `print()` statements to trace the data at various points.   Review your custom `__repr__` and `__str__` method implementations if used.\n\n\n\n## Examples\n\n### Basic Examples\n\n**Example 1: Formatting a dictionary:**\n\n```python\nfrom prettyprint import pp\n\ndata = {'name': 'John Doe', 'age': 30, 'city': 'New York'}\npp(data)\n```\n\nOutput:\n\n```\n{\n    'name': 'John Doe',\n    'age': 30,\n    'city': 'New York'\n}\n```\n\n**Example 2: Formatting a list:**\n\n```python\nfrom prettyprint import pp\n\ndata = [1, 2, 3, 4, 5]\npp(data)\n```\n\nOutput:\n\n```\n[\n    1,\n    2,\n    3,\n    4,\n    5\n]\n```\n\n**Example 3: Formatting a nested structure:**\n\n```python\nfrom prettyprint import pp\n\ndata = {\n    'name': 'Jane Doe',\n    'address': {\n        'street': '123 Main St',\n        'city': 'Anytown',\n        'zip': '12345'\n    }\n}\npp(data)\n```\n\nOutput:\n\n```\n{\n    'name': 'Jane Doe',\n    'address': {\n        'street': '123 Main St',\n        'city': 'Anytown',\n        'zip': '12345'\n    }\n}\n```\n\n\n### Advanced Examples\n\n**Example 1: Handling a large list:**  To prevent excessively long output, limit the depth of displayed elements.\n\n```python\nfrom prettyprint import pp\nimport random\n\nlarge_list = [random.randint(1, 100) for _ in range(1000)]\npp(large_list, depth=10) # Show only the first 10 elements\n```\n\n**Example 2: Custom object formatting:**\n\n```python\nfrom prettyprint import pp\n\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def __repr__(self):\n        return f\"Person(name='{self.name}', age={self.age})\"\n\nperson = Person(\"Alice\", 25)\npp(person)\n```\n\nOutput:\n\n```\nPerson(name='Alice', age=25)\n```\n\n**Example 3:  Conditional formatting (pre-processing):**\n\n```python\nfrom prettyprint import pp\n\ndata = {'a': 10, 'b': 20, 'c': 5}\n\ndef highlight_above_threshold(data, threshold=15):\n    for key, value in data.items():\n        if value > threshold:\n            data[key] = f\"**{value}**\"\n    return data\n\nformatted_data = highlight_above_threshold(data)\npp(formatted_data)\n```\n\nOutput:\n\n```\n{\n    'a': 10,\n    'b': '**20**',\n    'c': 5\n}\n```\n\n\n### Real-world Use Cases\n\n* **Logging:**  Include `pp(data)` within log messages to provide clear and formatted context information for debugging purposes.\n\n* **Debugging:**  Print complex data structures during debugging sessions to inspect their contents clearly.\n\n* **Command-line interfaces:** Display formatted data neatly in command-line applications.\n\n* **Web application development:**  When debugging or presenting data in a less technical context, `pp()` can be used within handlers to present relevant information.\n\n* **Data analysis:**  Use `pp()` to explore and visualize data structures during initial analysis, facilitating pattern discovery.  (Note: For large datasets, this may need to be coupled with data sampling/summarization techniques.)\n\n* **Reporting:** Generate well-formatted reports containing complex data that is easily understandable by both technical and non-technical users.\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"}],"output-file":"prettyprint.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"title":"PrettyPrint - A Developer's Handbook","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}