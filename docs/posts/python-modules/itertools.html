<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Muthukrishnan">

<title>itertools - Documentation – Technical Manuals</title>
<style>
html {
  color: #1a1a1a;
  background-color: #fdfdfd;
}
body {
  margin: 0 auto;
  max-width: 36em;
  padding-left: 50px;
  padding-right: 50px;
  padding-top: 50px;
  padding-bottom: 50px;
  hyphens: auto;
  overflow-wrap: break-word;
  text-rendering: optimizeLegibility;
  font-kerning: normal;
}
@media (max-width: 600px) {
  body {
    font-size: 0.9em;
    padding: 12px;
  }
  h1 {
    font-size: 1.8em;
  }
}
@media print {
  html {
    background-color: white;
  }
  body {
    background-color: transparent;
    color: black;
    font-size: 12pt;
  }
  p, h2, h3 {
    orphans: 3;
    widows: 3;
  }
  h2, h3, h4 {
    page-break-after: avoid;
  }
}
p {
  margin: 1em 0;
}
a {
  color: #1a1a1a;
}
a:visited {
  color: #1a1a1a;
}
img {
  max-width: 100%;
}
svg {
  height; auto;
  max-width: 100%;
}
h1, h2, h3, h4, h5, h6 {
  margin-top: 1.4em;
}
h5, h6 {
  font-size: 1em;
  font-style: italic;
}
h6 {
  font-weight: normal;
}
ol, ul {
  padding-left: 1.7em;
  margin-top: 1em;
}
li > ol, li > ul {
  margin-top: 0;
}
ul > li:not(:has(> p)) > ul,
ol > li:not(:has(> p)) > ul,
ul > li:not(:has(> p)) > ol,
ol > li:not(:has(> p)) > ol {
  margin-bottom: 0;
}
ul > li:not(:has(> p)) > ul > li:has(> p),
ol > li:not(:has(> p)) > ul > li:has(> p),
ul > li:not(:has(> p)) > ol > li:has(> p),
ol > li:not(:has(> p)) > ol > li:has(> p) {
  margin-top: 1rem;
}
blockquote {
  margin: 1em 0 1em 1.7em;
  padding-left: 1em;
  border-left: 2px solid #e6e6e6;
  color: #606060;
}
code {
  font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
  font-size: 85%;
  margin: 0;
  hyphens: manual;
}
pre {
  margin: 1em 0;
  overflow: auto;
}
pre code {
  padding: 0;
  overflow: visible;
  overflow-wrap: normal;
}
.sourceCode {
 background-color: transparent;
 overflow: visible;
}
hr {
  background-color: #1a1a1a;
  border: none;
  height: 1px;
  margin: 1em 0;
}
table {
  margin: 1em 0;
  border-collapse: collapse;
  width: 100%;
  overflow-x: auto;
  display: block;
  font-variant-numeric: lining-nums tabular-nums;
}
table caption {
  margin-bottom: 0.75em;
}
tbody {
  margin-top: 0.5em;
  border-top: 1px solid #1a1a1a;
  border-bottom: 1px solid #1a1a1a;
}
th {
  border-top: 1px solid #1a1a1a;
  padding: 0.25em 0.5em 0.25em 0.5em;
}
td {
  padding: 0.125em 0.5em 0.25em 0.5em;
}
header {
  margin-bottom: 4em;
  text-align: center;
}
#TOC li {
  list-style: none;
}
#TOC ul {
  padding-left: 1.3em;
}
#TOC > ul {
  padding-left: 0;
}
#TOC a:not(:hover) {
  text-decoration: none;
}
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<link href="../../favicon.ico" rel="icon">
<script async="" src="https://www.googletagmanager.com/gtag/js?id="></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', '', { 'anonymize_ip': true});
</script>
<link rel="icon" type="image/x-icon" href="../../favicon.ico">
<meta property="og:title" content="itertools - Documentation – Technical Manuals">
<meta property="og:site_name" content="Technical Manuals">
</head><body><div class="navigation-header">
    <nav>
        <div>
            <div class="logo">
                <a href="../../" aria-label="Home">
                    <span>Technical Manuals - Home</span>
                </a>
            </div>
            <div class="nav-menu">
                <ul>
                    <li>
                        <a href="../../about.html">
                            <span class="menu-text">About</span>
                        </a>
                    </li>
                    <li> 
                        <a href="https://github.com/muthuspark" target="_blank">
                            <span class="menu-text">Github</span>
                        </a>
                    </li>
                    <li>
                        <a href="https://linkedin.com/in/krimuthu" target="_blank">
                            <span class="menu-text">Linkedin</span>
                        </a>
                    </li>
                    <li>
                        <button onclick="window.print()" class="print-button">
                            <svg width="20" height="20" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <path d="M6 9V2h12v7"></path>
                              <path d="M6 18H4a2 2 0 01-2-2v-5a2 2 0 012-2h16a2 2 0 012 2v5a2 2 0 01-2 2h-2"></path>
                              <path d="M6 14h12v8H6z"></path>
                            </svg>
                            Print Page
                        </button>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
</div>


<link rel="stylesheet" href="../../styles.css">





<header id="title-block-header">
<h1 class="title">itertools - Documentation</h1>

</header>

<nav id="TOC" role="doc-toc">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#what-is-itertools" id="toc-what-is-itertools">What is itertools?</a></li>
  <li><a href="#why-use-itertools" id="toc-why-use-itertools">Why use itertools?</a></li>
  <li><a href="#iterators-vs.-iterables" id="toc-iterators-vs.-iterables">Iterators vs.&nbsp;Iterables</a></li>
  <li><a href="#key-concepts-iterators-and-generators" id="toc-key-concepts-iterators-and-generators">Key Concepts: Iterators and Generators</a></li>
  <li><a href="#infinite-iterators" id="toc-infinite-iterators">Infinite Iterators</a>
  <ul>
  <li><a href="#count" id="toc-count">count()</a></li>
  <li><a href="#cycle" id="toc-cycle">cycle()</a></li>
  <li><a href="#repeat" id="toc-repeat">repeat()</a></li>
  </ul></li>
  <li><a href="#combinatoric-iterators" id="toc-combinatoric-iterators">Combinatoric Iterators</a>
  <ul>
  <li><a href="#product" id="toc-product">product()</a></li>
  <li><a href="#permutations" id="toc-permutations">permutations()</a></li>
  <li><a href="#combinations" id="toc-combinations">combinations()</a></li>
  <li><a href="#combinations_with_replacement" id="toc-combinations_with_replacement">combinations_with_replacement()</a></li>
  </ul></li>
  <li><a href="#iterators-terminating-on-the-shortest-input-sequence" id="toc-iterators-terminating-on-the-shortest-input-sequence">Iterators terminating on the shortest input sequence</a>
  <ul>
  <li><a href="#chain" id="toc-chain">chain()</a></li>
  <li><a href="#chain.from_iterable" id="toc-chain.from_iterable">chain.from_iterable()</a></li>
  <li><a href="#zip_longest" id="toc-zip_longest">zip_longest()</a></li>
  </ul></li>
  <li><a href="#filtering-iterators" id="toc-filtering-iterators">Filtering Iterators</a>
  <ul>
  <li><a href="#filterfalse" id="toc-filterfalse">filterfalse()</a></li>
  <li><a href="#takewhile" id="toc-takewhile">takewhile()</a></li>
  <li><a href="#dropwhile" id="toc-dropwhile">dropwhile()</a></li>
  </ul></li>
  <li><a href="#grouping-data" id="toc-grouping-data">Grouping Data</a>
  <ul>
  <li><a href="#groupby" id="toc-groupby">groupby()</a></li>
  </ul></li>
  <li><a href="#function-composition" id="toc-function-composition">Function Composition</a>
  <ul>
  <li><a href="#starmap" id="toc-starmap">starmap()</a></li>
  </ul></li>
  <li><a href="#working-with-iterators" id="toc-working-with-iterators">Working with Iterators</a>
  <ul>
  <li><a href="#islice" id="toc-islice">islice()</a></li>
  <li><a href="#tee" id="toc-tee">tee()</a></li>
  <li><a href="#zip" id="toc-zip">zip()</a></li>
  <li><a href="#compress" id="toc-compress">compress()</a></li>
  </ul></li>
  <li><a href="#advanced-usage-and-examples" id="toc-advanced-usage-and-examples">Advanced Usage and Examples</a>
  <ul>
  <li><a href="#combining-multiple-itertools-functions" id="toc-combining-multiple-itertools-functions">Combining Multiple Itertools Functions</a></li>
  <li><a href="#efficient-data-processing-with-itertools" id="toc-efficient-data-processing-with-itertools">Efficient Data Processing with itertools</a></li>
  <li><a href="#real-world-applications" id="toc-real-world-applications">Real-world Applications</a></li>
  </ul></li>
  <li><a href="#performance-considerations" id="toc-performance-considerations">Performance Considerations</a>
  <ul>
  <li><a href="#memory-efficiency" id="toc-memory-efficiency">Memory Efficiency</a></li>
  <li><a href="#speed-optimization" id="toc-speed-optimization">Speed Optimization</a></li>
  </ul></li>
  </ul>
</nav>
<h3 id="what-is-itertools">What is itertools?</h3>
<p>The <code>itertools</code> module in Python is a powerful collection of tools for working with iterators. It provides functions that create efficient iterators for various common data processing tasks. These functions are designed to minimize memory usage and improve performance, especially when dealing with large datasets. Instead of creating and storing entire lists in memory, <code>itertools</code> generates values on demand, one at a time, making it ideal for memory-efficient processing.</p>
<h3 id="why-use-itertools">Why use itertools?</h3>
<p><code>itertools</code> offers several key advantages:</p>
<ul>
<li><strong>Memory Efficiency:</strong> It avoids creating and storing large intermediate lists, making it suitable for processing massive datasets that wouldn’t fit into memory otherwise.</li>
<li><strong>Readability and Conciseness:</strong> <code>itertools</code> provides elegant and concise ways to express complex iteration logic, making your code cleaner and easier to understand.</li>
<li><strong>Performance:</strong> The functions are highly optimized for speed, often outperforming manually implemented iteration techniques.</li>
<li><strong>Functional Programming Paradigm:</strong> <code>itertools</code> supports a functional programming style, promoting code reusability and reducing the need for explicit loops in many cases.</li>
</ul>
<h3 id="iterators-vs.-iterables">Iterators vs.&nbsp;Iterables</h3>
<p>It’s crucial to understand the distinction between iterators and iterables:</p>
<ul>
<li><p><strong>Iterable:</strong> An object that can be iterated over. This includes sequences like lists, tuples, strings, and also objects that implement the iterator protocol (having a <code>__iter__</code> method). An iterable can be used to create an iterator.</p></li>
<li><p><strong>Iterator:</strong> An object that produces the next value in a sequence when its <code>__next__</code> method is called. It keeps track of its current position during iteration. When there are no more values, it raises a <code>StopIteration</code> exception.</p></li>
</ul>
<p>In essence, an iterable is <em>something you can iterate over</em>, while an iterator is <em>the thing doing the iterating</em>. Many <code>itertools</code> functions accept iterables as input and return iterators as output.</p>
<h3 id="key-concepts-iterators-and-generators">Key Concepts: Iterators and Generators</h3>
<p>Understanding iterators and generators is fundamental to using <code>itertools</code> effectively:</p>
<ul>
<li><p><strong>Iterators:</strong> As described above, iterators are objects supporting the iterator protocol (<code>__iter__</code> and <code>__next__</code>). They provide a way to traverse a sequence of values one at a time.</p></li>
<li><p><strong>Generators:</strong> Generators are a specific type of iterator created using a function containing the <code>yield</code> keyword. Each <code>yield</code> statement suspends the function’s execution and returns a value. Upon the next call to <code>__next__</code>, the function resumes from where it left off. Generators are very memory-efficient because they produce values only when needed, rather than creating a complete sequence in memory upfront. Many <code>itertools</code> functions are implemented as generators. This makes them extremely efficient for large datasets. For example, consider a generator function to produce the first <code>n</code> even numbers:</p></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> even_numbers(n):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> <span class="dv">2</span> <span class="op">*</span> i</span></code></pre></div>
<p>This generator produces even numbers only when requested, avoiding the creation of a large list. This same principle of on-demand generation is central to the efficiency of the <code>itertools</code> module.</p>
<h2 id="infinite-iterators">Infinite Iterators</h2>
<p>The <code>itertools</code> module includes several functions that generate infinite iterators. These are iterators that, theoretically, never end. In practice, you’ll always use them in conjunction with other tools (like slicing or <code>islice</code> from <code>itertools</code>) to limit the number of values produced. Attempting to exhaust these iterators directly will result in your program running indefinitely.</p>
<h3 id="count">count()</h3>
<p><code>count([start, [, step]])</code></p>
<p>This function returns an iterator that yields evenly spaced values starting with <em>start</em>. The default <em>start</em> value is 0, and the default <em>step</em> value is 1. This iterator will continue indefinitely unless explicitly stopped.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> count</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Count from 10 upwards with a step of 2</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> count(<span class="dv">10</span>, <span class="dv">2</span>):</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">20</span>:</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(i)  <span class="co"># Output: 10 12 14 16 18 20</span></span></code></pre></div>
<p><strong>Important Note:</strong> <code>count()</code> is infinite. Always use it with a mechanism to break out of the loop (like in the example above), or in combination with other <code>itertools</code> functions that limit the iteration.</p>
<h3 id="cycle">cycle()</h3>
<p><code>cycle(iterable)</code></p>
<p>This function returns an iterator that repeatedly cycles through the elements of the input <em>iterable</em>. It will continue cycling indefinitely.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> cycle</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'red'</span>, <span class="st">'green'</span>, <span class="st">'blue'</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, color <span class="kw">in</span> <span class="bu">enumerate</span>(cycle(colors)):</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">5</span>:</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(color) <span class="co"># Output: red green blue red green blue</span></span></code></pre></div>
<p><strong>Important Note:</strong> <code>cycle()</code> is also infinite. Use it carefully in conjunction with other tools to control the iteration length.</p>
<h3 id="repeat">repeat()</h3>
<p><code>repeat(object[, times])</code></p>
<p>This function returns an iterator that yields the <em>object</em> repeatedly. If <em>times</em> is given, the iterator will yield the object <em>times</em> times. If <em>times</em> is omitted (or None), the iterator will yield the object indefinitely.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> repeat</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Repeat 'hello' 3 times</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> repeat(<span class="st">'hello'</span>, <span class="dv">3</span>):</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(i)  <span class="co"># Output: hello hello hello</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">#Repeat 'world' indefinitely (requires a loop termination condition)</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, val <span class="kw">in</span> <span class="bu">enumerate</span>(repeat(<span class="st">'world'</span>)):</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i<span class="op">&gt;</span><span class="dv">2</span>:</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(val) <span class="co"># Output: world world world</span></span></code></pre></div>
<p><strong>Important Note:</strong> Without specifying <em>times</em>, <code>repeat()</code> is an infinite iterator. Remember to always have a mechanism to stop the iteration when used without <code>times</code>.</p>
<h2 id="combinatoric-iterators">Combinatoric Iterators</h2>
<p>The <code>itertools</code> module provides several functions for generating various combinatoric sequences, such as Cartesian products, permutations, and combinations. These are particularly useful in situations where you need to systematically explore all possible arrangements or selections of elements from a given set.</p>
<h3 id="product">product()</h3>
<p><code>product(*iterables, repeat=1)</code></p>
<p>This function computes the Cartesian product of input iterables. It returns an iterator that generates tuples, where each tuple contains one element from each input iterable. The <code>repeat</code> argument specifies how many times each iterable should be repeated in the product.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> product</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>letters <span class="op">=</span> [<span class="st">'A'</span>, <span class="st">'B'</span>]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Cartesian product of letters and numbers</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> product(letters, numbers):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)  <span class="co"># Output: ('A', 1) ('A', 2) ('B', 1) ('B', 2)</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Cartesian product of letters with itself (repeat=2)</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> product(letters, repeat<span class="op">=</span><span class="dv">2</span>):</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)  <span class="co"># Output: ('A', 'A') ('A', 'B') ('B', 'A') ('B', 'B')</span></span></code></pre></div>
<h3 id="permutations">permutations()</h3>
<p><code>permutations(iterable, r=None)</code></p>
<p>This function returns successive <em>r</em>-length permutations of elements in the input <em>iterable</em>. If <em>r</em> is not specified or is None, then <em>r</em> defaults to the length of the iterable and all possible full-length permutations are generated.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> permutations</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>letters <span class="op">=</span> [<span class="st">'A'</span>, <span class="st">'B'</span>, <span class="st">'C'</span>]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># All permutations of length 2</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> permutations(letters, <span class="dv">2</span>):</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)  <span class="co"># Output: ('A', 'B') ('A', 'C') ('B', 'A') ('B', 'C') ('C', 'A') ('C', 'B')</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co"># All permutations of length 3 (all possible permutations)</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> permutations(letters):</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)  <span class="co"># Output: ('A', 'B', 'C') ('A', 'C', 'B') ('B', 'A', 'C') ('B', 'C', 'A') ('C', 'A', 'B') ('C', 'B', 'A')</span></span></code></pre></div>
<h3 id="combinations">combinations()</h3>
<p><code>combinations(iterable, r)</code></p>
<p>This function returns <em>r</em>-length combinations of elements from the input <em>iterable</em>. A combination is an unordered selection of items, unlike permutations which are ordered.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> combinations</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>letters <span class="op">=</span> [<span class="st">'A'</span>, <span class="st">'B'</span>, <span class="st">'C'</span>]</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># All combinations of length 2</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> combinations(letters, <span class="dv">2</span>):</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)  <span class="co"># Output: ('A', 'B') ('A', 'C') ('B', 'C')</span></span></code></pre></div>
<h3 id="combinations_with_replacement">combinations_with_replacement()</h3>
<p><code>combinations_with_replacement(iterable, r)</code></p>
<p>Similar to <code>combinations()</code>, but this function allows elements to be selected multiple times. It returns <em>r</em>-length combinations with replacement from the input <em>iterable</em>.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> combinations_with_replacement</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>letters <span class="op">=</span> [<span class="st">'A'</span>, <span class="st">'B'</span>]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co"># All combinations with replacement of length 2</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> combinations_with_replacement(letters, <span class="dv">2</span>):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)  <span class="co"># Output: ('A', 'A') ('A', 'B') ('B', 'B')</span></span></code></pre></div>
<h2 id="iterators-terminating-on-the-shortest-input-sequence">Iterators terminating on the shortest input sequence</h2>
<p>Several <code>itertools</code> functions are designed to work with multiple input iterables, and their behavior is determined by the shortest input sequence. This means the iteration stops when the shortest iterable is exhausted. This section covers such functions.</p>
<h3 id="chain">chain()</h3>
<p><code>chain(*iterables)</code></p>
<p>This function takes multiple iterables as input and returns an iterator that chains them together. It yields elements from the first iterable until it’s exhausted, then moves on to the second, and so on. The iteration stops when the shortest input iterable is exhausted.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> chain</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>list1 <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>list2 <span class="op">=</span> [<span class="st">'a'</span>, <span class="st">'b'</span>]</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>list3 <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">40</span>]</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> chain(list1, list2, list3):</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)  <span class="co"># Output: 1 2 3 a b</span></span></code></pre></div>
<p>In this example, <code>chain</code> processes <code>list1</code>, <code>list2</code>, and then <code>list3</code>. It stops after exhausting <code>list2</code>, even though <code>list3</code> contains additional elements.</p>
<h3 id="chain.from_iterable">chain.from_iterable()</h3>
<p><code>chain.from_iterable(iterable)</code></p>
<p>This is a class method of <code>chain</code> that takes a single iterable of iterables as input. It behaves similarly to <code>chain()</code>, but allows you to pass a collection of iterables as a single argument.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> chain</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>list_of_lists <span class="op">=</span> [[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="st">'a'</span>, <span class="st">'b'</span>], [<span class="dv">10</span>, <span class="dv">20</span>]]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> chain.from_iterable(list_of_lists):</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)  <span class="co"># Output: 1 2 3 a b 10 20</span></span></code></pre></div>
<p>This is functionally equivalent to <code>chain([1, 2, 3], ['a', 'b'], [10, 20])</code> but more concise when dealing with a collection of iterables.</p>
<h3 id="zip_longest">zip_longest()</h3>
<p><code>zip_longest(*iterables, fillvalue=None)</code></p>
<p>This function is similar to the built-in <code>zip()</code> function, but it continues until the longest iterable is exhausted. When shorter iterables are exhausted, it fills in missing values with the specified <em>fillvalue</em> (defaulting to <code>None</code>).</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> zip_longest</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>list1 <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>list2 <span class="op">=</span> [<span class="st">'a'</span>, <span class="st">'b'</span>]</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> zip_longest(list1, list2, fillvalue<span class="op">=</span><span class="st">'-'</span>):</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)  <span class="co"># Output: (1, 'a') (2, 'b') (3, '-')</span></span></code></pre></div>
<p><code>zip()</code> would have stopped at <code>(2,'b')</code>. <code>zip_longest()</code> extends the iteration to the length of the longest iterable, filling in <code>'-'</code> for missing values in the shorter list.</p>
<h2 id="filtering-iterators">Filtering Iterators</h2>
<p>The <code>itertools</code> module offers several functions for filtering iterators based on specified conditions. These functions provide efficient ways to selectively process elements from an iterator without needing to create intermediate lists.</p>
<h3 id="filterfalse">filterfalse()</h3>
<p><code>filterfalse(function, iterable)</code></p>
<p>This function returns an iterator yielding elements from the <em>iterable</em> for which the <em>function</em> returns <code>False</code>. It’s the opposite of the built-in <code>filter()</code> function, which yields elements where the function returns <code>True</code>.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> filterfalse</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_even(x):</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter out even numbers</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> num <span class="kw">in</span> filterfalse(is_even, numbers):</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(num)  <span class="co"># Output: 1 3 5</span></span></code></pre></div>
<h3 id="takewhile">takewhile()</h3>
<p><code>takewhile(predicate, iterable)</code></p>
<p>This function returns an iterator that yields elements from the <em>iterable</em> as long as the <em>predicate</em> function returns <code>True</code>. The iteration stops immediately when the predicate returns <code>False</code>, even if there are remaining elements in the iterable.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> takewhile</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">8</span>, <span class="dv">2</span>]</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> less_than_5(x):</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">&lt;</span> <span class="dv">5</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Take numbers while they are less than 5</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> num <span class="kw">in</span> takewhile(less_than_5, numbers):</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(num)  <span class="co"># Output: 1 4</span></span></code></pre></div>
<p>The output stops at 4 because <code>less_than_5(6)</code> is <code>False</code>.</p>
<h3 id="dropwhile">dropwhile()</h3>
<p><code>dropwhile(predicate, iterable)</code></p>
<p>This function is the opposite of <code>takewhile()</code>. It returns an iterator that skips elements from the <em>iterable</em> as long as the <em>predicate</em> function returns <code>True</code>. It starts yielding elements only after the predicate returns <code>False</code> for the first time, and continues yielding the remaining elements.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> dropwhile</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">8</span>, <span class="dv">2</span>]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> less_than_5(x):</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">&lt;</span> <span class="dv">5</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop numbers while they are less than 5</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> num <span class="kw">in</span> dropwhile(less_than_5, numbers):</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(num)  <span class="co"># Output: 6 3 8 2</span></span></code></pre></div>
<p>The output begins at 6 because that’s the first element for which <code>less_than_5()</code> returns <code>False</code>.</p>
<h2 id="grouping-data">Grouping Data</h2>
<h3 id="groupby">groupby()</h3>
<p><code>groupby(iterable, key=None)</code></p>
<p>The <code>groupby()</code> function is a powerful tool for grouping consecutive elements in an iterable that share a common key. It’s particularly useful for processing data that’s already sorted or pre-grouped according to some criterion. The function returns an iterator that yields pairs; each pair consists of a key and an iterator over the elements that share that key.</p>
<p><strong>Important Considerations:</strong></p>
<ul>
<li><p><strong>Data Must Be Sorted:</strong> <code>groupby()</code> groups <em>consecutive</em> elements with the same key. If your data isn’t sorted by the key, you’ll get unexpected groupings. You typically need to sort your data using <code>sorted()</code> with a custom <code>key</code> function before using <code>groupby()</code>.</p></li>
<li><p><strong>Key Function:</strong> The optional <code>key</code> argument specifies a function that’s applied to each element to determine its key. If <code>key</code> is not provided, the elements themselves are used as keys.</p></li>
<li><p><strong>Iterator of Iterators:</strong> The result of <code>groupby()</code> is an iterator of <em>key, group</em> pairs. The <em>group</em> is itself an iterator containing the elements with that key. You need nested loops to iterate through the groups.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> groupby</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [(<span class="st">'a'</span>, <span class="dv">1</span>), (<span class="st">'a'</span>, <span class="dv">2</span>), (<span class="st">'b'</span>, <span class="dv">3</span>), (<span class="st">'b'</span>, <span class="dv">4</span>), (<span class="st">'a'</span>, <span class="dv">5</span>)]</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Sort the data by the first element (the key)</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>sorted_data <span class="op">=</span> <span class="bu">sorted</span>(data, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">0</span>])</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Group by the first element</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key, group <span class="kw">in</span> groupby(sorted_data, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">0</span>]):</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Key: </span><span class="sc">{</span>key<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> item <span class="kw">in</span> group:</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  Item: </span><span class="sc">{</span>item<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div>
<p>This will output:</p>
<pre><code>Key: a
  Item: ('a', 1)
  Item: ('a', 2)
Key: b
  Item: ('b', 3)
  Item: ('b', 4)
Key: a
  Item: ('a', 5)</code></pre>
<p>Notice how the ‘a’ elements are grouped together, even though they are not consecutive in the original <code>data</code> list. The sorting step is crucial for <code>groupby()</code> to function correctly. If <code>sorted_data</code> wasn’t used, the output would be different and incorrect. This emphasizes the need to pre-sort data when using <code>groupby()</code>.</p>
<h2 id="function-composition">Function Composition</h2>
<h3 id="starmap">starmap()</h3>
<p><code>starmap(function, iterable)</code></p>
<p>The <code>starmap()</code> function applies a given function to arguments unpacked from an iterable. It’s a convenient way to apply a function to a sequence of tuples where each tuple represents the arguments for a single function call. This avoids the need for explicit unpacking within a loop.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> starmap</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add(x, y):</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">+</span> y</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">3</span>, <span class="dv">4</span>), (<span class="dv">5</span>, <span class="dv">6</span>)]</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply add() to each tuple in numbers</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> result <span class="kw">in</span> starmap(add, numbers):</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(result)  <span class="co"># Output: 3 7 11</span></span></code></pre></div>
<p>In this example, <code>starmap(add, numbers)</code> is equivalent to:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x, y <span class="kw">in</span> numbers:</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(add(x,y))</span></code></pre></div>
<p>but <code>starmap</code> is more concise and often more efficient, particularly for large datasets. <code>starmap</code> automatically unpacks each tuple from <code>numbers</code> and passes the unpacked values as arguments to the <code>add</code> function. This makes the code cleaner and easier to read, especially when dealing with functions that take multiple arguments.</p>
<h2 id="working-with-iterators">Working with Iterators</h2>
<p>This section details several <code>itertools</code> functions that provide versatile ways to manipulate and work with iterators.</p>
<h3 id="islice">islice()</h3>
<p><code>islice(iterable, start, stop[, step])</code></p>
<p>This function returns an iterator that yields selected items from the input <em>iterable</em>, similar to Python’s slicing syntax for sequences. It takes <code>start</code>, <code>stop</code>, and optional <code>step</code> arguments, just like slicing. Note that <code>start</code> is inclusive and <code>stop</code> is exclusive.</p>
<p><strong>Examples:</strong></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> islice</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> <span class="bu">range</span>(<span class="dv">10</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Get items from index 2 up to (but not including) index 5</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>sliced_numbers <span class="op">=</span> islice(numbers, <span class="dv">2</span>, <span class="dv">5</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(sliced_numbers))  <span class="co"># Output: [2, 3, 4]</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Get every other item starting from index 0 up to (but not including) index 8</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>sliced_numbers <span class="op">=</span> islice(numbers, <span class="dv">0</span>, <span class="dv">8</span>, <span class="dv">2</span>)</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(sliced_numbers))  <span class="co"># Output: [0, 2, 4, 6]</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="co">#Get all items from index 3 onwards</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>sliced_numbers <span class="op">=</span> islice(numbers, <span class="dv">3</span>, <span class="va">None</span>)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(sliced_numbers)) <span class="co"># Output: [3, 4, 5, 6, 7, 8, 9]</span></span></code></pre></div>
<p><code>islice</code> is highly efficient because it doesn’t create a full copy of the iterable; it generates values on demand.</p>
<h3 id="tee">tee()</h3>
<p><code>tee(iterable, n=2)</code></p>
<p>This function returns <em>n</em> independent iterators from a single iterable. Each iterator maintains its own position, allowing you to iterate over the same data multiple times from different points.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> tee</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>iter1, iter2 <span class="op">=</span> tee(numbers)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(iter1))  <span class="co"># Output: [1, 2, 3, 4, 5]</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(iter2))  <span class="co"># Output: [1, 2, 3, 4, 5]</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="co">#Iterate over iter1 to consume some items</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="bu">next</span>(iter1)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="bu">next</span>(iter1)</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(iter1)) <span class="co">#Output: [3, 4, 5]</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span class="co">#iter2 is unaffected by the consumption of items from iter1</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(iter2)) <span class="co"># Output: [1, 2, 3, 4, 5]</span></span></code></pre></div>
<p><code>tee()</code> is useful when you need to process the same iterable multiple times without re-reading or creating copies of the original data. However, be aware that it does use some internal memory to keep track of the iterators. For extremely large datasets, using <code>tee()</code> with a large <code>n</code> may become inefficient.</p>
<h3 id="zip">zip()</h3>
<p><code>zip(*iterables)</code></p>
<p>While not strictly part of <code>itertools</code>, it’s important to note that <code>itertools</code> works closely with the built-in <code>zip()</code> function (which in python 3 returns an iterator). <code>zip()</code> aggregates elements from multiple iterables into tuples. It stops when the shortest iterable is exhausted.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>names <span class="op">=</span> [<span class="st">'Alice'</span>, <span class="st">'Bob'</span>, <span class="st">'Charlie'</span>]</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>ages <span class="op">=</span> [<span class="dv">25</span>, <span class="dv">30</span>, <span class="dv">28</span>]</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, age <span class="kw">in</span> <span class="bu">zip</span>(names, ages):</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss"> is </span><span class="sc">{</span>age<span class="sc">}</span><span class="ss"> years old."</span>)  <span class="co"># Output: Alice is 25 years old. Bob is 30 years old. Charlie is 28 years old.</span></span></code></pre></div>
<h3 id="compress">compress()</h3>
<p><code>compress(data, selectors)</code></p>
<p>This function filters elements from the <em>data</em> iterable based on boolean values from the <em>selectors</em> iterable. It yields elements from <em>data</em> only where the corresponding element in <em>selectors</em> is <code>True</code>. The iterables must be of the same length; otherwise, a <code>ValueError</code> is raised.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> compress</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>selectors <span class="op">=</span> [<span class="va">True</span>, <span class="va">False</span>, <span class="va">True</span>, <span class="va">False</span>, <span class="va">True</span>]</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> compress(data, selectors):</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)  <span class="co"># Output: 1 3 5</span></span></code></pre></div>
<p><code>compress()</code> is efficient because it doesn’t create intermediate lists; it only yields elements as they are needed.</p>
<h2 id="advanced-usage-and-examples">Advanced Usage and Examples</h2>
<p>This section explores more advanced techniques and showcases the power of <code>itertools</code> in various scenarios.</p>
<h3 id="combining-multiple-itertools-functions">Combining Multiple Itertools Functions</h3>
<p>One of the strengths of <code>itertools</code> is the ability to chain multiple functions together to create complex data processing pipelines. This approach enhances code readability and efficiency by avoiding explicit loops and large intermediate data structures.</p>
<p><strong>Example: Finding all even numbers less than 100 that are divisible by 3.</strong></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> count, filterfalse, takewhile</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_even(x):</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_divisible_by_3(x):</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">%</span> <span class="dv">3</span> <span class="op">==</span><span class="dv">0</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>numbers <span class="op">=</span> count() <span class="co">#Infinite counter</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>even_numbers <span class="op">=</span> filterfalse(is_even, numbers) <span class="co">#Filter out odd numbers</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>even_numbers_less_than_100 <span class="op">=</span> takewhile(<span class="kw">lambda</span> x: x <span class="op">&lt;</span> <span class="dv">100</span>, even_numbers) <span class="co"># Limit to numbers less than 100</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>numbers_divisible_by_3 <span class="op">=</span> filterfalse(is_divisible_by_3, even_numbers_less_than_100)</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="co">#Find the desired numbers. Since the number of desired results is small, converting to a list is acceptable.</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> <span class="bu">list</span>(numbers_divisible_by_3) </span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(results) <span class="co">#Output: [6, 18, 30, 42, 54, 66, 78, 90]</span></span></code></pre></div>
<p>This example chains <code>count()</code>, <code>filterfalse()</code> (twice), and <code>takewhile()</code> to efficiently find the desired numbers without creating a large list of all numbers up to 100.</p>
<h3 id="efficient-data-processing-with-itertools">Efficient Data Processing with itertools</h3>
<p><code>itertools</code> is particularly beneficial when working with large datasets that wouldn’t fit comfortably in memory. Its functions generate values on demand, reducing memory usage and improving performance significantly. The memory efficiency comes from lazy evaluation - values are computed only when needed.</p>
<p><strong>Example: Processing a large file line by line.</strong></p>
<p>Instead of reading the entire file into memory at once, you could use <code>itertools</code> in conjunction with a file iterator to process the file line by line:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> islice</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> process_large_file(filename, chunk_size<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(filename, <span class="st">'r'</span>) <span class="im">as</span> f:</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>            chunk <span class="op">=</span> <span class="bu">list</span>(islice(f, chunk_size))  <span class="co">#Process the file in smaller chunks</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> chunk:</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Process each chunk (e.g., calculate statistics, filter data etc.)</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>            <span class="co">#Example: count the number of lines in each chunk.</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Processed a chunk of </span><span class="sc">{</span><span class="bu">len</span>(chunk)<span class="sc">}</span><span class="ss"> lines."</span>)</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="co">#Example Usage:</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>process_large_file(<span class="st">"my_large_file.txt"</span>)</span></code></pre></div>
<p>This approach avoids loading the entire file into memory.</p>
<h3 id="real-world-applications">Real-world Applications</h3>
<p><code>itertools</code> is applicable in a wide range of scenarios, including:</p>
<ul>
<li><strong>Data Analysis:</strong> Efficiently processing and filtering large datasets, grouping data based on key values, generating combinations and permutations for statistical analysis.</li>
<li><strong>Machine Learning:</strong> Creating data generators for training models, generating different variations of input data for model robustness testing.</li>
<li><strong>Web Development:</strong> Handling large amounts of data efficiently in web applications, generating paginated results, and managing iterators for streaming data.</li>
<li><strong>Algorithm Design:</strong> Implementing efficient algorithms that require systematic exploration of combinations, permutations, or sequences (e.g., graph algorithms, combinatorial optimization).</li>
<li><strong>Game Development:</strong> Generating game boards, simulating scenarios, and managing game states efficiently.</li>
</ul>
<p>By mastering <code>itertools</code>, developers can write more efficient, readable, and maintainable code for a wide range of applications involving iterative data processing.</p>
<h2 id="performance-considerations">Performance Considerations</h2>
<p>The <code>itertools</code> module is designed with performance in mind, particularly regarding memory usage and speed. However, understanding the trade-offs and potential performance bottlenecks is crucial for optimal usage.</p>
<h3 id="memory-efficiency">Memory Efficiency</h3>
<p>The primary advantage of <code>itertools</code> is its memory efficiency. Unlike many other approaches that create and store entire lists in memory, <code>itertools</code> functions generate values on demand (lazy evaluation). This is especially critical when dealing with large datasets or infinite sequences where loading everything into memory would be infeasible or lead to excessive memory consumption and potential crashes.</p>
<p><strong>How <code>itertools</code> achieves memory efficiency:</strong></p>
<ul>
<li><strong>Generators:</strong> Many <code>itertools</code> functions are implemented as generators. Generators yield values one at a time, only when requested, avoiding the creation of intermediate lists.</li>
<li><strong>Lazy Evaluation:</strong> Values are computed only when they are actually needed, preventing unnecessary calculations and memory allocation.</li>
<li><strong>Minimal Data Structures:</strong> <code>itertools</code> functions use minimal internal data structures, reducing memory overhead.</li>
</ul>
<p>However, it is important to note that:</p>
<ul>
<li><strong><code>tee()</code> function:</strong> The <code>tee()</code> function creates multiple independent iterators from a single iterable. While convenient, this requires internal buffering to track the state of each iterator. Using <code>tee()</code> with a large number of iterators or on very large datasets can lead to increased memory usage.</li>
<li><strong>Chaining:</strong> Chaining multiple <code>itertools</code> functions can introduce a small performance overhead due to the function calls. However, this overhead is typically insignificant compared to the memory savings in most cases.</li>
<li><strong>Large Intermediate Results:</strong> If you convert the result of an <code>itertools</code> function to a list (e.g., using <code>list()</code>), you’ll lose the memory efficiency benefits. Only do this if the entire result set comfortably fits in memory.</li>
</ul>
<h3 id="speed-optimization">Speed Optimization</h3>
<p>While <code>itertools</code> is generally fast, there are situations where careful consideration can further improve performance:</p>
<ul>
<li><strong>Avoid Unnecessary Conversions:</strong> Avoid converting iterators to lists (<code>list()</code>) unless absolutely necessary, as this negates the memory benefits and can be slow for large iterables.</li>
<li><strong>Choose Appropriate Functions:</strong> Select the most suitable <code>itertools</code> function for the task. For example, using <code>islice()</code> to extract a portion of an iterable is generally faster than manually iterating and checking indices.</li>
<li><strong>Data Preprocessing:</strong> Pre-sorting data can significantly improve the performance of functions like <code>groupby()</code>, which relies on consecutive elements having the same key.</li>
<li><strong>Vectorized Operations:</strong> For computationally intensive operations on numerical data, consider using NumPy, which offers vectorized operations that are often much faster than looping with <code>itertools</code>.</li>
<li><strong>Profiling:</strong> Use Python’s profiling tools (e.g., <code>cProfile</code>) to identify performance bottlenecks in your code. This helps pinpoint areas where optimization is most impactful.</li>
</ul>
<p>By understanding these aspects and choosing the appropriate <code>itertools</code> functions and techniques, you can maximize the performance of your data processing code while keeping memory usage under control.</p>


<footer>Copyright 2025 - Muthukrishnan</footer>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561" crossorigin="anonymous"></script>




</body></html>