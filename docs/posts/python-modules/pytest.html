<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Muthukrishnan">

<title>pytest - Documentation – Technical Manuals</title>
<style>
html {
  color: #1a1a1a;
  background-color: #fdfdfd;
}
body {
  margin: 0 auto;
  max-width: 36em;
  padding-left: 50px;
  padding-right: 50px;
  padding-top: 50px;
  padding-bottom: 50px;
  hyphens: auto;
  overflow-wrap: break-word;
  text-rendering: optimizeLegibility;
  font-kerning: normal;
}
@media (max-width: 600px) {
  body {
    font-size: 0.9em;
    padding: 12px;
  }
  h1 {
    font-size: 1.8em;
  }
}
@media print {
  html {
    background-color: white;
  }
  body {
    background-color: transparent;
    color: black;
    font-size: 12pt;
  }
  p, h2, h3 {
    orphans: 3;
    widows: 3;
  }
  h2, h3, h4 {
    page-break-after: avoid;
  }
}
p {
  margin: 1em 0;
}
a {
  color: #1a1a1a;
}
a:visited {
  color: #1a1a1a;
}
img {
  max-width: 100%;
}
svg {
  height; auto;
  max-width: 100%;
}
h1, h2, h3, h4, h5, h6 {
  margin-top: 1.4em;
}
h5, h6 {
  font-size: 1em;
  font-style: italic;
}
h6 {
  font-weight: normal;
}
ol, ul {
  padding-left: 1.7em;
  margin-top: 1em;
}
li > ol, li > ul {
  margin-top: 0;
}
ul > li:not(:has(> p)) > ul,
ol > li:not(:has(> p)) > ul,
ul > li:not(:has(> p)) > ol,
ol > li:not(:has(> p)) > ol {
  margin-bottom: 0;
}
ul > li:not(:has(> p)) > ul > li:has(> p),
ol > li:not(:has(> p)) > ul > li:has(> p),
ul > li:not(:has(> p)) > ol > li:has(> p),
ol > li:not(:has(> p)) > ol > li:has(> p) {
  margin-top: 1rem;
}
blockquote {
  margin: 1em 0 1em 1.7em;
  padding-left: 1em;
  border-left: 2px solid #e6e6e6;
  color: #606060;
}
code {
  font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
  font-size: 85%;
  margin: 0;
  hyphens: manual;
}
pre {
  margin: 1em 0;
  overflow: auto;
}
pre code {
  padding: 0;
  overflow: visible;
  overflow-wrap: normal;
}
.sourceCode {
 background-color: transparent;
 overflow: visible;
}
hr {
  background-color: #1a1a1a;
  border: none;
  height: 1px;
  margin: 1em 0;
}
table {
  margin: 1em 0;
  border-collapse: collapse;
  width: 100%;
  overflow-x: auto;
  display: block;
  font-variant-numeric: lining-nums tabular-nums;
}
table caption {
  margin-bottom: 0.75em;
}
tbody {
  margin-top: 0.5em;
  border-top: 1px solid #1a1a1a;
  border-bottom: 1px solid #1a1a1a;
}
th {
  border-top: 1px solid #1a1a1a;
  padding: 0.25em 0.5em 0.25em 0.5em;
}
td {
  padding: 0.125em 0.5em 0.25em 0.5em;
}
header {
  margin-bottom: 4em;
  text-align: center;
}
#TOC li {
  list-style: none;
}
#TOC ul {
  padding-left: 1.3em;
}
#TOC > ul {
  padding-left: 0;
}
#TOC a:not(:hover) {
  text-decoration: none;
}
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<link href="../../favicon.ico" rel="icon">
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-MXDPF6L5TL"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-MXDPF6L5TL', { 'anonymize_ip': true});
</script>
<link rel="icon" type="image/x-icon" href="favicon.ico">
<meta property="og:title" content="pytest - Documentation – Technical Manuals">
<meta property="og:site_name" content="Technical Manuals">
</head><body><div class="navigation-header">
    <nav>
        <div>
            <div class="logo">
                <a href="../../" aria-label="Home">
                    <span>Technical Manuals - Home</span>
                </a>
            </div>
            <div class="nav-menu">
                <ul>
                    <li>
                        <a href="../../about.html">
                            <span class="menu-text">About</span>
                        </a>
                    </li>
                    <li> 
                        <a href="https://github.com/muthuspark" target="_blank">
                            <span class="menu-text">Github</span>
                        </a>
                    </li>
                    <li>
                        <a href="https://linkedin.com/in/krimuthu" target="_blank">
                            <span class="menu-text">Linkedin</span>
                        </a>
                    </li>
                    <li>
                        <button onclick="window.print()" class="print-button">
                            <svg width="20" height="20" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <path d="M6 9V2h12v7"></path>
                              <path d="M6 18H4a2 2 0 01-2-2v-5a2 2 0 012-2h16a2 2 0 012 2v5a2 2 0 01-2 2h-2"></path>
                              <path d="M6 14h12v8H6z"></path>
                            </svg>
                            Print Page
                        </button>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
</div>


<link rel="stylesheet" href="../../styles.css">





<header id="title-block-header">
<h1 class="title">pytest - Documentation</h1>

</header>

<nav id="TOC" role="doc-toc">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#what-is-pytest" id="toc-what-is-pytest">What is pytest?</a></li>
  <li><a href="#why-use-pytest" id="toc-why-use-pytest">Why use pytest?</a></li>
  <li><a href="#installation-and-setup" id="toc-installation-and-setup">Installation and Setup</a></li>
  <li><a href="#basic-syntax-and-usage" id="toc-basic-syntax-and-usage">Basic Syntax and Usage</a></li>
  <li><a href="#writing-tests-with-pytest" id="toc-writing-tests-with-pytest">Writing Tests with pytest</a>
  <ul>
  <li><a href="#test-functions-and-naming-conventions" id="toc-test-functions-and-naming-conventions">Test Functions and Naming Conventions</a></li>
  <li><a href="#assertions-and-test-failures" id="toc-assertions-and-test-failures">Assertions and Test Failures</a></li>
  <li><a href="#fixtures-for-test-setup-and-teardown" id="toc-fixtures-for-test-setup-and-teardown">Fixtures for Test Setup and Teardown</a></li>
  <li><a href="#parametrization-for-running-tests-with-multiple-inputs" id="toc-parametrization-for-running-tests-with-multiple-inputs">Parametrization for Running Tests with Multiple Inputs</a></li>
  <li><a href="#using-marks-to-organize-and-control-tests" id="toc-using-marks-to-organize-and-control-tests">Using Marks to Organize and Control Tests</a></li>
  <li><a href="#working-with-test-directories-and-modules" id="toc-working-with-test-directories-and-modules">Working with Test Directories and Modules</a></li>
  </ul></li>
  <li><a href="#advanced-testing-techniques" id="toc-advanced-testing-techniques">Advanced Testing Techniques</a>
  <ul>
  <li><a href="#mocking-and-patching" id="toc-mocking-and-patching">Mocking and Patching</a></li>
  <li><a href="#test-coverage" id="toc-test-coverage">Test Coverage</a></li>
  <li><a href="#debugging-tests" id="toc-debugging-tests">Debugging Tests</a></li>
  <li><a href="#running-tests-in-parallel" id="toc-running-tests-in-parallel">Running Tests in Parallel</a></li>
  <li><a href="#plugins-and-extensions" id="toc-plugins-and-extensions">Plugins and Extensions</a></li>
  <li><a href="#integrating-with-continuous-integration-ci" id="toc-integrating-with-continuous-integration-ci">Integrating with Continuous Integration (CI)</a></li>
  </ul></li>
  <li><a href="#pytest-features-and-best-practices" id="toc-pytest-features-and-best-practices">pytest Features and Best Practices</a>
  <ul>
  <li><a href="#managing-test-dependencies" id="toc-managing-test-dependencies">Managing Test Dependencies</a></li>
  <li><a href="#writing-clean-and-readable-tests" id="toc-writing-clean-and-readable-tests">Writing Clean and Readable Tests</a></li>
  <li><a href="#testing-different-code-structures-classes-modules" id="toc-testing-different-code-structures-classes-modules">Testing Different Code Structures (Classes, Modules)</a></li>
  <li><a href="#handling-exceptions-and-errors-in-tests" id="toc-handling-exceptions-and-errors-in-tests">Handling Exceptions and Errors in Tests</a></li>
  <li><a href="#working-with-external-libraries-and-apis" id="toc-working-with-external-libraries-and-apis">Working with External Libraries and APIs</a></li>
  <li><a href="#advanced-fixtures-usage" id="toc-advanced-fixtures-usage">Advanced Fixtures Usage</a></li>
  <li><a href="#understanding-pytest-configuration" id="toc-understanding-pytest-configuration">Understanding pytest Configuration</a></li>
  <li><a href="#customizing-pytest-behavior-with-plugins" id="toc-customizing-pytest-behavior-with-plugins">Customizing pytest behavior with Plugins</a></li>
  </ul></li>
  <li><a href="#example-test-cases" id="toc-example-test-cases">Example Test Cases</a>
  <ul>
  <li><a href="#testing-functions" id="toc-testing-functions">Testing Functions</a></li>
  <li><a href="#testing-classes" id="toc-testing-classes">Testing Classes</a></li>
  <li><a href="#testing-modules" id="toc-testing-modules">Testing Modules</a></li>
  <li><a href="#testing-apis" id="toc-testing-apis">Testing APIs</a></li>
  <li><a href="#testing-databases" id="toc-testing-databases">Testing Databases</a></li>
  <li><a href="#comprehensive-example-project" id="toc-comprehensive-example-project">Comprehensive Example Project</a></li>
  </ul></li>
  <li><a href="#troubleshooting-and-common-issues" id="toc-troubleshooting-and-common-issues">Troubleshooting and Common Issues</a>
  <ul>
  <li><a href="#debugging-test-failures" id="toc-debugging-test-failures">Debugging Test Failures</a></li>
  <li><a href="#resolving-common-errors" id="toc-resolving-common-errors">Resolving Common Errors</a></li>
  <li><a href="#understanding-pytest-warnings" id="toc-understanding-pytest-warnings">Understanding pytest Warnings</a></li>
  <li><a href="#troubleshooting-plugin-conflicts" id="toc-troubleshooting-plugin-conflicts">Troubleshooting Plugin Conflicts</a></li>
  <li><a href="#performance-optimization" id="toc-performance-optimization">Performance Optimization</a></li>
  </ul></li>
  <li><a href="#appendix" id="toc-appendix">Appendix</a>
  <ul>
  <li><a href="#glossary-of-terms" id="toc-glossary-of-terms">Glossary of Terms</a></li>
  <li><a href="#command-line-options-reference" id="toc-command-line-options-reference">Command-line Options Reference</a></li>
  <li><a href="#configuration-file-options" id="toc-configuration-file-options">Configuration File Options</a></li>
  <li><a href="#further-reading-and-resources" id="toc-further-reading-and-resources">Further Reading and Resources</a></li>
  </ul></li>
  </ul>
</nav>
<h3 id="what-is-pytest">What is pytest?</h3>
<p>pytest is a powerful and versatile testing framework for Python. It’s known for its ease of use, extensibility, and rich plugin ecosystem. pytest allows you to write simple, readable tests that scale well from small projects to large, complex applications. Unlike some testing frameworks that require you to inherit from specific base classes or follow rigid structures, pytest emphasizes simplicity and convention over configuration. It automatically discovers tests and provides a rich set of features for handling assertions, fixtures, parameterization, and more, all while maintaining a clean and concise syntax.</p>
<h3 id="why-use-pytest">Why use pytest?</h3>
<p>Several factors contribute to pytest’s popularity:</p>
<ul>
<li><strong>Simplicity:</strong> pytest’s syntax is incredibly straightforward and intuitive, making it easy to learn and use, even for beginners.</li>
<li><strong>Expressiveness:</strong> You can write tests that closely mirror the logic you’re testing, leading to highly readable and maintainable test suites.</li>
<li><strong>Extensibility:</strong> A vast ecosystem of plugins extends pytest’s functionality, enabling integration with various tools and technologies.</li>
<li><strong>Rich Features:</strong> pytest supports advanced testing techniques like fixtures (for managing test setup and teardown), parameterization (for running tests with multiple inputs), and more.</li>
<li><strong>Detailed Reporting:</strong> pytest generates clear and informative reports, helping you quickly identify and diagnose failures.</li>
<li><strong>Excellent Community Support:</strong> A large and active community provides extensive documentation, support, and a wide range of plugins.</li>
</ul>
<h3 id="installation-and-setup">Installation and Setup</h3>
<p>Installing pytest is straightforward using pip:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install pytest</span></code></pre></div>
<p>That’s it! No further configuration is usually necessary for basic usage. For more advanced features or plugin integration, you may need to install additional packages. For example, to use pytest’s HTML reporting plugin, you would run:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install pytest-html</span></code></pre></div>
<p>To run your tests, navigate to your project’s directory in the terminal and execute:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pytest</span></span></code></pre></div>
<p>pytest automatically discovers and runs tests in files matching the <code>test_*.py</code> or <code>*_test.py</code> naming convention.</p>
<h3 id="basic-syntax-and-usage">Basic Syntax and Usage</h3>
<p>The core of pytest is the <code>assert</code> statement. When an assertion fails, pytest will report the failure and provide context information.</p>
<p>A simple test might look like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add(x, y):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">+</span> y</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_add():</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> add(<span class="dv">2</span>, <span class="dv">3</span>) <span class="op">==</span> <span class="dv">5</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> add(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>) <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> add(<span class="dv">0</span>, <span class="dv">0</span>) <span class="op">==</span> <span class="dv">0</span></span></code></pre></div>
<p>To run this test, save it as <code>test_example.py</code> and execute <code>pytest</code> in your terminal. pytest will discover and execute <code>test_add()</code>. If all assertions pass, pytest will indicate success. If any assertion fails, pytest will report the failure, including the line number and the assertion that failed.</p>
<p>More complex tests can utilize fixtures for setup and teardown, parameterization for running tests with multiple inputs, and other advanced features which are described in later sections of this manual.</p>
<h2 id="writing-tests-with-pytest">Writing Tests with pytest</h2>
<h3 id="test-functions-and-naming-conventions">Test Functions and Naming Conventions</h3>
<p>pytest discovers tests automatically based on naming conventions. Test functions must be named starting with <code>test_</code>. Test classes (which are less common but can be useful for organization) must be named <code>Test*</code> and their methods must also start with <code>test_</code>. Files containing tests should generally follow the naming convention <code>test_*.py</code> or <code>*_test.py</code>. This automatic discovery mechanism simplifies test organization and reduces the boilerplate code. For example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># test_mymodule.py</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_addition():</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">4</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TestSubtraction:</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> test_subtract_positive(<span class="va">self</span>):</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="dv">5</span> <span class="op">-</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">2</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> test_subtract_negative(<span class="va">self</span>):</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="dv">1</span> <span class="op">-</span> <span class="dv">5</span> <span class="op">==</span> <span class="op">-</span><span class="dv">4</span></span></code></pre></div>
<h3 id="assertions-and-test-failures">Assertions and Test Failures</h3>
<p>pytest uses Python’s built-in <code>assert</code> statement for verifying test conditions. When an assertion fails, pytest provides detailed information about the failure, including the failing assertion, the line number, and a traceback. There is no need for explicit <code>assertTrue</code>/<code>assertFalse</code> functions commonly used in other testing frameworks.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_myfunction():</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> my_function(<span class="dv">5</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> result <span class="op">==</span> <span class="dv">10</span>  <span class="co"># Passes if result is 10, fails otherwise</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="bu">type</span>(result) <span class="kw">is</span> <span class="bu">int</span> <span class="co"># Checks the type of the result</span></span></code></pre></div>
<p>If the assertion fails, pytest provides a clear, concise report explaining the failure.</p>
<h3 id="fixtures-for-test-setup-and-teardown">Fixtures for Test Setup and Teardown</h3>
<p>Fixtures provide a mechanism to setup and teardown resources used by your tests. They help eliminate code duplication and ensure consistent test environments. Fixtures are defined using the <code>@pytest.fixture</code> decorator.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pytest</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="at">@pytest.fixture</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> my_fixture():</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Setup code, e.g., create a database connection</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    conn <span class="op">=</span> connect_to_db()</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span> conn  <span class="co"># Yield the fixture value to the test</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Teardown code, e.g., close the database connection</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    conn.close()</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_using_fixture(my_fixture):</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use the fixture within the test</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> my_fixture.execute_query(...)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> results <span class="op">==</span> expected_results</span></code></pre></div>
<p>The code after <code>yield</code> in the fixture will be executed after the test has finished, regardless of whether it passed or failed. This ensures cleanup (like closing a file or a network connection).</p>
<h3 id="parametrization-for-running-tests-with-multiple-inputs">Parametrization for Running Tests with Multiple Inputs</h3>
<p>The <code>@pytest.mark.parametrize</code> decorator allows you to run the same test function with multiple sets of input values. This significantly reduces code duplication when testing with various inputs.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pytest</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="at">@pytest.mark.parametrize</span>(<span class="st">"input, expected"</span>, [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">2</span>, <span class="dv">4</span>), (<span class="dv">3</span>, <span class="dv">6</span>)])</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_double(<span class="bu">input</span>, expected):</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> double(<span class="bu">input</span>) <span class="op">==</span> expected</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> double(x):</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x <span class="op">*</span> <span class="dv">2</span></span></code></pre></div>
<p>This will run <code>test_double</code> three times, once for each input/expected pair.</p>
<h3 id="using-marks-to-organize-and-control-tests">Using Marks to Organize and Control Tests</h3>
<p>Markers (created using <code>@pytest.mark.marker_name</code>) allow you to categorize and manage your tests. This is useful for selectively running subsets of tests or for grouping tests based on functionality or feature.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pytest</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="at">@pytest.mark.slow</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_long_running_process():</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ...</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="at">@pytest.mark.database</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_database_interaction():</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ...</span></span></code></pre></div>
<p>You can then use the <code>-m</code> command-line option to run only tests with specific markers: <code>pytest -m slow</code> will only run tests marked with <code>@pytest.mark.slow</code>.</p>
<h3 id="working-with-test-directories-and-modules">Working with Test Directories and Modules</h3>
<p>pytest automatically discovers tests within a directory structure. Tests are typically organized into separate files and/or directories to improve maintainability and readability. pytest will recursively search for tests in subdirectories, provided they follow the test naming conventions. You can control the search scope using command-line options like <code>pytest ./path/to/tests/</code>. To exclude certain directories or files, you can use configuration files (e.g., <code>pytest.ini</code>) to define patterns to ignore. Well organized test directories reflect the structure of your application’s codebase, promoting better organization and maintainability.</p>
<h2 id="advanced-testing-techniques">Advanced Testing Techniques</h2>
<h3 id="mocking-and-patching">Mocking and Patching</h3>
<p>Mocking and patching are essential for isolating units of code during testing. pytest seamlessly integrates with the <code>unittest.mock</code> library (or <code>mock</code> for older Python versions) to allow mocking of functions, methods, and even entire modules. This is crucial for testing components that interact with external systems (databases, APIs, file systems) without the need to have those systems available during testing.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pytest</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> unittest.mock <span class="im">import</span> patch</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> my_function(external_dependency):</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> external_dependency.get_data()</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="at">@patch</span>(<span class="st">'my_module.external_dependency.get_data'</span>, return_value<span class="op">=</span><span class="st">'mocked data'</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_my_function_with_mock(mock_get_data):</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> my_function(external_dependency) <span class="co">#external_dependency is mocked</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> result <span class="op">==</span> <span class="st">'mocked data'</span></span></code></pre></div>
<p>This example patches the <code>get_data</code> method of the <code>external_dependency</code> object, replacing it with a mock that returns “mocked data”.</p>
<h3 id="test-coverage">Test Coverage</h3>
<p>Measuring test coverage helps identify areas of your codebase that are not adequately tested. Tools like <code>pytest-cov</code> provide detailed reports on statement, branch, and other types of code coverage. To use <code>pytest-cov</code>, install it (<code>pip install pytest-cov</code>) and then run pytest with the <code>--cov</code> and <code>--cov-report</code> options:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pytest</span> <span class="at">--cov</span><span class="op">=</span>my_module <span class="at">--cov-report</span> term-missing</span></code></pre></div>
<p>This will generate a report showing the lines of code in <code>my_module</code> that are not covered by tests.</p>
<h3 id="debugging-tests">Debugging Tests</h3>
<p>When tests fail, it’s often necessary to debug the failing test or the code being tested. Standard Python debugging techniques (using pdb or IDE debuggers) work with pytest. You can add breakpoints directly into your test functions or use the <code>--pdb</code> command-line option to automatically drop into the debugger when a test fails.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pytest</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pdb</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_example():</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  a <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  b <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  pdb.set_trace() <span class="co">#Breakpoint</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  result <span class="op">=</span> a<span class="op">/</span>b</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">assert</span> result <span class="op">==</span> <span class="dv">0</span> <span class="co">#This will likely trigger an exception before this line.</span></span></code></pre></div>
<h3 id="running-tests-in-parallel">Running Tests in Parallel</h3>
<p>Running tests in parallel can significantly reduce the overall testing time, especially for large test suites. pytest-xdist is a popular plugin that enables parallel test execution. Install it (<code>pip install pytest-xdist</code>) and run pytest with the <code>-n</code> option, specifying the number of processes to use.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pytest</span> <span class="at">-n</span> auto  <span class="co"># Use all available CPU cores.</span></span></code></pre></div>
<p>This will distribute tests across multiple processes, speeding up the testing process.</p>
<h3 id="plugins-and-extensions">Plugins and Extensions</h3>
<p>pytest’s extensibility is a key strength. Numerous plugins extend its functionality to support various needs, such as integration with specific frameworks, generating custom reports, and adding new features. The plugin ecosystem is vast and well-documented. To install a plugin, use pip: <code>pip install pytest-plugin-name</code>.</p>
<h3 id="integrating-with-continuous-integration-ci">Integrating with Continuous Integration (CI)</h3>
<p>Continuous integration (CI) systems like GitHub Actions, GitLab CI, Jenkins, and others readily integrate with pytest. You typically define a CI job that runs pytest. The CI system will provide feedback on test results, automatically reporting successes and failures. The simplest approach often involves installing pytest and running <code>pytest</code> as part of a shell script within your CI configuration. Many CI systems also offer built-in integrations that simplify this process.</p>
<h2 id="pytest-features-and-best-practices">pytest Features and Best Practices</h2>
<h3 id="managing-test-dependencies">Managing Test Dependencies</h3>
<p>Efficiently managing dependencies is crucial for maintainable test suites. Avoid tightly coupling tests to each other. Use fixtures to provide necessary resources to tests, ensuring that each test has the resources it needs without affecting others. This promotes independence and prevents cascading failures. For external dependencies (databases, APIs), use mocking or test doubles when possible to isolate your tests from the external system’s availability and behavior.</p>
<h3 id="writing-clean-and-readable-tests">Writing Clean and Readable Tests</h3>
<p>Write tests that are easy to understand and maintain. Use descriptive names for test functions and variables. Keep tests concise and focused on testing a single aspect of the code. Use meaningful assertions that clearly state what is being tested and the expected outcome. Avoid overly complex logic within tests – if your test is hard to understand, it’s probably time to refactor. Aim for high readability.</p>
<h3 id="testing-different-code-structures-classes-modules">Testing Different Code Structures (Classes, Modules)</h3>
<p>pytest adapts well to various code structures. For functions, simple <code>test_</code> prefixed functions suffice. For classes, create <code>Test</code> prefixed classes where methods are <code>test_</code> prefixed. Organize tests logically, mirroring the structure of your codebase. Use fixtures to share setup and teardown between tests within a class, or even across different modules.</p>
<h3 id="handling-exceptions-and-errors-in-tests">Handling Exceptions and Errors in Tests</h3>
<p>Use <code>pytest.raises</code> context manager to assert that a specific exception is raised by a function or block of code. This allows you to test error handling in your application.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pytest</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> my_function(x):</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Input must be non-negative"</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_my_function_raises_exception():</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> pytest.raises(<span class="pp">ValueError</span>) <span class="im">as</span> excinfo:</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        my_function(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="st">"Input must be non-negative"</span> <span class="kw">in</span> <span class="bu">str</span>(excinfo.value)</span></code></pre></div>
<p>This test ensures that <code>my_function</code> raises a <code>ValueError</code> when the input is negative.</p>
<h3 id="working-with-external-libraries-and-apis">Working with External Libraries and APIs</h3>
<p>When testing code that interacts with external systems (databases, APIs, etc.), use mocks and test doubles to isolate your tests. This ensures your tests are fast, reliable, and don’t depend on the availability of external services. When interacting with real external systems for integration testing, consider using fixtures to manage connections and resources efficiently and cleanly.</p>
<h3 id="advanced-fixtures-usage">Advanced Fixtures Usage</h3>
<p>Fixtures can be parameterized (using <code>@pytest.mark.parametrize</code>) to provide different values to tests. You can also define fixtures that depend on other fixtures, creating a hierarchy of setup steps. Utilize fixture scope (<code>function</code>, <code>class</code>, <code>module</code>, <code>session</code>) to control when fixtures are created and destroyed to optimize resource utilization. Autouse fixtures provide setup automatically to all tests in a module without needing to explicitly pass them as arguments.</p>
<h3 id="understanding-pytest-configuration">Understanding pytest Configuration</h3>
<p>pytest supports configuration through command-line options, environment variables, and configuration files (e.g., <code>pytest.ini</code>, <code>tox.ini</code>). These allow customizing pytest’s behavior to suit your project’s needs. Configuration files define markers, plugins, test selection criteria, and more. Understanding pytest’s configuration mechanisms is key to tailoring its behavior to your specific workflow and project requirements.</p>
<h3 id="customizing-pytest-behavior-with-plugins">Customizing pytest behavior with Plugins</h3>
<p>Plugins enhance pytest’s capabilities. They can add new features, extend existing ones, or integrate with other tools. The plugin ecosystem is a vast resource for customization. Plugins add reporting functionalities (HTML reports, coverage reports), integrate with other testing tools, support specialized testing techniques, and much more. Installing plugins via pip and understanding their configuration options is crucial for adapting pytest to complex project needs.</p>
<h2 id="example-test-cases">Example Test Cases</h2>
<h3 id="testing-functions">Testing Functions</h3>
<p>Let’s test a simple function that calculates the square of a number:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># my_module.py</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> square(x):</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">*</span> x</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># test_my_module.py</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> my_module</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_square_positive():</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> my_module.square(<span class="dv">5</span>) <span class="op">==</span> <span class="dv">25</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_square_zero():</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> my_module.square(<span class="dv">0</span>) <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_square_negative():</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> my_module.square(<span class="op">-</span><span class="dv">3</span>) <span class="op">==</span> <span class="dv">9</span></span></code></pre></div>
<p>This example demonstrates testing a function with various inputs, including positive, zero, and negative numbers.</p>
<h3 id="testing-classes">Testing Classes</h3>
<p>Consider a simple class representing a bank account:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># bank_account.py</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BankAccount:</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, balance<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.balance <span class="op">=</span> balance</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> deposit(<span class="va">self</span>, amount):</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.balance <span class="op">+=</span> amount</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> withdraw(<span class="va">self</span>, amount):</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.balance <span class="op">&gt;=</span> amount:</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.balance <span class="op">-=</span> amount</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Insufficient funds"</span>)</span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># test_bank_account.py</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pytest</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> bank_account <span class="im">import</span> BankAccount</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_deposit():</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    account <span class="op">=</span> BankAccount()</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    account.deposit(<span class="dv">100</span>)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> account.balance <span class="op">==</span> <span class="dv">100</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_withdraw():</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    account <span class="op">=</span> BankAccount(<span class="dv">100</span>)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    account.withdraw(<span class="dv">50</span>)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> account.balance <span class="op">==</span> <span class="dv">50</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_withdraw_insufficient_funds():</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    account <span class="op">=</span> BankAccount(<span class="dv">50</span>)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> pytest.raises(<span class="pp">ValueError</span>):</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>        account.withdraw(<span class="dv">100</span>)</span></code></pre></div>
<p>This showcases testing class methods, including error handling.</p>
<h3 id="testing-modules">Testing Modules</h3>
<p>Testing modules involves testing multiple functions or classes within a module. The structure remains similar to testing individual functions or classes, but might incorporate fixtures for shared setup and teardown across tests within that module.</p>
<h3 id="testing-apis">Testing APIs</h3>
<p>Testing APIs often involves making requests to an API endpoint and checking the response. This frequently involves using libraries like <code>requests</code>. Mocking the API might be necessary for unit tests to avoid dependencies on the actual API’s availability.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># test_api.py</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> requests</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pytest</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_api_get_request():</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    response <span class="op">=</span> requests.get(<span class="st">"https://api.example.com/data"</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> response.status_code <span class="op">==</span> <span class="dv">200</span> <span class="co">#Check for successful response</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> response.json()[<span class="st">"key"</span>] <span class="op">==</span> <span class="st">"expected_value"</span> <span class="co">#check for expected value in response</span></span></code></pre></div>
<p>This example is simplified; real-world API testing often involves more complex assertions and error handling. Remember to replace <code>"https://api.example.com/data"</code> with a real API endpoint, and adjust the assertion to match the expected response structure.</p>
<h3 id="testing-databases">Testing Databases</h3>
<p>Database testing often involves setting up a test database and interacting with it. Fixtures are useful for setting up and tearing down the test database, and using parameterized tests allows for varied data inputs. Libraries like <code>psycopg2</code> (for PostgreSQL) or others appropriate to your database system are necessary.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># test_database.py</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pytest</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> psycopg2 <span class="co">#Or appropriate database library</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="at">@pytest.fixture</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> db_connection():</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    conn <span class="op">=</span> psycopg2.<span class="ex">connect</span>(...) <span class="co">#connection details</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span> conn</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    conn.close()</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> test_database_query(db_connection):</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    cursor <span class="op">=</span> db_connection.cursor()</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    cursor.execute(<span class="st">"SELECT 1"</span>) <span class="co">#simple query for demonstration</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> cursor.fetchone()</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> result <span class="op">==</span> (<span class="dv">1</span>,)</span></code></pre></div>
<p>This is a basic example; real-world database testing will often involve more complex queries, data manipulation, and error handling.</p>
<h3 id="comprehensive-example-project">Comprehensive Example Project</h3>
<p>A comprehensive example would involve a larger project with multiple modules, classes, functions, and tests demonstrating the integration of various testing techniques and best practices. Due to its complexity, it’s best created in a separate, dedicated project structure. A real-world example could include a web application with features tested through end-to-end tests, integration tests focusing on interactions between application components, and unit tests targeting specific functionalities of the individual components. The tests would use fixtures to manage resources (databases, temporary files), mocks for external dependencies, and parametrization for running tests with various inputs and conditions. This would be too extensive to be included here, but it represents a realistic goal for a comprehensive pytest-based testing strategy.</p>
<h2 id="troubleshooting-and-common-issues">Troubleshooting and Common Issues</h2>
<h3 id="debugging-test-failures">Debugging Test Failures</h3>
<p>When tests fail, pytest provides a detailed traceback showing the point of failure. Carefully examine the traceback to identify the root cause. The error message often points directly to the problem. If the traceback isn’t sufficient, consider the following:</p>
<ul>
<li><p><strong>Use a debugger:</strong> Integrate a debugger (like <code>pdb</code> or your IDE’s debugger) into your tests using <code>pdb.set_trace()</code> to step through the code line by line and inspect variables at runtime. The <code>--pdb</code> command-line option with pytest will automatically start the debugger upon test failure.</p></li>
<li><p><strong>Print statements (temporarily):</strong> Strategically placed <code>print()</code> statements can help track the values of variables and the execution flow. Remove these once debugging is complete.</p></li>
<li><p><strong>Simplify the test:</strong> If a test is overly complex, break it down into smaller, more focused tests to isolate the problem.</p></li>
<li><p><strong>Check for side effects:</strong> Ensure that tests don’t modify shared resources in a way that affects subsequent tests. Use fixtures to manage resources and isolate tests effectively.</p></li>
<li><p><strong>Inspect logs:</strong> Check application logs for clues about the error, especially if the failure is related to interactions with external systems.</p></li>
</ul>
<h3 id="resolving-common-errors">Resolving Common Errors</h3>
<p>Some frequently encountered errors and their solutions include:</p>
<ul>
<li><p><strong><code>ImportError</code>:</strong> This usually means that pytest cannot find a module. Double-check the module’s name, location, and ensure it’s correctly installed in your environment. Verify that your test files are in the correct directory and that pytest is running from the appropriate project root.</p></li>
<li><p><strong><code>NameError</code>:</strong> This indicates that a variable or function is not defined. Verify spelling, scope (local vs.&nbsp;global), and that the variable or function is correctly imported.</p></li>
<li><p><strong><code>AssertionError</code>:</strong> This means that an assertion in your test failed. Carefully review the assertion and the values being compared to understand why the test failed. Make sure that expected values match actual values.</p></li>
<li><p><strong><code>TypeError</code>:</strong> This signifies a type mismatch in an operation or function call. Check that the data types of the inputs match the expected types.</p></li>
<li><p><strong><code>SyntaxError</code>:</strong> This points to incorrect syntax in your test code or tested code. Carefully review the code for syntax errors, common mistakes include missing colons or incorrect indentation.</p></li>
</ul>
<h3 id="understanding-pytest-warnings">Understanding pytest Warnings</h3>
<p>pytest issues warnings to alert you to potential problems or suboptimal practices in your tests or code. Pay attention to warnings; they frequently point out potential bugs or areas for improvement. Common warnings include:</p>
<ul>
<li><p><strong>Unused fixtures:</strong> These warn about fixtures that are defined but not used in any tests. Remove unused fixtures to improve code clarity.</p></li>
<li><p><strong>Unreachable code:</strong> This signals code that is not executed by the test. This can be due to logic errors or incorrect conditional statements.</p></li>
<li><p><strong>Incorrectly defined markers:</strong> If a marker is defined incorrectly, pytest will issue a warning. Check the marker syntax and ensure it’s defined correctly.</p></li>
<li><p><strong>Deprecated features:</strong> Warnings for deprecated features encourage you to update your code to use newer and more supported alternatives.</p></li>
</ul>
<h3 id="troubleshooting-plugin-conflicts">Troubleshooting Plugin Conflicts</h3>
<p>If you encounter problems after installing plugins, a conflict between plugins might be the cause. Try the following:</p>
<ul>
<li><p><strong>Uninstall conflicting plugins:</strong> If you suspect a conflict, temporarily uninstall one or more plugins to see if it resolves the issue.</p></li>
<li><p><strong>Check plugin documentation:</strong> Consult the documentation of the plugins to see if there are known compatibility issues or specific configuration requirements.</p></li>
<li><p><strong>Check pytest version:</strong> Ensure that your pytest version is compatible with the plugins you’re using.</p></li>
<li><p><strong>Simplify your <code>pytest.ini</code>:</strong> If you use <code>pytest.ini</code>, try removing or commenting out any plugins or configurations to determine if a specific configuration is causing the conflict.</p></li>
</ul>
<h3 id="performance-optimization">Performance Optimization</h3>
<p>For large test suites, performance optimization is critical. Consider these strategies:</p>
<ul>
<li><p><strong>Parallelization:</strong> Use <code>pytest-xdist</code> to run tests in parallel, significantly reducing overall execution time.</p></li>
<li><p><strong>Efficient fixtures:</strong> Design fixtures to minimize setup and teardown overhead. Only create resources when necessary, and avoid unnecessary operations within fixtures.</p></li>
<li><p><strong>Optimize test code:</strong> Avoid redundant calculations or operations within your tests. Keep tests concise and focused on a single aspect of your code.</p></li>
<li><p><strong>Profiling:</strong> Use profiling tools to identify bottlenecks in your test suite. This allows you to focus optimization efforts where they will have the biggest impact.</p></li>
<li><p><strong>Avoid I/O-bound operations in tests if possible:</strong> I/O (network requests, database queries, file access) is often slow. When possible, use mocking to avoid these operations. For integration tests where this is not feasible, consider caching responses where appropriate.</p></li>
</ul>
<h2 id="appendix">Appendix</h2>
<h3 id="glossary-of-terms">Glossary of Terms</h3>
<ul>
<li><p><strong>Fixture:</strong> A function that provides resources (data, connections, temporary files, etc.) to your tests. Fixtures ensure consistent setup and teardown for tests.</p></li>
<li><p><strong>Marker:</strong> A tag applied to tests to categorize them or control their execution. Markers allow selective test running based on criteria.</p></li>
<li><p><strong>Assertion:</strong> A statement that checks whether a condition is true. Assertions are used to verify expected behavior in tests. Failures in assertions cause test failures.</p></li>
<li><p><strong>Test Double:</strong> A generic term for any substitute object used in testing (mock, stub, spy, fake). Test doubles isolate the code under test from external dependencies.</p></li>
<li><p><strong>Mock:</strong> A test double that simulates the behavior of a real object, allowing you to control its interactions and return values.</p></li>
<li><p><strong>Stub:</strong> A test double that provides canned answers to calls made during testing.</p></li>
<li><p><strong>Spy:</strong> A test double that records interactions (calls, arguments) made during testing.</p></li>
<li><p><strong>Fake:</strong> A simplified, working implementation of a real object used in testing.</p></li>
<li><p><strong>Test Coverage:</strong> A measure of how much of your codebase is executed by your tests. High test coverage increases confidence in the quality and correctness of the code.</p></li>
<li><p><strong>Autouse Fixture:</strong> A fixture automatically used by all tests in a given scope (module, class, etc.) without explicitly specifying it.</p></li>
</ul>
<h3 id="command-line-options-reference">Command-line Options Reference</h3>
<p>This is a partial list; refer to the official pytest documentation for a complete listing.</p>
<ul>
<li><p><code>pytest</code>: Runs pytest, discovering and executing tests.</p></li>
<li><p><code>pytest -v</code>: Runs pytest in verbose mode, showing more detailed output.</p></li>
<li><p><code>pytest -q</code>: Runs pytest in quiet mode, showing minimal output.</p></li>
<li><p><code>pytest -s</code>: Disables capturing of output from <code>print()</code> statements.</p></li>
<li><p><code>pytest -x</code>: Stops running tests after the first failure.</p></li>
<li><p><code>pytest -k &lt;expression&gt;</code>: Runs only tests matching the given expression (e.g., <code>-k "test_add"</code>).</p></li>
<li><p><code>pytest -m &lt;marker&gt;</code>: Runs only tests marked with the specified marker (e.g., <code>-m slow</code>).</p></li>
<li><p><code>pytest --pdb</code>: Starts the debugger when a test fails.</p></li>
<li><p><code>pytest --cov=&lt;package&gt;</code>: Runs pytest with code coverage measurement.</p></li>
</ul>
<h3 id="configuration-file-options">Configuration File Options</h3>
<p>pytest supports configuration through various files (typically <code>pytest.ini</code>, <code>tox.ini</code>, <code>setup.cfg</code>). These files allow customizing pytest behavior:</p>
<ul>
<li><p><code>[pytest]</code> section: Contains pytest-specific settings.</p></li>
<li><p><code>addopts</code>: Specifies additional command-line options to be used by default.</p></li>
<li><p><code>testpaths</code>: Specifies directories containing tests.</p></li>
<li><p><code>markers</code>: Defines custom markers to categorize tests.</p></li>
<li><p><code>python_files</code>: Specifies patterns for files containing tests (default is <code>test_*.py</code> and <code>*_test.py</code>).</p></li>
<li><p><code>python_classes</code>: Specifies patterns for test classes.</p></li>
<li><p><code>python_functions</code>: Specifies patterns for test functions.</p></li>
</ul>
<p>Refer to the official pytest documentation for a complete list of configuration options.</p>
<h3 id="further-reading-and-resources">Further Reading and Resources</h3>
<ul>
<li><p><strong>Official pytest documentation:</strong> The primary source for information on pytest. It contains comprehensive tutorials, API documentation, and guides.</p></li>
<li><p><strong>pytest plugin index:</strong> A listing of available pytest plugins, extending pytest functionality.</p></li>
<li><p><strong>pytest GitHub repository:</strong> The source code and issue tracker for pytest.</p></li>
<li><p><strong>Online tutorials and blog posts:</strong> Numerous online resources provide examples and explanations of pytest usage and best practices. Searching for “pytest tutorial” or “pytest best practices” will yield many helpful results.</p></li>
</ul>
<p>Remember to always refer to the official documentation for the most up-to-date and accurate information.</p>


<footer>Copyright 2025 - Muthukrishnan</footer>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561" crossorigin="anonymous"></script>




</body></html>