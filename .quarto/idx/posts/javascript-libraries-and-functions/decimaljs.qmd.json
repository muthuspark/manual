{"title":"Decimal.js - Documentation","markdown":{"yaml":{"title":"Decimal.js - Documentation","categories":["JavaScript Libraries and Functions"]},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n### What is Decimal.js?\n\nDecimal.js is a JavaScript library providing arbitrary-precision decimal arithmetic.  Unlike JavaScript's native `Number` type, which uses double-precision floating-point representation (IEEE 754), Decimal.js allows you to perform calculations with decimal numbers of any precision, avoiding the rounding errors and inaccuracies inherent in floating-point arithmetic. This is crucial for applications requiring exact decimal calculations, such as financial systems, accounting software, and scientific computations where precision is paramount.  It handles numbers as strings, ensuring accurate representation and manipulation of decimal values.\n\n\n### Why use Decimal.js?\n\nJavaScript's built-in `Number` type suffers from well-known limitations when dealing with decimal numbers.  Floating-point representation leads to rounding errors that can accumulate and produce incorrect results, particularly in calculations involving multiple operations or very small/large numbers.  Decimal.js overcomes these limitations by providing:\n\n* **Exact decimal representation:**  Numbers are represented internally with arbitrary precision, eliminating rounding errors.\n* **Consistent results:** Calculations always yield the mathematically correct result, within the specified precision.\n* **Improved accuracy:** Ideal for applications requiring absolute accuracy, preventing subtle bugs caused by floating-point inaccuracies.\n* **Control over precision:**  You can specify the desired precision for calculations, adapting to the specific needs of your application.\n* **Extended functionality:** Decimal.js offers a comprehensive set of arithmetic and mathematical functions, extending beyond basic operations.\n\n\n### Features and Benefits\n\n* **Arbitrary Precision:** Handle numbers with as many decimal places as needed.\n* **Rounding Modes:** Control how rounding is performed (e.g., round half up, round half even).\n* **Various Arithmetic Operations:**  Supports addition, subtraction, multiplication, division, modulo, exponentiation, and more.\n* **Comparison Functions:**  Provides methods for comparing decimal numbers (equals, greater than, less than, etc.).\n* **Mathematical Functions:** Includes functions like `sqrt`, `ln`, `log`, etc., with high precision.\n* **String Conversion:**  Handles input and output as strings, preventing floating-point representation issues.\n* **Error Handling:**  Provides mechanisms for handling potential errors during calculations (e.g., division by zero).\n* **Well-Tested and Documented:** Thoroughly tested and accompanied by comprehensive documentation.\n\n\n### Installation and Setup\n\nDecimal.js can be installed via npm or yarn:\n\n```bash\nnpm install decimal.js\n# or\nyarn add decimal.js\n```\n\nAfter installation, you can import and use it in your JavaScript code:\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Create Decimal objects\nlet a = new Decimal(1.23456789);\nlet b = new Decimal('0.0001');\n\n// Perform calculations\nlet sum = a.plus(b);\nlet product = a.times(b);\n\n// Output the results (results are Decimal objects)\nconsole.log(sum.toString()); // Output: 1.23466789\nconsole.log(product.toString()); // Output: 0.000123456789\n\n// Set precision globally\nDecimal.set({ precision: 10 }); //Optional global setting.\n\n//Alternatively, set precision for individual operations:\nlet result = new Decimal(1).dividedBy(3).toPrecision(3); // Output: 0.333 \n```\n\nFor browser usage without a module bundler, you can include the Decimal.js script directly in your HTML file.  Download the `decimal.min.js` file from the project's website and add a `<script>` tag to your HTML:\n\n```html\n<script src=\"decimal.min.js\"></script>\n<script>\n  // Use Decimal.js here,  Decimal is now a global object\n  let a = new Decimal(10);\n  console.log(a.toString());\n</script>\n```\nRemember to adjust the path to `decimal.min.js` as needed.  The global object approach is less preferred, as it can lead to conflicts with other libraries using the same name.\n\n\n## Basic Usage\n\n### Creating Decimal Objects\n\nDecimal objects are created using the `Decimal` constructor.  The constructor accepts various input types:\n\n* **Number:**  A JavaScript number. Note that precision might be lost due to inherent limitations of JavaScript numbers.\n* **String:** A string representation of a decimal number. This is generally the preferred method for maintaining precision.\n* **Array:** An array of integers representing the digits of the number.  Useful for advanced scenarios.\n* **Decimal:** Another Decimal object; creates a copy.\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Creating Decimal objects from different inputs\nconst a = new Decimal(123.456);            // From a Number\nconst b = new Decimal('78.90');          // From a String - Recommended for maximum precision\nconst c = new Decimal([1, 2, 3, 4, 5]);   // From an array of digits (represents 12345)\nconst d = new Decimal(a);                 // From another Decimal object (Creates a copy)\n\nconsole.log(a.toString(), b.toString(), c.toString(), d.toString());\n```\n\n### Arithmetic Operations (+, -, *, /)\n\nDecimal.js provides methods for all basic arithmetic operations.  These methods return new Decimal objects, leaving the original operands unchanged:\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('10.5');\nconst b = new Decimal('2.5');\n\nconst sum = a.plus(b);      // Addition\nconst difference = a.minus(b); // Subtraction\nconst product = a.times(b);    // Multiplication\nconst quotient = a.dividedBy(b); // Division\n\nconsole.log(sum.toString(), difference.toString(), product.toString(), quotient.toString()); //Output: 13 8 26.25 4.2\n```\n\nThese methods have chainable counterparts for improved readability (eg. `add`, `sub`, `mul`, `div`).  Note that division by zero will throw an error.\n\n\n### Comparison Operations (==, !=, >, <, >=, <=)\n\nDecimal.js offers methods for comparing Decimal objects.  These methods return boolean values:\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('10');\nconst b = new Decimal('10.00');\nconst c = new Decimal('11');\n\nconsole.log(a.equals(b)); // true - compares values, ignoring representation differences.\nconsole.log(a.equals(c)); // false\nconsole.log(a.greaterThan(c)); // false\nconsole.log(a.lessThan(c));  // true\nconsole.log(a.greaterThanOrEqualTo(b)); // true\nconsole.log(a.lessThanOrEqualTo(b));  // true\n\n//Inequality operators can also be used directly:\nconsole.log(a.comparedTo(b) === 0); // true, equivalent to a.equals(b)\nconsole.log(a.comparedTo(c) < 0);  // true, equivalent to a.lessThan(c)\n\n```\n\nThe `comparedTo` method returns -1 if the current Decimal object is less than the argument, 0 if equal, and 1 if greater than the argument.\n\n\n### Rounding Modes\n\nDecimal.js provides several rounding modes that control how results are rounded during calculations.  These modes are specified using the `rounding` property in the configuration object (see Precision and Configuration below) or as an argument to specific methods like `toDecimalPlaces`.\n\nThe available rounding modes are:\n\n* `Decimal.ROUND_UP`: Round away from zero.\n* `Decimal.ROUND_DOWN`: Round towards zero.\n* `Decimal.ROUND_CEIL`: Round towards positive infinity.\n* `Decimal.ROUND_FLOOR`: Round towards negative infinity.\n* `Decimal.ROUND_HALF_UP`: Round towards nearest neighbour. If equidistant, round away from zero.\n* `Decimal.ROUND_HALF_DOWN`: Round towards nearest neighbour. If equidistant, round towards zero.\n* `Decimal.ROUND_HALF_EVEN` (Banker's rounding): Round towards nearest neighbour. If equidistant, round towards the even neighbour.\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\nDecimal.set({ rounding: Decimal.ROUND_HALF_UP }); //Set global rounding mode\n\nlet num = new Decimal('2.5');\nconsole.log(num.toDecimalPlaces(0).toString()); // Output: 3\n\nDecimal.set({ rounding: Decimal.ROUND_HALF_EVEN }); //Set global rounding mode\nnum = new Decimal('2.5');\nconsole.log(num.toDecimalPlaces(0).toString()); // Output: 2\n\nnum = new Decimal('3.5');\nconsole.log(num.toDecimalPlaces(0).toString()); // Output: 4\n\n\n```\n\n\n### Precision and Configuration\n\nThe precision of Decimal.js calculations can be controlled globally using `Decimal.set()`, or individually for specific operations.\n\n* **Global Precision:** Sets the default precision for all subsequent calculations using `Decimal.set({ precision: value });`.   `value` represents the number of decimal places.\n\n* **Local Precision:** Methods like `toDecimalPlaces()` and `toPrecision()` allow you to specify the precision for individual operations.\n\n* **Rounding Mode:**  The rounding mode is also set using `Decimal.set({ rounding: mode })`, where `mode` is one of the rounding modes described above.\n\n* **Other Configurations:**  The `Decimal.set()` method also allows configuring other options, such as the cryptographically secure random number generator. Consult the official documentation for complete details.\n\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Set global precision to 5 decimal places\nDecimal.set({ precision: 5, rounding: Decimal.ROUND_HALF_UP });\n\nconst a = new Decimal('1.23456789');\nconsole.log(a.toString()); // Output: 1.23457 (Rounded due to global precision and rounding mode)\n\n// Local precision override:\nconsole.log(a.toDecimalPlaces(10).toString()); // Output: 1.2345678900 (Overrides global precision)\n\n//Changing global settings\nDecimal.set({ precision: 10});\nconsole.log(a.toString()); // Output: 1.2345678900\n\n```\n\n\n## Advanced Operations\n\n### Modulo Operation (%)\n\nThe modulo operation, represented by the `modulo` method (or its shorter alias `mod`), returns the remainder after division.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('10');\nconst b = new Decimal('3');\n\nconst remainder = a.modulo(b); // or a.mod(b)\nconsole.log(remainder.toString()); // Output: 1\n```\n\nThe result will always have the same sign as the divisor (`b` in this example).  Division by zero will throw an error.\n\n\n### Exponentiation (**)\n\nExponentiation is performed using the `pow` method.  The first argument is the base, and the second is the exponent.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst base = new Decimal('2');\nconst exponent = new Decimal('5');\n\nconst result = base.pow(exponent);\nconsole.log(result.toString()); // Output: 32\n\nconst negativeExponentResult = base.pow('-2');\nconsole.log(negativeExponentResult.toString()); //Output: 0.25\n```\n\nBoth base and exponent can be Decimal objects or numbers.  Note that fractional exponents will be subject to rounding based on configured precision.\n\n\n### Square Root (sqrt)\n\nThe square root is calculated using the `sqrt` method.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst num = new Decimal('16');\nconst root = num.sqrt();\nconsole.log(root.toString()); // Output: 4\n\nconst num2 = new Decimal('2');\nconst root2 = num2.sqrt();\nconsole.log(root2.toString()); // Output: 1.4142135623730951 (precision dependent)\n```\n\nThe `sqrt` method will throw an error if the input is negative.\n\n\n### Absolute Value (abs)\n\nThe absolute value of a Decimal object is obtained using the `abs` method.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('-10');\nconst b = new Decimal('5');\n\nconsole.log(a.abs().toString()); // Output: 10\nconsole.log(b.abs().toString()); // Output: 5\n```\n\n\n### Decimal to Number Conversion\n\nConverting a Decimal object to a JavaScript number is done using the `toNumber()` method.  Be aware that this conversion can lead to loss of precision due to the limitations of JavaScript's floating-point representation.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst d = new Decimal('123.456789');\nconst n = d.toNumber();\nconsole.log(n); // Output: 123.456789 (Might be slightly different due to floating point inaccuracies)\n```\n\n\n### Number to Decimal Conversion\n\nAs described in the Basic Usage section, a `Decimal` object can be created directly from a JavaScript number using the constructor. However, keep in mind that any inherent precision loss in the original JavaScript number will be carried over.  Using string representation is generally recommended for maximum accuracy when creating decimals from numbers.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst n = 123.456789;\nconst d = new Decimal(n);       //Potentially lossy conversion\nconst d2 = new Decimal(n.toString()); //Lossless conversion, preferred method if precision is important.\n\n\nconsole.log(d.toString(), d2.toString()); // Output: 123.456789  123.456789 (may differ slightly depending on JavaScript engine and number representation)\n\n```\nUsing `n.toString()` ensures the number is converted to a string before creating the `Decimal`, preventing potential inaccuracies.\n\n\n## Mathematical Functions\n\nDecimal.js provides several advanced mathematical functions that operate on Decimal objects.  These functions generally maintain the library's high precision, although results might be subject to minor rounding based on the configured precision.  Remember to always check the Decimal.js documentation for the most up-to-date information on function specifics and potential limitations.\n\n### Trigonometric Functions (sin, cos, tan)\n\nThese functions calculate the trigonometric values (sine, cosine, tangent) of an angle given in radians.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst angle = new Decimal(Math.PI / 4); // 45 degrees in radians\n\nconst sinValue = angle.sin();\nconst cosValue = angle.cos();\nconst tanValue = angle.tan();\n\nconsole.log(sinValue.toString()); // Output:  0.7071067811865476\nconsole.log(cosValue.toString()); // Output: 0.7071067811865476\nconsole.log(tanValue.toString()); // Output: 1\n```\n\nThe input angle should be a Decimal object.  The output is a new Decimal object representing the trigonometric value.\n\n\n### Inverse Trigonometric Functions (asin, acos, atan)\n\nThese functions compute the inverse trigonometric functions (arcsine, arccosine, arctangent), returning the angle in radians as a Decimal object.  The input should be a Decimal object within the valid range for each function (-1 to 1 for asin and acos, any value for atan).\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst value = new Decimal('0.7071067811865476');\n\nconst asinValue = value.asin();\nconst acosValue = value.acos();\nconst atanValue = value.atan();\n\n\nconsole.log(asinValue.toString()); // Output:  0.7853981633974483\nconsole.log(acosValue.toString()); // Output: 0.7853981633974483\nconsole.log(atanValue.toString()); // Output: 0.615479708629172\n\n```\n\nResults are also Decimal objects.  Note that the precision of the results depends on the library's internal calculations and configured precision.\n\n\n### Exponential and Logarithmic Functions (exp, ln, log)\n\n* `exp`: Calculates the exponential function (e raised to the power of the input).\n* `ln`:  Calculates the natural logarithm (base e).\n* `log`: Calculates the logarithm to a specified base (second argument).  If no base is specified, it defaults to base 10.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst num = new Decimal('2');\nconst base = new Decimal(10);\n\nconst expValue = num.exp();\nconst lnValue = num.ln();\nconst logBase10Value = num.log(base);  //Log base 10\nconst logBase2Value = num.log(2);    //Log base 2\n\n\nconsole.log(expValue.toString());     // Output: 7.38905609893065\nconsole.log(lnValue.toString());      // Output: 0.6931471805599453\nconsole.log(logBase10Value.toString()); // Output: 0.3010299956639812\nconsole.log(logBase2Value.toString()); // Output: 1\n\n```\n\nInput and output are Decimal objects.  Error handling for invalid inputs (e.g., ln of a non-positive number) should be considered.\n\n\n### Hyperbolic Functions\n\nDecimal.js provides hyperbolic functions: `sinh`, `cosh`, `tanh`, `asinh`, `acosh`, and `atanh`. These functions mirror their trigonometric counterparts but operate on hyperbolic curves.  Usage is analogous to the trigonometric functions described above, with input and output being Decimal objects.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst num = new Decimal(1);\n\nconsole.log(num.sinh().toString()); // Output: 1.1752011936438014\nconsole.log(num.cosh().toString()); // Output: 1.5430806348152437\nconsole.log(num.tanh().toString()); // Output: 0.7615941559557649\n\n\n```\n\nRemember to consult the official Decimal.js documentation for detailed information about the accuracy, range, and error handling of each function.  Note that the results of these calculations can be sensitive to the configured precision.  Higher precision settings will generally lead to more accurate results, but at the cost of increased computation time.\n\n\n## Comparison and Equality\n\n### Comparing Decimal Objects\n\nDecimal.js provides several methods for comparing Decimal objects.  The core method is `comparedTo`, which offers a numerical comparison:\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('10.5');\nconst b = new Decimal('10.500');\nconst c = new Decimal('11');\n\nconsole.log(a.comparedTo(b)); // Output: 0 (a and b are equal)\nconsole.log(a.comparedTo(c)); // Output: -1 (a is less than c)\nconsole.log(c.comparedTo(a)); // Output: 1 (c is greater than a)\n```\n\n`comparedTo` returns:\n\n* `0`: if the two numbers are equal.\n* `-1`: if the current Decimal is less than the argument.\n* `1`: if the current Decimal is greater than the argument.\n\nOther comparison methods offer a more convenient, boolean-based comparison:\n\n* `equals`: Checks for equality (ignores trailing zeros).\n* `greaterThan`, `lessThan`, `greaterThanOrEqualTo`, `lessThanOrEqualTo`:  These methods provide straightforward boolean comparisons.\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('10.5');\nconst b = new Decimal('10.500');\n\nconsole.log(a.equals(b));             // Output: true (equals ignores trailing zeros)\nconsole.log(a.greaterThan(b));        // Output: false\nconsole.log(a.lessThan(b));          // Output: false\nconsole.log(a.greaterThanOrEqualTo(b));// Output: true\nconsole.log(a.lessThanOrEqualTo(b));  // Output: true\n\n```\n\n\n### Testing for Equality\n\nWhen testing for equality, it's crucial to understand how Decimal.js handles trailing zeros. The `equals` method provides a robust solution.  It compares the numerical values, disregarding differences in the number of trailing zeros.\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('1.000');\nconst b = new Decimal('1');\n\nconsole.log(a.equals(b)); // Output: true (Decimal.js considers them equal)\nconsole.log(a.toString() === b.toString()); //Output: false (String comparison considers them different)\n\n```\n\nDirectly comparing using the `===` operator on Decimal objects is generally not recommended for equality checks; instead, use the `equals` method.\n\n\n### Handling Precision Differences\n\nDecimal.js's `equals` method inherently handles precision differences when comparing numerical values.  However, if you need to compare numbers based on a specific level of precision, you can use methods like `toDecimalPlaces` or `toPrecision` before comparison:\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('1.23456');\nconst b = new Decimal('1.23457');\nconst c = new Decimal('1.234567');\n\nconsole.log(a.equals(c)); // Output: false (different values)\n\n\n//Comparing to 4 decimal places\nconsole.log(a.toDecimalPlaces(4).equals(c.toDecimalPlaces(4))); // Output: true (equal when rounded to 4 decimal places)\n\n\n//Comparing using toPrecision:\nconsole.log(a.toPrecision(5).equals(b.toPrecision(5))); //Output: false (different when rounded to 5 significant digits)\nconsole.log(a.toPrecision(5).equals(c.toPrecision(5))); //Output: true (equal when rounded to 5 significant digits)\n\n\n```\n\nThis approach allows you to define the level of precision required for your equality checks.  Always consider the appropriate precision needed for the context of your application.\n\n\n## Error Handling\n\n### Common Errors and Exceptions\n\nDecimal.js throws exceptions in specific situations to indicate errors during calculations.  The most common errors include:\n\n* **Division by zero:** Attempting to divide a Decimal object by zero (`dividedBy(0)` or `/ 0`) will throw a `DivisionByZeroError`.\n\n* **Invalid input:** Providing invalid input to the Decimal constructor or methods (e.g., non-numeric strings) might throw a `TypeError` or a more specific error related to the invalid input.\n\n* **Overflow/Underflow:**  If the result of a calculation exceeds the maximum or minimum representable value (determined by the configured precision), an error might be thrown or the result might be clamped depending on the library's configuration. Note that with sufficient precision, overflow and underflow should be unlikely.\n\n* **Invalid rounding mode:** Specifying an invalid rounding mode when configuring Decimal.js may throw an error.\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\ntry {\n  const result = new Decimal(10).dividedBy(0);\n  console.log(result);\n} catch (e) {\n  console.error(\"Error:\", e.message); // Output: Error: Division by zero\n}\n\ntry {\n  const invalidDecimal = new Decimal('abc');\n  console.log(invalidDecimal);\n} catch (e) {\n  console.error(\"Error:\", e.message); //Output will vary depending on the Decimal.js version and browser\n}\n\n```\n\nAlways wrap potentially error-prone Decimal.js operations within `try...catch` blocks to handle exceptions gracefully.\n\n\n### Debugging Techniques\n\nDebugging Decimal.js code often involves careful examination of inputs and outputs. Key debugging techniques include:\n\n* **Console Logging:**  Use `console.log` to print the values of Decimal objects at different stages of your calculations.  Pay close attention to the string representations of the Decimal objects (`toString()`) to ensure they reflect the expected values and precision.\n\n* **Inspecting Intermediate Results:** Break down complex calculations into smaller, more manageable steps.  Log the intermediate results to identify where errors might be occurring.\n\n* **Using a Debugger:** Utilize your browser's developer tools or a dedicated debugger to step through your code, inspect variables, and understand the flow of execution.  This is particularly helpful when dealing with nested calculations or complex logic.\n\n* **Testing with Known Values:** Create unit tests with known inputs and expected outputs to verify the accuracy of your Decimal.js calculations.  This helps identify unexpected behavior or inaccuracies.\n\n* **Checking Precision:**  Ensure that the configured precision is adequate for your application's needs.  Insufficient precision can lead to rounding errors that might not be immediately apparent.\n\n\n### Best Practices for Error Prevention\n\nTo prevent errors and ensure accuracy:\n\n* **Use String Inputs:**  Whenever possible, provide Decimal.js with string representations of numbers.  This avoids potential floating-point inaccuracies during parsing.\n\n* **Check Inputs:**  Validate inputs before passing them to Decimal.js methods.  This includes checking for null, undefined, or non-numeric values.\n\n* **Handle Exceptions:**  Always wrap Decimal.js operations in `try...catch` blocks to handle potential exceptions.\n\n* **Set Appropriate Precision:** Configure the precision of Decimal.js to meet the accuracy requirements of your application.  Higher precision improves accuracy but may affect performance.\n\n* **Modular Code:** Break down complex calculations into smaller, well-defined functions to improve readability, testability, and maintainability.\n\n* **Unit Testing:**  Write comprehensive unit tests to validate your Decimal.js code.  This helps detect errors early and ensures accuracy over time.\n\n* **Consult Documentation:** Familiarize yourself with the Decimal.js documentation to understand the functions, their limitations, and potential error scenarios.\n\nBy adhering to these best practices, you can significantly reduce errors and build robust applications using Decimal.js.\n\n\n## Performance Considerations\n\nDecimal.js provides accurate decimal arithmetic, but its operations are generally slower than native JavaScript `Number` operations due to the overhead of arbitrary-precision calculations.  Understanding performance considerations is crucial for building efficient applications.\n\n\n### Optimizing Decimal Operations\n\nSeveral strategies can help optimize Decimal.js operations:\n\n* **Minimize Object Creation:** Creating Decimal objects repeatedly can impact performance.  Reuse existing Decimal objects whenever possible, especially within loops.\n\n* **Avoid Unnecessary Operations:** Carefully review your calculations to eliminate redundant or unnecessary operations.\n\n* **Batch Operations:** If possible, group multiple operations into a single sequence rather than performing them individually. Some operations, like chained additions or multiplications, can be optimized internally.\n\n* **Use efficient methods:** Utilize the most efficient method for the task. For instance, `add` and `plus` do the same operation, but direct use of `add` might offer a slight performance advantage in some contexts. Check the documentation for nuanced differences.\n\n* **Pre-allocate memory:** In scenarios involving large arrays or collections of decimals, consider pre-allocating arrays to avoid repeated dynamic memory allocations.  This is especially relevant for large-scale computations.\n\n\n* **Leverage efficient data structures:** Using appropriate data structures for large datasets (like typed arrays, if applicable) might help minimize memory overhead and potentially improve performance.\n\n* **Consider alternative libraries:** If performance is exceptionally critical and the precision requirements are not overly stringent, consider exploring other libraries offering faster decimal arithmetic (although usually with trade-offs in precision).\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Inefficient (repeated object creation)\nlet sum = new Decimal(0);\nfor (let i = 0; i < 100000; i++) {\n  sum = sum.plus(new Decimal(i));\n}\n\n// More efficient (reusing object)\nlet efficientSum = new Decimal(0);\nfor (let i = 0; i < 100000; i++) {\n  efficientSum.add(i); //Using add directly\n}\n\n```\n\nThe second example is more efficient as it avoids repeatedly creating new Decimal objects.\n\n\n### Benchmarking and Tuning\n\nTo measure and tune the performance of your Decimal.js code:\n\n* **Use Benchmarking Tools:** Employ benchmarking libraries like `benchmark.js` to measure the execution time of different code sections and compare optimization strategies.\n\n* **Profile Your Code:** Utilize browser profiling tools to identify performance bottlenecks within your Decimal.js code.\n\n* **Iterative Optimization:**  Apply optimizations iteratively, measuring the performance impact of each change using benchmarking tools. This ensures you are focusing on the most significant performance improvements.\n\n* **Analyze Results:** Carefully analyze benchmarking results to understand the trade-offs between different optimization techniques.\n\n\n### Strategies for Large-Scale Computations\n\nFor large-scale computations with Decimal.js:\n\n* **Parallel Processing:** Consider using Web Workers to perform calculations in parallel, improving performance, especially on multi-core processors.\n\n* **Asynchronous Operations:**  For tasks that do not require immediate results, use asynchronous operations to prevent blocking the main thread.\n\n* **Data Chunking:**  Break down large datasets into smaller chunks to process them in batches. This can improve memory management and avoid excessive memory allocation.\n\n* **Specialized Algorithms:** If applicable, explore specialized algorithms designed for high-precision calculations that might offer better performance than naive implementations.\n\n* **Caching:** If calculations involve repeated operations on the same data, caching intermediate results can significantly reduce computational time.\n\nRemember that the choice of optimization strategies will depend heavily on the specific nature of your large-scale computation and the acceptable level of performance trade-offs.  Profiling and benchmarking are essential for identifying the most effective optimizations.\n\n\n## API Reference\n\nThis section provides a comprehensive reference to the Decimal.js API. Due to the extensive nature of the API, providing a completely detailed explanation of *every* method and property within this response is impractical.  This overview will cover the key aspects and provide examples, encouraging you to consult the official Decimal.js documentation for the most complete and up-to-date information.\n\n\n### Constructor and Methods\n\nThe core of Decimal.js is its constructor, `Decimal()`, and its numerous methods.  The constructor creates a new Decimal object:\n\n```javascript\nconst myDecimal = new Decimal('123.45');\n```\n\nNumerous methods are available for arithmetic operations (`plus`, `minus`, `times`, `dividedBy`, `modulo`), comparison (`equals`, `greaterThan`, `lessThan`, etc.), mathematical functions (`sin`, `cos`, `sqrt`, `ln`, etc.), rounding and formatting (`toDecimalPlaces`, `toPrecision`, `toFixed`, `toString`), and more.  These methods are chainable for improved readability and conciseness:\n\n```javascript\nconst result = new Decimal('10').plus(5).times(2).toDecimalPlaces(2);\n```\n\n### Properties and Attributes\n\nDecimal.js offers several properties, primarily for configuration and accessing internal information.  Note that directly manipulating internal properties is generally discouraged and should be avoided unless you have a deep understanding of the library's internal workings.  Key properties include:\n\n* `Decimal.precision`:  Gets or sets the global precision.\n* `Decimal.rounding`: Gets or sets the global rounding mode.\n* `Decimal.crypto`:  Gets or sets whether to use a cryptographically secure random number generator.\n\n\nThese properties are typically managed using the `Decimal.set()` method for configuration:\n\n```javascript\nDecimal.set({ precision: 10, rounding: Decimal.ROUND_HALF_UP });\n```\n\n\n### Detailed Explanation of Each Method\n\nA comprehensive explanation of *every* method would be too extensive for this context.  The official Decimal.js documentation is the definitive source for detailed explanations.  However, we can briefly touch on some key method categories:\n\n* **Arithmetic:** `plus`, `minus`, `times`, `dividedBy`, `modulo`, `pow` (exponentiation).  These methods perform standard arithmetic operations with high precision.\n\n* **Comparison:** `equals`, `comparedTo`, `greaterThan`, `lessThan`, `greaterThanOrEqualTo`, `lessThanOrEqualTo`. These methods facilitate comparing Decimal objects.\n\n* **Mathematical:** `sin`, `cos`, `tan`, `asin`, `acos`, `atan`, `exp`, `ln`, `log`, `sqrt`, `abs`, and hyperbolic functions.  These provide advanced mathematical capabilities.\n\n* **Rounding & Formatting:** `toDecimalPlaces`, `toPrecision`, `toFixed`, `toString`.  These control how the Decimal object is represented.  Different rounding modes are available (`ROUND_UP`, `ROUND_DOWN`, `ROUND_HALF_UP`, `ROUND_HALF_EVEN`, etc.) and should be chosen appropriately.\n\n* **Other Utility Methods:** Decimal.js offers other helpful methods like `isFinite`, `isNaN`, `isZero`, and several utility functions.\n\n\n### Examples of Each Method\n\nProviding an example for every method would be excessively long. Instead, let's illustrate a few important ones:\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Arithmetic\nconst sum = new Decimal('2.5').plus('3.7');         //Addition - Output: 6.2\nconst diff = new Decimal(10).minus(3);             //Subtraction - Output: 7\nconst prod = new Decimal(4).times(5);               //Multiplication - Output: 20\nconst div = new Decimal(10).dividedBy(3);           //Division - Output: 3.3333333333333335 (Precision Dependent)\nconst mod = new Decimal(17).modulo(5);              //Modulo - Output: 2\nconst pow = new Decimal(2).pow(3);                   //Power - Output: 8\n\n\n//Comparison\nconst isEqual = new Decimal('1.00').equals('1');    //Equality - Output: true\nconst greater = new Decimal(5).greaterThan(3);      //GreaterThan - Output: true\n\n//Rounding and Formatting\nconst rounded = new Decimal('12.3456').toDecimalPlaces(2); //Output: 12.35\nconst precise = new Decimal('1234567').toPrecision(3);   //Output: 1.23e+6\nconst formatted = new Decimal('12.34').toFixed(1);      //Output: 12.3\n\n//Mathematical function\nconst sqrtResult = new Decimal(16).sqrt();             //Output: 4\nconst lnResult = new Decimal(Math.E).ln();            //Output: 1\n```\n\nRefer to the official Decimal.js documentation for exhaustive method listings, detailed explanations, and further examples.  Remember to install the library (`npm install decimal.js`) before running these code snippets.\n\n\n\n## Examples and Use Cases\n\nDecimal.js excels in scenarios where precise decimal arithmetic is crucial, avoiding the pitfalls of JavaScript's native floating-point numbers. Here are some compelling use cases:\n\n\n### Financial Calculations\n\nFinancial applications demand utmost accuracy.  Even small rounding errors can accumulate and lead to significant discrepancies in balances, interest calculations, or currency conversions. Decimal.js provides a robust solution:\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Calculating compound interest\nconst principal = new Decimal('1000');\nconst rate = new Decimal('0.05'); // 5% interest rate\nconst years = new Decimal('5');\nconst interest = principal.times(rate.times(years));\n\nconst totalAmount = principal.plus(interest);\nconsole.log(\"Total amount after 5 years:\", totalAmount.toFixed(2)); //Output: 1250.00\n\n//Currency Conversion with precise exchange rates.\nconst amountInUSD = new Decimal('100');\nconst exchangeRate = new Decimal('0.85'); //USD to EUR\nconst amountInEUR = amountInUSD.times(exchangeRate);\nconsole.log(\"Amount in EUR:\", amountInEUR.toFixed(2)); //Output: 85.00\n\n```\n\nThis example demonstrates how Decimal.js ensures precise interest calculations and currency conversions, preventing accumulated rounding errors.\n\n\n### Scientific Computations\n\nScientific computations frequently involve very small or very large numbers, where the limitations of floating-point arithmetic become apparent. Decimal.js enables accurate results even with extreme values:\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Calculating Avogadro's number multiplied by a small factor:\nconst avogadro = new Decimal('6.02214076e+23'); // Avogadro's number\nconst smallFactor = new Decimal('1e-10');\nconst result = avogadro.times(smallFactor);\nconsole.log(\"Result:\", result.toString()); //Output will be precise\n\n// Handling very small numbers in calculations involving exponents\nconst smallNumber = new Decimal('1e-20');\nconst exponent = new Decimal(10);\nconst poweredResult = smallNumber.pow(exponent);\nconsole.log(\"Powered result:\", poweredResult.toString()); //Output will maintain precision\n\n```\n\nIn this example, Decimal.js precisely handles Avogadro's number and a small factor without losing significant figures, a common issue with native floating point numbers.\n\n\n### Cryptocurrency Applications\n\nCryptocurrency transactions involve precise amounts of digital assets.  Decimal.js is invaluable for accurate calculations of balances, transaction fees, and exchanges:\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Calculating transaction fees:\nconst transactionAmount = new Decimal('1.23456789'); //BTC\nconst feeRate = new Decimal('0.001'); // 0.1% fee\nconst transactionFee = transactionAmount.times(feeRate);\nconsole.log(\"Transaction fee:\", transactionFee.toFixed(8)); //Output will be precise to 8 decimal places\n\n\n//Exchange calculations using precise exchange rate\nconst btcAmount = new Decimal('0.1');\nconst ethExchangeRate = new Decimal('1600'); //BTC to ETH\nconst ethAmount = btcAmount.times(ethExchangeRate);\nconsole.log(\"ETH amount:\", ethAmount.toString()); //Output maintains precision\n\n\n```\n\nThis example showcases how to accurately calculate transaction fees and handle cryptocurrency exchanges using Decimal.js, preserving the necessary level of precision for cryptocurrency transactions.\n\n\n### Data Analysis\n\nData analysis frequently involves calculations with decimal numbers, especially when dealing with financial, statistical, or scientific data.  Maintaining accuracy is crucial for reliable results:\n\n```javascript\nimport Decimal from 'decimal.js';\n\n//Calculating the average of a set of decimal values:\nconst values = [new Decimal('1.2'), new Decimal('2.5'), new Decimal('3.7'), new Decimal('4.1')];\nlet sum = new Decimal(0);\nfor (const val of values) {\n    sum = sum.plus(val);\n}\nconst average = sum.dividedBy(values.length);\nconsole.log(\"Average:\", average.toFixed(2)); //Output: 2.88\n\n\n//Calculating Standard Deviation of a set of decimal values:  (requires additional helper functions beyond the scope of this example, but Decimal.js would be essential for accurate intermediate calculations)\n\n```\n\nDecimal.js ensures that aggregations like averages and statistical computations are performed with high accuracy, yielding reliable analytical results.  While the standard deviation example is not fully elaborated here for brevity, it highlights the usefulness of the library in more complex data analysis tasks.  You would use Decimal.js for precise calculations within the standard deviation formula.\n\n\n## Contributing to Decimal.js\n\nContributions to Decimal.js are welcome!  This section outlines the process for contributing to the project.\n\n### Development Setup\n\n1. **Fork the Repository:** Fork the official Decimal.js repository on GitHub to your personal account.\n\n2. **Clone Your Fork:** Clone your forked repository to your local machine:\n\n   ```bash\n   git clone git@github.com:<your-username>/decimal.js.git\n   cd decimal.js\n   ```\n\n3. **Install Dependencies:** Install the necessary dependencies using npm or yarn:\n\n   ```bash\n   npm install\n   # or\n   yarn install\n   ```\n\n4. **Set up Testing:**  Decimal.js uses a comprehensive test suite.  Ensure the tests run correctly before making any changes. Run the tests using:\n\n   ```bash\n   npm test\n   # or\n   yarn test\n   ```\n\n### Coding Standards\n\nDecimal.js follows specific coding standards to ensure consistency and readability.  Key aspects include:\n\n* **Consistent Indentation:** Use two spaces for indentation.\n\n* **Meaningful Variable Names:** Use descriptive variable names that clearly indicate their purpose.\n\n* **Comments:**  Add clear and concise comments to explain complex logic or non-obvious code sections.\n\n* **Code Style:** Adhere to a consistent coding style (the existing codebase serves as a good guide).\n\n* **ES6+ Features:** Use modern JavaScript features (ES6+ and beyond where appropriate).\n\nBefore submitting a pull request, ensure your code conforms to these standards.  You can use linters like ESLint to help enforce the style guide automatically.\n\n\n### Testing and Quality Assurance\n\nDecimal.js has a thorough test suite.  Before submitting any changes, ensure that all existing tests pass and that you've added new tests to cover your changes.  Thorough testing is essential to maintain the library's accuracy and reliability.  The test suite uses tools like Jasmine and Karma.  Familiarize yourself with the testing process to effectively contribute.\n\n\n### Submitting Pull Requests\n\n1. **Create a Branch:** Create a new branch for your changes from the `main` or `master` branch (depending on the repository's main branch):\n\n   ```bash\n   git checkout -b <your-branch-name>\n   ```\n\n2. **Make Your Changes:** Implement your changes, adhering to the coding standards and adding comprehensive tests.\n\n3. **Commit Your Changes:** Commit your changes with clear and concise commit messages:\n\n   ```bash\n   git add .\n   git commit -m \"Your descriptive commit message\"\n   ```\n\n4. **Push Your Branch:** Push your branch to your forked repository:\n\n   ```bash\n   git push origin <your-branch-name>\n   ```\n\n5. **Open a Pull Request:** On GitHub, open a pull request from your branch to the main branch of the official Decimal.js repository. Provide a clear description of your changes and address any feedback from the maintainers.\n\nRemember to follow the contribution guidelines provided in the official Decimal.js repository.  The maintainers will review your pull request and provide feedback.  Be prepared to address any comments or suggested improvements before your contribution is merged.\n\n","srcMarkdownNoYaml":"\n## Introduction\n\n### What is Decimal.js?\n\nDecimal.js is a JavaScript library providing arbitrary-precision decimal arithmetic.  Unlike JavaScript's native `Number` type, which uses double-precision floating-point representation (IEEE 754), Decimal.js allows you to perform calculations with decimal numbers of any precision, avoiding the rounding errors and inaccuracies inherent in floating-point arithmetic. This is crucial for applications requiring exact decimal calculations, such as financial systems, accounting software, and scientific computations where precision is paramount.  It handles numbers as strings, ensuring accurate representation and manipulation of decimal values.\n\n\n### Why use Decimal.js?\n\nJavaScript's built-in `Number` type suffers from well-known limitations when dealing with decimal numbers.  Floating-point representation leads to rounding errors that can accumulate and produce incorrect results, particularly in calculations involving multiple operations or very small/large numbers.  Decimal.js overcomes these limitations by providing:\n\n* **Exact decimal representation:**  Numbers are represented internally with arbitrary precision, eliminating rounding errors.\n* **Consistent results:** Calculations always yield the mathematically correct result, within the specified precision.\n* **Improved accuracy:** Ideal for applications requiring absolute accuracy, preventing subtle bugs caused by floating-point inaccuracies.\n* **Control over precision:**  You can specify the desired precision for calculations, adapting to the specific needs of your application.\n* **Extended functionality:** Decimal.js offers a comprehensive set of arithmetic and mathematical functions, extending beyond basic operations.\n\n\n### Features and Benefits\n\n* **Arbitrary Precision:** Handle numbers with as many decimal places as needed.\n* **Rounding Modes:** Control how rounding is performed (e.g., round half up, round half even).\n* **Various Arithmetic Operations:**  Supports addition, subtraction, multiplication, division, modulo, exponentiation, and more.\n* **Comparison Functions:**  Provides methods for comparing decimal numbers (equals, greater than, less than, etc.).\n* **Mathematical Functions:** Includes functions like `sqrt`, `ln`, `log`, etc., with high precision.\n* **String Conversion:**  Handles input and output as strings, preventing floating-point representation issues.\n* **Error Handling:**  Provides mechanisms for handling potential errors during calculations (e.g., division by zero).\n* **Well-Tested and Documented:** Thoroughly tested and accompanied by comprehensive documentation.\n\n\n### Installation and Setup\n\nDecimal.js can be installed via npm or yarn:\n\n```bash\nnpm install decimal.js\n# or\nyarn add decimal.js\n```\n\nAfter installation, you can import and use it in your JavaScript code:\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Create Decimal objects\nlet a = new Decimal(1.23456789);\nlet b = new Decimal('0.0001');\n\n// Perform calculations\nlet sum = a.plus(b);\nlet product = a.times(b);\n\n// Output the results (results are Decimal objects)\nconsole.log(sum.toString()); // Output: 1.23466789\nconsole.log(product.toString()); // Output: 0.000123456789\n\n// Set precision globally\nDecimal.set({ precision: 10 }); //Optional global setting.\n\n//Alternatively, set precision for individual operations:\nlet result = new Decimal(1).dividedBy(3).toPrecision(3); // Output: 0.333 \n```\n\nFor browser usage without a module bundler, you can include the Decimal.js script directly in your HTML file.  Download the `decimal.min.js` file from the project's website and add a `<script>` tag to your HTML:\n\n```html\n<script src=\"decimal.min.js\"></script>\n<script>\n  // Use Decimal.js here,  Decimal is now a global object\n  let a = new Decimal(10);\n  console.log(a.toString());\n</script>\n```\nRemember to adjust the path to `decimal.min.js` as needed.  The global object approach is less preferred, as it can lead to conflicts with other libraries using the same name.\n\n\n## Basic Usage\n\n### Creating Decimal Objects\n\nDecimal objects are created using the `Decimal` constructor.  The constructor accepts various input types:\n\n* **Number:**  A JavaScript number. Note that precision might be lost due to inherent limitations of JavaScript numbers.\n* **String:** A string representation of a decimal number. This is generally the preferred method for maintaining precision.\n* **Array:** An array of integers representing the digits of the number.  Useful for advanced scenarios.\n* **Decimal:** Another Decimal object; creates a copy.\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Creating Decimal objects from different inputs\nconst a = new Decimal(123.456);            // From a Number\nconst b = new Decimal('78.90');          // From a String - Recommended for maximum precision\nconst c = new Decimal([1, 2, 3, 4, 5]);   // From an array of digits (represents 12345)\nconst d = new Decimal(a);                 // From another Decimal object (Creates a copy)\n\nconsole.log(a.toString(), b.toString(), c.toString(), d.toString());\n```\n\n### Arithmetic Operations (+, -, *, /)\n\nDecimal.js provides methods for all basic arithmetic operations.  These methods return new Decimal objects, leaving the original operands unchanged:\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('10.5');\nconst b = new Decimal('2.5');\n\nconst sum = a.plus(b);      // Addition\nconst difference = a.minus(b); // Subtraction\nconst product = a.times(b);    // Multiplication\nconst quotient = a.dividedBy(b); // Division\n\nconsole.log(sum.toString(), difference.toString(), product.toString(), quotient.toString()); //Output: 13 8 26.25 4.2\n```\n\nThese methods have chainable counterparts for improved readability (eg. `add`, `sub`, `mul`, `div`).  Note that division by zero will throw an error.\n\n\n### Comparison Operations (==, !=, >, <, >=, <=)\n\nDecimal.js offers methods for comparing Decimal objects.  These methods return boolean values:\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('10');\nconst b = new Decimal('10.00');\nconst c = new Decimal('11');\n\nconsole.log(a.equals(b)); // true - compares values, ignoring representation differences.\nconsole.log(a.equals(c)); // false\nconsole.log(a.greaterThan(c)); // false\nconsole.log(a.lessThan(c));  // true\nconsole.log(a.greaterThanOrEqualTo(b)); // true\nconsole.log(a.lessThanOrEqualTo(b));  // true\n\n//Inequality operators can also be used directly:\nconsole.log(a.comparedTo(b) === 0); // true, equivalent to a.equals(b)\nconsole.log(a.comparedTo(c) < 0);  // true, equivalent to a.lessThan(c)\n\n```\n\nThe `comparedTo` method returns -1 if the current Decimal object is less than the argument, 0 if equal, and 1 if greater than the argument.\n\n\n### Rounding Modes\n\nDecimal.js provides several rounding modes that control how results are rounded during calculations.  These modes are specified using the `rounding` property in the configuration object (see Precision and Configuration below) or as an argument to specific methods like `toDecimalPlaces`.\n\nThe available rounding modes are:\n\n* `Decimal.ROUND_UP`: Round away from zero.\n* `Decimal.ROUND_DOWN`: Round towards zero.\n* `Decimal.ROUND_CEIL`: Round towards positive infinity.\n* `Decimal.ROUND_FLOOR`: Round towards negative infinity.\n* `Decimal.ROUND_HALF_UP`: Round towards nearest neighbour. If equidistant, round away from zero.\n* `Decimal.ROUND_HALF_DOWN`: Round towards nearest neighbour. If equidistant, round towards zero.\n* `Decimal.ROUND_HALF_EVEN` (Banker's rounding): Round towards nearest neighbour. If equidistant, round towards the even neighbour.\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\nDecimal.set({ rounding: Decimal.ROUND_HALF_UP }); //Set global rounding mode\n\nlet num = new Decimal('2.5');\nconsole.log(num.toDecimalPlaces(0).toString()); // Output: 3\n\nDecimal.set({ rounding: Decimal.ROUND_HALF_EVEN }); //Set global rounding mode\nnum = new Decimal('2.5');\nconsole.log(num.toDecimalPlaces(0).toString()); // Output: 2\n\nnum = new Decimal('3.5');\nconsole.log(num.toDecimalPlaces(0).toString()); // Output: 4\n\n\n```\n\n\n### Precision and Configuration\n\nThe precision of Decimal.js calculations can be controlled globally using `Decimal.set()`, or individually for specific operations.\n\n* **Global Precision:** Sets the default precision for all subsequent calculations using `Decimal.set({ precision: value });`.   `value` represents the number of decimal places.\n\n* **Local Precision:** Methods like `toDecimalPlaces()` and `toPrecision()` allow you to specify the precision for individual operations.\n\n* **Rounding Mode:**  The rounding mode is also set using `Decimal.set({ rounding: mode })`, where `mode` is one of the rounding modes described above.\n\n* **Other Configurations:**  The `Decimal.set()` method also allows configuring other options, such as the cryptographically secure random number generator. Consult the official documentation for complete details.\n\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Set global precision to 5 decimal places\nDecimal.set({ precision: 5, rounding: Decimal.ROUND_HALF_UP });\n\nconst a = new Decimal('1.23456789');\nconsole.log(a.toString()); // Output: 1.23457 (Rounded due to global precision and rounding mode)\n\n// Local precision override:\nconsole.log(a.toDecimalPlaces(10).toString()); // Output: 1.2345678900 (Overrides global precision)\n\n//Changing global settings\nDecimal.set({ precision: 10});\nconsole.log(a.toString()); // Output: 1.2345678900\n\n```\n\n\n## Advanced Operations\n\n### Modulo Operation (%)\n\nThe modulo operation, represented by the `modulo` method (or its shorter alias `mod`), returns the remainder after division.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('10');\nconst b = new Decimal('3');\n\nconst remainder = a.modulo(b); // or a.mod(b)\nconsole.log(remainder.toString()); // Output: 1\n```\n\nThe result will always have the same sign as the divisor (`b` in this example).  Division by zero will throw an error.\n\n\n### Exponentiation (**)\n\nExponentiation is performed using the `pow` method.  The first argument is the base, and the second is the exponent.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst base = new Decimal('2');\nconst exponent = new Decimal('5');\n\nconst result = base.pow(exponent);\nconsole.log(result.toString()); // Output: 32\n\nconst negativeExponentResult = base.pow('-2');\nconsole.log(negativeExponentResult.toString()); //Output: 0.25\n```\n\nBoth base and exponent can be Decimal objects or numbers.  Note that fractional exponents will be subject to rounding based on configured precision.\n\n\n### Square Root (sqrt)\n\nThe square root is calculated using the `sqrt` method.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst num = new Decimal('16');\nconst root = num.sqrt();\nconsole.log(root.toString()); // Output: 4\n\nconst num2 = new Decimal('2');\nconst root2 = num2.sqrt();\nconsole.log(root2.toString()); // Output: 1.4142135623730951 (precision dependent)\n```\n\nThe `sqrt` method will throw an error if the input is negative.\n\n\n### Absolute Value (abs)\n\nThe absolute value of a Decimal object is obtained using the `abs` method.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('-10');\nconst b = new Decimal('5');\n\nconsole.log(a.abs().toString()); // Output: 10\nconsole.log(b.abs().toString()); // Output: 5\n```\n\n\n### Decimal to Number Conversion\n\nConverting a Decimal object to a JavaScript number is done using the `toNumber()` method.  Be aware that this conversion can lead to loss of precision due to the limitations of JavaScript's floating-point representation.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst d = new Decimal('123.456789');\nconst n = d.toNumber();\nconsole.log(n); // Output: 123.456789 (Might be slightly different due to floating point inaccuracies)\n```\n\n\n### Number to Decimal Conversion\n\nAs described in the Basic Usage section, a `Decimal` object can be created directly from a JavaScript number using the constructor. However, keep in mind that any inherent precision loss in the original JavaScript number will be carried over.  Using string representation is generally recommended for maximum accuracy when creating decimals from numbers.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst n = 123.456789;\nconst d = new Decimal(n);       //Potentially lossy conversion\nconst d2 = new Decimal(n.toString()); //Lossless conversion, preferred method if precision is important.\n\n\nconsole.log(d.toString(), d2.toString()); // Output: 123.456789  123.456789 (may differ slightly depending on JavaScript engine and number representation)\n\n```\nUsing `n.toString()` ensures the number is converted to a string before creating the `Decimal`, preventing potential inaccuracies.\n\n\n## Mathematical Functions\n\nDecimal.js provides several advanced mathematical functions that operate on Decimal objects.  These functions generally maintain the library's high precision, although results might be subject to minor rounding based on the configured precision.  Remember to always check the Decimal.js documentation for the most up-to-date information on function specifics and potential limitations.\n\n### Trigonometric Functions (sin, cos, tan)\n\nThese functions calculate the trigonometric values (sine, cosine, tangent) of an angle given in radians.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst angle = new Decimal(Math.PI / 4); // 45 degrees in radians\n\nconst sinValue = angle.sin();\nconst cosValue = angle.cos();\nconst tanValue = angle.tan();\n\nconsole.log(sinValue.toString()); // Output:  0.7071067811865476\nconsole.log(cosValue.toString()); // Output: 0.7071067811865476\nconsole.log(tanValue.toString()); // Output: 1\n```\n\nThe input angle should be a Decimal object.  The output is a new Decimal object representing the trigonometric value.\n\n\n### Inverse Trigonometric Functions (asin, acos, atan)\n\nThese functions compute the inverse trigonometric functions (arcsine, arccosine, arctangent), returning the angle in radians as a Decimal object.  The input should be a Decimal object within the valid range for each function (-1 to 1 for asin and acos, any value for atan).\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst value = new Decimal('0.7071067811865476');\n\nconst asinValue = value.asin();\nconst acosValue = value.acos();\nconst atanValue = value.atan();\n\n\nconsole.log(asinValue.toString()); // Output:  0.7853981633974483\nconsole.log(acosValue.toString()); // Output: 0.7853981633974483\nconsole.log(atanValue.toString()); // Output: 0.615479708629172\n\n```\n\nResults are also Decimal objects.  Note that the precision of the results depends on the library's internal calculations and configured precision.\n\n\n### Exponential and Logarithmic Functions (exp, ln, log)\n\n* `exp`: Calculates the exponential function (e raised to the power of the input).\n* `ln`:  Calculates the natural logarithm (base e).\n* `log`: Calculates the logarithm to a specified base (second argument).  If no base is specified, it defaults to base 10.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst num = new Decimal('2');\nconst base = new Decimal(10);\n\nconst expValue = num.exp();\nconst lnValue = num.ln();\nconst logBase10Value = num.log(base);  //Log base 10\nconst logBase2Value = num.log(2);    //Log base 2\n\n\nconsole.log(expValue.toString());     // Output: 7.38905609893065\nconsole.log(lnValue.toString());      // Output: 0.6931471805599453\nconsole.log(logBase10Value.toString()); // Output: 0.3010299956639812\nconsole.log(logBase2Value.toString()); // Output: 1\n\n```\n\nInput and output are Decimal objects.  Error handling for invalid inputs (e.g., ln of a non-positive number) should be considered.\n\n\n### Hyperbolic Functions\n\nDecimal.js provides hyperbolic functions: `sinh`, `cosh`, `tanh`, `asinh`, `acosh`, and `atanh`. These functions mirror their trigonometric counterparts but operate on hyperbolic curves.  Usage is analogous to the trigonometric functions described above, with input and output being Decimal objects.\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst num = new Decimal(1);\n\nconsole.log(num.sinh().toString()); // Output: 1.1752011936438014\nconsole.log(num.cosh().toString()); // Output: 1.5430806348152437\nconsole.log(num.tanh().toString()); // Output: 0.7615941559557649\n\n\n```\n\nRemember to consult the official Decimal.js documentation for detailed information about the accuracy, range, and error handling of each function.  Note that the results of these calculations can be sensitive to the configured precision.  Higher precision settings will generally lead to more accurate results, but at the cost of increased computation time.\n\n\n## Comparison and Equality\n\n### Comparing Decimal Objects\n\nDecimal.js provides several methods for comparing Decimal objects.  The core method is `comparedTo`, which offers a numerical comparison:\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('10.5');\nconst b = new Decimal('10.500');\nconst c = new Decimal('11');\n\nconsole.log(a.comparedTo(b)); // Output: 0 (a and b are equal)\nconsole.log(a.comparedTo(c)); // Output: -1 (a is less than c)\nconsole.log(c.comparedTo(a)); // Output: 1 (c is greater than a)\n```\n\n`comparedTo` returns:\n\n* `0`: if the two numbers are equal.\n* `-1`: if the current Decimal is less than the argument.\n* `1`: if the current Decimal is greater than the argument.\n\nOther comparison methods offer a more convenient, boolean-based comparison:\n\n* `equals`: Checks for equality (ignores trailing zeros).\n* `greaterThan`, `lessThan`, `greaterThanOrEqualTo`, `lessThanOrEqualTo`:  These methods provide straightforward boolean comparisons.\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('10.5');\nconst b = new Decimal('10.500');\n\nconsole.log(a.equals(b));             // Output: true (equals ignores trailing zeros)\nconsole.log(a.greaterThan(b));        // Output: false\nconsole.log(a.lessThan(b));          // Output: false\nconsole.log(a.greaterThanOrEqualTo(b));// Output: true\nconsole.log(a.lessThanOrEqualTo(b));  // Output: true\n\n```\n\n\n### Testing for Equality\n\nWhen testing for equality, it's crucial to understand how Decimal.js handles trailing zeros. The `equals` method provides a robust solution.  It compares the numerical values, disregarding differences in the number of trailing zeros.\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('1.000');\nconst b = new Decimal('1');\n\nconsole.log(a.equals(b)); // Output: true (Decimal.js considers them equal)\nconsole.log(a.toString() === b.toString()); //Output: false (String comparison considers them different)\n\n```\n\nDirectly comparing using the `===` operator on Decimal objects is generally not recommended for equality checks; instead, use the `equals` method.\n\n\n### Handling Precision Differences\n\nDecimal.js's `equals` method inherently handles precision differences when comparing numerical values.  However, if you need to compare numbers based on a specific level of precision, you can use methods like `toDecimalPlaces` or `toPrecision` before comparison:\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\nconst a = new Decimal('1.23456');\nconst b = new Decimal('1.23457');\nconst c = new Decimal('1.234567');\n\nconsole.log(a.equals(c)); // Output: false (different values)\n\n\n//Comparing to 4 decimal places\nconsole.log(a.toDecimalPlaces(4).equals(c.toDecimalPlaces(4))); // Output: true (equal when rounded to 4 decimal places)\n\n\n//Comparing using toPrecision:\nconsole.log(a.toPrecision(5).equals(b.toPrecision(5))); //Output: false (different when rounded to 5 significant digits)\nconsole.log(a.toPrecision(5).equals(c.toPrecision(5))); //Output: true (equal when rounded to 5 significant digits)\n\n\n```\n\nThis approach allows you to define the level of precision required for your equality checks.  Always consider the appropriate precision needed for the context of your application.\n\n\n## Error Handling\n\n### Common Errors and Exceptions\n\nDecimal.js throws exceptions in specific situations to indicate errors during calculations.  The most common errors include:\n\n* **Division by zero:** Attempting to divide a Decimal object by zero (`dividedBy(0)` or `/ 0`) will throw a `DivisionByZeroError`.\n\n* **Invalid input:** Providing invalid input to the Decimal constructor or methods (e.g., non-numeric strings) might throw a `TypeError` or a more specific error related to the invalid input.\n\n* **Overflow/Underflow:**  If the result of a calculation exceeds the maximum or minimum representable value (determined by the configured precision), an error might be thrown or the result might be clamped depending on the library's configuration. Note that with sufficient precision, overflow and underflow should be unlikely.\n\n* **Invalid rounding mode:** Specifying an invalid rounding mode when configuring Decimal.js may throw an error.\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\ntry {\n  const result = new Decimal(10).dividedBy(0);\n  console.log(result);\n} catch (e) {\n  console.error(\"Error:\", e.message); // Output: Error: Division by zero\n}\n\ntry {\n  const invalidDecimal = new Decimal('abc');\n  console.log(invalidDecimal);\n} catch (e) {\n  console.error(\"Error:\", e.message); //Output will vary depending on the Decimal.js version and browser\n}\n\n```\n\nAlways wrap potentially error-prone Decimal.js operations within `try...catch` blocks to handle exceptions gracefully.\n\n\n### Debugging Techniques\n\nDebugging Decimal.js code often involves careful examination of inputs and outputs. Key debugging techniques include:\n\n* **Console Logging:**  Use `console.log` to print the values of Decimal objects at different stages of your calculations.  Pay close attention to the string representations of the Decimal objects (`toString()`) to ensure they reflect the expected values and precision.\n\n* **Inspecting Intermediate Results:** Break down complex calculations into smaller, more manageable steps.  Log the intermediate results to identify where errors might be occurring.\n\n* **Using a Debugger:** Utilize your browser's developer tools or a dedicated debugger to step through your code, inspect variables, and understand the flow of execution.  This is particularly helpful when dealing with nested calculations or complex logic.\n\n* **Testing with Known Values:** Create unit tests with known inputs and expected outputs to verify the accuracy of your Decimal.js calculations.  This helps identify unexpected behavior or inaccuracies.\n\n* **Checking Precision:**  Ensure that the configured precision is adequate for your application's needs.  Insufficient precision can lead to rounding errors that might not be immediately apparent.\n\n\n### Best Practices for Error Prevention\n\nTo prevent errors and ensure accuracy:\n\n* **Use String Inputs:**  Whenever possible, provide Decimal.js with string representations of numbers.  This avoids potential floating-point inaccuracies during parsing.\n\n* **Check Inputs:**  Validate inputs before passing them to Decimal.js methods.  This includes checking for null, undefined, or non-numeric values.\n\n* **Handle Exceptions:**  Always wrap Decimal.js operations in `try...catch` blocks to handle potential exceptions.\n\n* **Set Appropriate Precision:** Configure the precision of Decimal.js to meet the accuracy requirements of your application.  Higher precision improves accuracy but may affect performance.\n\n* **Modular Code:** Break down complex calculations into smaller, well-defined functions to improve readability, testability, and maintainability.\n\n* **Unit Testing:**  Write comprehensive unit tests to validate your Decimal.js code.  This helps detect errors early and ensures accuracy over time.\n\n* **Consult Documentation:** Familiarize yourself with the Decimal.js documentation to understand the functions, their limitations, and potential error scenarios.\n\nBy adhering to these best practices, you can significantly reduce errors and build robust applications using Decimal.js.\n\n\n## Performance Considerations\n\nDecimal.js provides accurate decimal arithmetic, but its operations are generally slower than native JavaScript `Number` operations due to the overhead of arbitrary-precision calculations.  Understanding performance considerations is crucial for building efficient applications.\n\n\n### Optimizing Decimal Operations\n\nSeveral strategies can help optimize Decimal.js operations:\n\n* **Minimize Object Creation:** Creating Decimal objects repeatedly can impact performance.  Reuse existing Decimal objects whenever possible, especially within loops.\n\n* **Avoid Unnecessary Operations:** Carefully review your calculations to eliminate redundant or unnecessary operations.\n\n* **Batch Operations:** If possible, group multiple operations into a single sequence rather than performing them individually. Some operations, like chained additions or multiplications, can be optimized internally.\n\n* **Use efficient methods:** Utilize the most efficient method for the task. For instance, `add` and `plus` do the same operation, but direct use of `add` might offer a slight performance advantage in some contexts. Check the documentation for nuanced differences.\n\n* **Pre-allocate memory:** In scenarios involving large arrays or collections of decimals, consider pre-allocating arrays to avoid repeated dynamic memory allocations.  This is especially relevant for large-scale computations.\n\n\n* **Leverage efficient data structures:** Using appropriate data structures for large datasets (like typed arrays, if applicable) might help minimize memory overhead and potentially improve performance.\n\n* **Consider alternative libraries:** If performance is exceptionally critical and the precision requirements are not overly stringent, consider exploring other libraries offering faster decimal arithmetic (although usually with trade-offs in precision).\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Inefficient (repeated object creation)\nlet sum = new Decimal(0);\nfor (let i = 0; i < 100000; i++) {\n  sum = sum.plus(new Decimal(i));\n}\n\n// More efficient (reusing object)\nlet efficientSum = new Decimal(0);\nfor (let i = 0; i < 100000; i++) {\n  efficientSum.add(i); //Using add directly\n}\n\n```\n\nThe second example is more efficient as it avoids repeatedly creating new Decimal objects.\n\n\n### Benchmarking and Tuning\n\nTo measure and tune the performance of your Decimal.js code:\n\n* **Use Benchmarking Tools:** Employ benchmarking libraries like `benchmark.js` to measure the execution time of different code sections and compare optimization strategies.\n\n* **Profile Your Code:** Utilize browser profiling tools to identify performance bottlenecks within your Decimal.js code.\n\n* **Iterative Optimization:**  Apply optimizations iteratively, measuring the performance impact of each change using benchmarking tools. This ensures you are focusing on the most significant performance improvements.\n\n* **Analyze Results:** Carefully analyze benchmarking results to understand the trade-offs between different optimization techniques.\n\n\n### Strategies for Large-Scale Computations\n\nFor large-scale computations with Decimal.js:\n\n* **Parallel Processing:** Consider using Web Workers to perform calculations in parallel, improving performance, especially on multi-core processors.\n\n* **Asynchronous Operations:**  For tasks that do not require immediate results, use asynchronous operations to prevent blocking the main thread.\n\n* **Data Chunking:**  Break down large datasets into smaller chunks to process them in batches. This can improve memory management and avoid excessive memory allocation.\n\n* **Specialized Algorithms:** If applicable, explore specialized algorithms designed for high-precision calculations that might offer better performance than naive implementations.\n\n* **Caching:** If calculations involve repeated operations on the same data, caching intermediate results can significantly reduce computational time.\n\nRemember that the choice of optimization strategies will depend heavily on the specific nature of your large-scale computation and the acceptable level of performance trade-offs.  Profiling and benchmarking are essential for identifying the most effective optimizations.\n\n\n## API Reference\n\nThis section provides a comprehensive reference to the Decimal.js API. Due to the extensive nature of the API, providing a completely detailed explanation of *every* method and property within this response is impractical.  This overview will cover the key aspects and provide examples, encouraging you to consult the official Decimal.js documentation for the most complete and up-to-date information.\n\n\n### Constructor and Methods\n\nThe core of Decimal.js is its constructor, `Decimal()`, and its numerous methods.  The constructor creates a new Decimal object:\n\n```javascript\nconst myDecimal = new Decimal('123.45');\n```\n\nNumerous methods are available for arithmetic operations (`plus`, `minus`, `times`, `dividedBy`, `modulo`), comparison (`equals`, `greaterThan`, `lessThan`, etc.), mathematical functions (`sin`, `cos`, `sqrt`, `ln`, etc.), rounding and formatting (`toDecimalPlaces`, `toPrecision`, `toFixed`, `toString`), and more.  These methods are chainable for improved readability and conciseness:\n\n```javascript\nconst result = new Decimal('10').plus(5).times(2).toDecimalPlaces(2);\n```\n\n### Properties and Attributes\n\nDecimal.js offers several properties, primarily for configuration and accessing internal information.  Note that directly manipulating internal properties is generally discouraged and should be avoided unless you have a deep understanding of the library's internal workings.  Key properties include:\n\n* `Decimal.precision`:  Gets or sets the global precision.\n* `Decimal.rounding`: Gets or sets the global rounding mode.\n* `Decimal.crypto`:  Gets or sets whether to use a cryptographically secure random number generator.\n\n\nThese properties are typically managed using the `Decimal.set()` method for configuration:\n\n```javascript\nDecimal.set({ precision: 10, rounding: Decimal.ROUND_HALF_UP });\n```\n\n\n### Detailed Explanation of Each Method\n\nA comprehensive explanation of *every* method would be too extensive for this context.  The official Decimal.js documentation is the definitive source for detailed explanations.  However, we can briefly touch on some key method categories:\n\n* **Arithmetic:** `plus`, `minus`, `times`, `dividedBy`, `modulo`, `pow` (exponentiation).  These methods perform standard arithmetic operations with high precision.\n\n* **Comparison:** `equals`, `comparedTo`, `greaterThan`, `lessThan`, `greaterThanOrEqualTo`, `lessThanOrEqualTo`. These methods facilitate comparing Decimal objects.\n\n* **Mathematical:** `sin`, `cos`, `tan`, `asin`, `acos`, `atan`, `exp`, `ln`, `log`, `sqrt`, `abs`, and hyperbolic functions.  These provide advanced mathematical capabilities.\n\n* **Rounding & Formatting:** `toDecimalPlaces`, `toPrecision`, `toFixed`, `toString`.  These control how the Decimal object is represented.  Different rounding modes are available (`ROUND_UP`, `ROUND_DOWN`, `ROUND_HALF_UP`, `ROUND_HALF_EVEN`, etc.) and should be chosen appropriately.\n\n* **Other Utility Methods:** Decimal.js offers other helpful methods like `isFinite`, `isNaN`, `isZero`, and several utility functions.\n\n\n### Examples of Each Method\n\nProviding an example for every method would be excessively long. Instead, let's illustrate a few important ones:\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Arithmetic\nconst sum = new Decimal('2.5').plus('3.7');         //Addition - Output: 6.2\nconst diff = new Decimal(10).minus(3);             //Subtraction - Output: 7\nconst prod = new Decimal(4).times(5);               //Multiplication - Output: 20\nconst div = new Decimal(10).dividedBy(3);           //Division - Output: 3.3333333333333335 (Precision Dependent)\nconst mod = new Decimal(17).modulo(5);              //Modulo - Output: 2\nconst pow = new Decimal(2).pow(3);                   //Power - Output: 8\n\n\n//Comparison\nconst isEqual = new Decimal('1.00').equals('1');    //Equality - Output: true\nconst greater = new Decimal(5).greaterThan(3);      //GreaterThan - Output: true\n\n//Rounding and Formatting\nconst rounded = new Decimal('12.3456').toDecimalPlaces(2); //Output: 12.35\nconst precise = new Decimal('1234567').toPrecision(3);   //Output: 1.23e+6\nconst formatted = new Decimal('12.34').toFixed(1);      //Output: 12.3\n\n//Mathematical function\nconst sqrtResult = new Decimal(16).sqrt();             //Output: 4\nconst lnResult = new Decimal(Math.E).ln();            //Output: 1\n```\n\nRefer to the official Decimal.js documentation for exhaustive method listings, detailed explanations, and further examples.  Remember to install the library (`npm install decimal.js`) before running these code snippets.\n\n\n\n## Examples and Use Cases\n\nDecimal.js excels in scenarios where precise decimal arithmetic is crucial, avoiding the pitfalls of JavaScript's native floating-point numbers. Here are some compelling use cases:\n\n\n### Financial Calculations\n\nFinancial applications demand utmost accuracy.  Even small rounding errors can accumulate and lead to significant discrepancies in balances, interest calculations, or currency conversions. Decimal.js provides a robust solution:\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Calculating compound interest\nconst principal = new Decimal('1000');\nconst rate = new Decimal('0.05'); // 5% interest rate\nconst years = new Decimal('5');\nconst interest = principal.times(rate.times(years));\n\nconst totalAmount = principal.plus(interest);\nconsole.log(\"Total amount after 5 years:\", totalAmount.toFixed(2)); //Output: 1250.00\n\n//Currency Conversion with precise exchange rates.\nconst amountInUSD = new Decimal('100');\nconst exchangeRate = new Decimal('0.85'); //USD to EUR\nconst amountInEUR = amountInUSD.times(exchangeRate);\nconsole.log(\"Amount in EUR:\", amountInEUR.toFixed(2)); //Output: 85.00\n\n```\n\nThis example demonstrates how Decimal.js ensures precise interest calculations and currency conversions, preventing accumulated rounding errors.\n\n\n### Scientific Computations\n\nScientific computations frequently involve very small or very large numbers, where the limitations of floating-point arithmetic become apparent. Decimal.js enables accurate results even with extreme values:\n\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Calculating Avogadro's number multiplied by a small factor:\nconst avogadro = new Decimal('6.02214076e+23'); // Avogadro's number\nconst smallFactor = new Decimal('1e-10');\nconst result = avogadro.times(smallFactor);\nconsole.log(\"Result:\", result.toString()); //Output will be precise\n\n// Handling very small numbers in calculations involving exponents\nconst smallNumber = new Decimal('1e-20');\nconst exponent = new Decimal(10);\nconst poweredResult = smallNumber.pow(exponent);\nconsole.log(\"Powered result:\", poweredResult.toString()); //Output will maintain precision\n\n```\n\nIn this example, Decimal.js precisely handles Avogadro's number and a small factor without losing significant figures, a common issue with native floating point numbers.\n\n\n### Cryptocurrency Applications\n\nCryptocurrency transactions involve precise amounts of digital assets.  Decimal.js is invaluable for accurate calculations of balances, transaction fees, and exchanges:\n\n```javascript\nimport Decimal from 'decimal.js';\n\n// Calculating transaction fees:\nconst transactionAmount = new Decimal('1.23456789'); //BTC\nconst feeRate = new Decimal('0.001'); // 0.1% fee\nconst transactionFee = transactionAmount.times(feeRate);\nconsole.log(\"Transaction fee:\", transactionFee.toFixed(8)); //Output will be precise to 8 decimal places\n\n\n//Exchange calculations using precise exchange rate\nconst btcAmount = new Decimal('0.1');\nconst ethExchangeRate = new Decimal('1600'); //BTC to ETH\nconst ethAmount = btcAmount.times(ethExchangeRate);\nconsole.log(\"ETH amount:\", ethAmount.toString()); //Output maintains precision\n\n\n```\n\nThis example showcases how to accurately calculate transaction fees and handle cryptocurrency exchanges using Decimal.js, preserving the necessary level of precision for cryptocurrency transactions.\n\n\n### Data Analysis\n\nData analysis frequently involves calculations with decimal numbers, especially when dealing with financial, statistical, or scientific data.  Maintaining accuracy is crucial for reliable results:\n\n```javascript\nimport Decimal from 'decimal.js';\n\n//Calculating the average of a set of decimal values:\nconst values = [new Decimal('1.2'), new Decimal('2.5'), new Decimal('3.7'), new Decimal('4.1')];\nlet sum = new Decimal(0);\nfor (const val of values) {\n    sum = sum.plus(val);\n}\nconst average = sum.dividedBy(values.length);\nconsole.log(\"Average:\", average.toFixed(2)); //Output: 2.88\n\n\n//Calculating Standard Deviation of a set of decimal values:  (requires additional helper functions beyond the scope of this example, but Decimal.js would be essential for accurate intermediate calculations)\n\n```\n\nDecimal.js ensures that aggregations like averages and statistical computations are performed with high accuracy, yielding reliable analytical results.  While the standard deviation example is not fully elaborated here for brevity, it highlights the usefulness of the library in more complex data analysis tasks.  You would use Decimal.js for precise calculations within the standard deviation formula.\n\n\n## Contributing to Decimal.js\n\nContributions to Decimal.js are welcome!  This section outlines the process for contributing to the project.\n\n### Development Setup\n\n1. **Fork the Repository:** Fork the official Decimal.js repository on GitHub to your personal account.\n\n2. **Clone Your Fork:** Clone your forked repository to your local machine:\n\n   ```bash\n   git clone git@github.com:<your-username>/decimal.js.git\n   cd decimal.js\n   ```\n\n3. **Install Dependencies:** Install the necessary dependencies using npm or yarn:\n\n   ```bash\n   npm install\n   # or\n   yarn install\n   ```\n\n4. **Set up Testing:**  Decimal.js uses a comprehensive test suite.  Ensure the tests run correctly before making any changes. Run the tests using:\n\n   ```bash\n   npm test\n   # or\n   yarn test\n   ```\n\n### Coding Standards\n\nDecimal.js follows specific coding standards to ensure consistency and readability.  Key aspects include:\n\n* **Consistent Indentation:** Use two spaces for indentation.\n\n* **Meaningful Variable Names:** Use descriptive variable names that clearly indicate their purpose.\n\n* **Comments:**  Add clear and concise comments to explain complex logic or non-obvious code sections.\n\n* **Code Style:** Adhere to a consistent coding style (the existing codebase serves as a good guide).\n\n* **ES6+ Features:** Use modern JavaScript features (ES6+ and beyond where appropriate).\n\nBefore submitting a pull request, ensure your code conforms to these standards.  You can use linters like ESLint to help enforce the style guide automatically.\n\n\n### Testing and Quality Assurance\n\nDecimal.js has a thorough test suite.  Before submitting any changes, ensure that all existing tests pass and that you've added new tests to cover your changes.  Thorough testing is essential to maintain the library's accuracy and reliability.  The test suite uses tools like Jasmine and Karma.  Familiarize yourself with the testing process to effectively contribute.\n\n\n### Submitting Pull Requests\n\n1. **Create a Branch:** Create a new branch for your changes from the `main` or `master` branch (depending on the repository's main branch):\n\n   ```bash\n   git checkout -b <your-branch-name>\n   ```\n\n2. **Make Your Changes:** Implement your changes, adhering to the coding standards and adding comprehensive tests.\n\n3. **Commit Your Changes:** Commit your changes with clear and concise commit messages:\n\n   ```bash\n   git add .\n   git commit -m \"Your descriptive commit message\"\n   ```\n\n4. **Push Your Branch:** Push your branch to your forked repository:\n\n   ```bash\n   git push origin <your-branch-name>\n   ```\n\n5. **Open a Pull Request:** On GitHub, open a pull request from your branch to the main branch of the official Decimal.js repository. Provide a clear description of your changes and address any feedback from the maintainers.\n\nRemember to follow the contribution guidelines provided in the official Decimal.js repository.  The maintainers will review your pull request and provide feedback.  Be prepared to address any comments or suggested improvements before your contribution is merged.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["../../styles.css"],"html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"},"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"},"../../footer.html"],"output-file":"decimaljs.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"license":"MIT","author-meta":"Muthukrishnan","title":"Decimal.js - Documentation","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}