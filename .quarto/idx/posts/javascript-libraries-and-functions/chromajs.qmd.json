{"title":"Chroma.js - Documentation","markdown":{"yaml":{"title":"Chroma.js - Documentation","description":"Chroma.js is a small, fast, and easy-to-use JavaScript library for color manipulation and conversion. It provides a simple and consistent API for working...","date":"2025-02-09","categories":["JavaScript Libraries and Functions"]},"headingText":"What is Chroma.js?","containsRefs":false,"markdown":"\n\nChroma.js is a small, fast, and easy-to-use JavaScript library for color manipulation and conversion.  It provides a simple and consistent API for working with colors in various formats (hex, RGB, HSL, HSV, and more), allowing you to perform operations like blending, interpolating, and manipulating color properties with ease.  Its compact size makes it ideal for inclusion in web projects without significantly impacting performance.\n\n### Why use Chroma.js?\n\nChroma.js offers several advantages over manually handling color calculations:\n\n* **Simplicity:** Its intuitive API makes color manipulation straightforward, even for complex operations.\n* **Efficiency:**  Chroma.js is optimized for performance, making it suitable for applications requiring many color calculations.\n* **Consistency:** It provides a unified way to handle colors regardless of their initial format.\n* **Cross-browser compatibility:** Chroma.js is designed to work seamlessly across different browsers.\n* **Extensive functionality:**  Beyond basic conversions, it provides functions for blending, interpolating, and generating color scales.\n\n### Setting up Chroma.js\n\nChroma.js can be easily integrated into your project using a variety of methods:\n\n* **Download:** Download the minified `chroma.min.js` file from the Chroma.js GitHub repository or CDN and include it in your HTML file using a `<script>` tag:\n\n```html\n<script src=\"chroma.min.js\"></script>\n```\n\n* **NPM:** If you're using npm, install it via:\n\n```bash\nnpm install chroma-js\n```\n\nThen, import it into your JavaScript file:\n\n\n```javascript\nimport chroma from 'chroma-js';\n```\n\n\n* **CDN:** You can also use a CDN like jsDelivr:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/chroma-js/chroma.min.js\"></script>\n```\n\n\nRemember to replace `\"chroma.min.js\"` with the actual path to the file if necessary.\n\n\n### Basic Usage Examples\n\nHere are some basic examples demonstrating Chroma.js's core functionality:\n\n**1. Creating a Chroma color:**\n\n```javascript\nlet color = chroma('#FF0000'); // Create a color from a hex string\nlet color2 = chroma('rgb(0, 255, 0)'); //Create a color from RGB values\nlet color3 = chroma('hsl(240, 100%, 50%)'); //Create a color from HSL values\n\nconsole.log(color.hex()); // Output: #ff0000\nconsole.log(color2.rgb()); // Output: [0, 255, 0]\nconsole.log(color3.hsl()); // Output: [240, 1, 0.5]\n\n```\n\n**2. Color manipulation:**\n\n```javascript\nlet color = chroma('#0000FF');\n\nlet lighterColor = color.brighten();\nlet darkerColor = color.darken();\n\nconsole.log(lighterColor.hex());\nconsole.log(darkerColor.hex());\n```\n\n\n**3. Color blending:**\n\n```javascript\nlet color1 = chroma('#FF0000');\nlet color2 = chroma('#0000FF');\nlet blendedColor = chroma.mix(color1, color2, 0.5); // Blend with a 50/50 ratio\n\nconsole.log(blendedColor.hex()); // Output: A purple color (depending on the blending method)\n```\n\nThese examples show how easily you can create, manipulate, and blend colors using Chroma.js.  Refer to the complete API documentation for a comprehensive list of available functions and methods.\n\n\n## Color Creation and Manipulation\n\n### Creating Colors from various inputs (Hex, RGB, HSL, etc.)\n\nChroma.js offers a flexible and consistent way to create color objects from various input formats.  The core `chroma()` function accepts a wide range of inputs:\n\n* **Hexadecimal strings:**  `chroma('#FF0000')`, `chroma('#f00')`\n* **RGB arrays:** `chroma([255, 0, 0])`\n* **RGB strings:** `chroma('rgb(255, 0, 0)')`\n* **HSL arrays:** `chroma([0, 1, 0.5])`\n* **HSL strings:** `chroma('hsl(0, 100%, 50%)')`\n* **HSV arrays:** `chroma([0, 1, 1])`\n* **HSV strings:** `chroma('hsv(0, 100%, 100%)')`\n* **Named colors:** `chroma('red')` (Note: Support for named colors might be limited; check the documentation for a complete list.)\n* **Number (Grayscale):** `chroma(0.5)` (Represents 50% gray)\n\n\nAll of these inputs will return a Chroma.js color object that can be further manipulated.\n\n\n### Converting between color spaces (RGB, HSL, HSV, LAB, etc.)\n\nChroma.js simplifies color space conversions.  Once you have a Chroma color object, you can easily get its representation in various color spaces using the following methods:\n\n* `.rgb()`: Returns an array representing the color in RGB [red, green, blue] (values 0-255).\n* `.rgba()`: Returns an array representing the color in RGBA [red, green, blue, alpha] (values 0-255, alpha 0-1).\n* `.hsl()`: Returns an array representing the color in HSL [hue, saturation, lightness] (hue 0-360, saturation and lightness 0-1).\n* `.hsv()`: Returns an array representing the color in HSV [hue, saturation, value] (hue 0-360, saturation and value 0-1).\n* `.lab()`: Returns an array representing the color in LAB [L, a, b] (L 0-100, a and b vary).\n* `.hex()`: Returns a hexadecimal string representation of the color (#RRGGBB).\n* `.css()`: Returns a CSS string representation of the color (e.g., 'rgb(255,0,0)', 'hsl(0,100%,50%)').\n\n\nFor example:\n\n```javascript\nlet color = chroma('#FF0000');\nconsole.log(color.rgb());     // Output: [255, 0, 0]\nconsole.log(color.hsl());     // Output: [0, 1, 0.5]\nconsole.log(color.hex());     // Output: #ff0000\nconsole.log(color.css());    // Output: rgb(255,0,0)\n```\n\n### Brightness, Saturation, and Hue adjustments\n\nChroma.js provides methods to easily adjust the brightness, saturation, and hue of a color:\n\n* `.brighten(amount)`: Increases the brightness of the color.  `amount` is a factor (e.g., 0.5 brightens by 50%).\n* `.darken(amount)`: Decreases the brightness of the color.\n* `.saturate(amount)`: Increases the saturation of the color.\n* `.desaturate(amount)`: Decreases the saturation of the color.\n* `.set(channel, value)`: Sets the value of a specific channel (e.g., 'rgb', 'hsl', etc.)\n* `.adjust([h,s,l])`: Adjusts Hue, Saturation, and Lightness at once.\n\n\nExample:\n\n```javascript\nlet color = chroma('#00FF00');\nlet brighterColor = color.brighten(0.2);\nlet moreSaturated = color.saturate(0.5);\nconsole.log(brighterColor.hex());\nconsole.log(moreSaturated.hex());\n\nlet adjustedColor = color.adjust([30, 0.2, -0.1]); //increases hue by 30, saturation by 20%, and decreases lightness by 10%\nconsole.log(adjustedColor.hex())\n\n```\n\n### Alpha manipulation\n\nChroma.js allows you to control the alpha (opacity) value of a color:\n\n* `.alpha(value)`: Sets the alpha value (0-1).\n* `.alpha()`: Gets the current alpha value.\n\nExample:\n\n```javascript\nlet color = chroma('#0000FF');\nlet semiTransparent = color.alpha(0.5);\nconsole.log(semiTransparent.rgba()); //Output will include an alpha value of 0.5\nconsole.log(semiTransparent.css()); //Output will include rgba values\n```\n\n### Clamping and limiting color values\n\nWhile Chroma.js generally handles color values appropriately, you might occasionally need to explicitly clamp or limit color component values.  This is not directly provided as a built-in function within the core Chroma.js API. You'd typically handle this using standard JavaScript `Math.min()` and `Math.max()` functions within your application's logic after obtaining the color values (RGB, HSL, etc.) from Chroma.js.  For example:\n\n```javascript\nlet color = chroma('rgb(300, 100, -50)'); // Example with out-of-range values\nlet rgb = color.rgb();\n\nlet clampedRGB = rgb.map(val => Math.max(0, Math.min(255, val))); //Clamp RGB values to 0-255\n\nconsole.log(clampedRGB);\n```\n\nThis ensures your color values remain within the valid ranges for the respective color spaces.\n\n\n## Color Scales and Palettes\n\n### Generating color scales\n\nChroma.js makes it easy to generate color scales using the `scale()` function.  You provide a starting and ending color, and the number of steps, and Chroma.js will generate a smoothly interpolated array of colors.  You can also specify a color scale scheme (e.g., 'YlOrRd', 'RdBu').  More details on predefined scales below.\n\n```javascript\nlet scale = chroma.scale(['red', 'blue']).colors(10); // Generate a 10-step scale from red to blue\nconsole.log(scale); // Output: Array of 10 hex color strings\n\nlet scale2 = chroma.scale('cool').colors(5); // Generates 5 colors from the 'cool' scheme\nconsole.log(scale2);\n\nlet scale3 = chroma.scale(['#000', '#fff']).mode('lab').colors(8); //Use lab color space for smoother interpolation\nconsole.log(scale3)\n```\n\nYou can also pass a function to `scale()` for more complex scales:\n\n```javascript\n// A function that will generate rainbow colors\nlet rainbowScale = chroma.scale(x => chroma.hsl(x * 360, 1, 0.5)).colors(10);\nconsole.log(rainbowScale)\n```\n\n\n### Predefined color scales\n\nChroma.js includes a number of predefined color scales, based on colorbrewer2.org and other sources.  These scales are designed for various purposes and offer perceptually uniform color transitions.  You can access them by name (e.g., 'viridis', 'magma', 'plasma', 'inferno', 'cividis', 'RdBu', 'YlOrRd', 'Greens', etc.).  Refer to the Chroma.js documentation or examples for the complete list and their visual representations.\n\n```javascript\nlet scale = chroma.scale('viridis').colors(5); //Using the predefined 'viridis' scale\nconsole.log(scale)\n```\n\n\n### Customizing color scales\n\nYou can customize the behavior of color scales by using the various options available within `chroma.scale()`.  For example, you can specify the `mode` for color space interpolation (`'rgb'`, `'lab'`, `'hsl'`, `'hsv'`), affecting the visual quality and perceived uniformity.  The `domain` option allows you to set the input range for the scale, which is helpful when mapping data values to colors.\n\n```javascript\nlet scale = chroma.scale(['blue', 'green', 'yellow', 'red']).domain([0,100]).colors(5);\n// Generates 5 colors interpolated between blue, green, yellow, and red based on a 0 to 100 domain.\n\nlet labScale = chroma.scale(['blue', 'green']).mode('lab').colors(10); //Use lab interpolation\nconsole.log(labScale);\n```\n\n\n### Interpolating colors\n\nChroma.js provides `interpolate()` for creating a color at a specific point along a scale.   This function is also implicitly used within `colors()` method of the scale object.\n\n\n```javascript\nlet scale = chroma.scale(['red', 'blue']);\nlet interpolatedColor = scale(0.5); // Color halfway between red and blue\nconsole.log(interpolatedColor.hex()); // Output: A purple hex code\n\nlet interpolatedColor2 = scale(0.75).hex();\nconsole.log(interpolatedColor2);\n```\n\nThe input to `scale()` is a normalized value between 0 and 1 (inclusive). You can easily map your data (in any numerical range) into that space before passing it to the function.\n\n### Working with palettes\n\nWhile not explicitly defined as a separate \"palette\" object, the result of `chroma.scale().colors()` effectively acts as a color palette.  You can store the returned array of color strings or objects for later use in your application, for example, to assign colors to chart segments, map features, etc.\n\n```javascript\nlet myPalette = chroma.scale('Spectral').colors(7); //Create a 7 color palette based on spectral scale\n\n//Use myPalette to color chart elements, map elements, or any visual elements.\n```\n\n\n## Color Comparisons and Differences\n\n### Calculating color difference (Delta E)\n\nChroma.js allows you to calculate the perceptual difference between two colors using the Delta E (ΔE) metric.  Delta E quantifies the difference in color appearance, taking into account human perception.  A smaller Delta E value indicates a smaller perceived difference. Chroma.js uses the CIE76 formula by default, but can also calculate using the more accurate CIE94 and CMC formulas by specifying the appropriate method in the `deltaE()` method.\n\n```javascript\nlet color1 = chroma('#FF0000');\nlet color2 = chroma('#FF0000');\nlet color3 = chroma('#0000FF');\n\nlet deltaE76 = color1.deltaE(color2, '76'); // Default method\nlet deltaE94 = color1.deltaE(color3, '94'); // Using CIE94\nlet deltaECMC = color1.deltaE(color3, 'cmc'); // Using CMC\n\nconsole.log(\"Delta E (CIE76):\", deltaE76); // Output: A very small number close to 0\nconsole.log(\"Delta E (CIE94):\", deltaE94); // Output: A larger number representing a greater difference\nconsole.log(\"Delta E (CMC):\", deltaECMC); // Output: A larger number representing a greater difference\n```\n\nNote that different Delta E formulas will yield different numerical results; however, the relative differences between color pairs should remain consistent regardless of chosen formula.\n\n\n### Comparing color similarity\n\nWhile not a direct function, you can use the Delta E value to determine the similarity of two colors.  A lower Delta E value indicates greater similarity.  You can define a threshold based on your application's requirements to determine if two colors are considered \"similar\" enough.\n\n```javascript\nlet color1 = chroma('#FF0000');\nlet color2 = chroma('#FF1100');\nlet threshold = 5; // Example threshold\n\nlet deltaE = color1.deltaE(color2);\n\nif (deltaE < threshold) {\n  console.log(\"Colors are similar\");\n} else {\n  console.log(\"Colors are different\");\n}\n```\n\n### Finding complementary and analogous colors\n\nChroma.js doesn't have built-in functions specifically labeled \"complementary\" or \"analogous.\"  However, you can easily calculate these using color space manipulations.\n\n\n* **Complementary colors:**  Complementary colors are located directly opposite each other on the color wheel (hue difference of approximately 180 degrees).  For HSL or HSV colors, you can calculate the complement by adding 180 to the hue, wrapping around 360 if necessary:\n\n```javascript\nlet color = chroma('#FF0000'); //Red\nlet hsl = color.hsl();\nlet complementaryHue = (hsl[0] + 180) % 360;\nlet complementaryColor = chroma.hsl(complementaryHue, hsl[1], hsl[2]);\nconsole.log(complementaryColor.hex()); //Output: Cyan (approximately)\n```\n\n* **Analogous colors:** Analogous colors are located next to each other on the color wheel (small hue differences). You can obtain analogous colors by adding or subtracting a small value from the hue:\n\n```javascript\nlet color = chroma('#FF0000');\nlet hsl = color.hsl();\nlet analogousColor1 = chroma.hsl((hsl[0] + 30) % 360, hsl[1], hsl[2]); //Slightly more orange\nlet analogousColor2 = chroma.hsl((hsl[0] - 30 + 360) % 360, hsl[1], hsl[2]); //Slightly more purple\nconsole.log(analogousColor1.hex(), analogousColor2.hex());\n```\n\nRemember to adjust the added/subtracted hue value to control the distance between analogous colors.  You may also need to adjust saturation and lightness for desired results.\n\n\n## Advanced Techniques\n\n### Blending colors\n\nChroma.js offers several ways to blend colors:\n\n* **`chroma.mix(color1, color2, weight, mode)`:** This is the primary blending function.  `color1` and `color2` are Chroma color objects. `weight` is a number between 0 and 1 representing the proportion of `color2` in the blend (0 means only `color1`, 1 means only `color2`).  `mode` is an optional parameter that specifies the blending method; common options include:\n\n    * `'lrgb'` (linear RGB): A simple average of RGB values. This is the default.\n    * `'lab'` (CIELAB):  Perceptually uniform blending in CIELAB color space.  Often produces more natural-looking results.\n    * `'hsv'` (HSV): Blending in the HSV color space.\n    * `'hsl'` (HSL): Blending in the HSL color space.\n\n\n```javascript\nlet color1 = chroma('#FF0000');\nlet color2 = chroma('#0000FF');\n\nlet blendedLRGB = chroma.mix(color1, color2, 0.5, 'lrgb');\nlet blendedLAB = chroma.mix(color1, color2, 0.5, 'lab');\n\nconsole.log(blendedLRGB.hex());\nconsole.log(blendedLAB.hex());\n```\n\n* **`chroma.blend(color1, color2, weight, mode)`:**  Similar to `mix`, this function provides the same functionality with a slightly different naming scheme.\n\nThe choice of blending mode significantly impacts the result. Experiment to find the mode best suited to your needs.\n\n\n### Color quantization\n\nColor quantization reduces the number of colors in an image or dataset.  Chroma.js doesn't directly perform image quantization, but you can use its color manipulation capabilities in conjunction with other libraries (like those for image processing) to achieve this.  A basic approach involves iterating through pixels, calculating their dominant color using averaging or clustering methods, and then mapping them to a reduced palette generated with Chroma.js's `scale()` function.\n\n```javascript\n//Illustrative example, requires external image processing library\n//This is a simplified example, a real application would require a proper image processing library\nconst palette = chroma.scale(['red', 'green', 'blue']).colors(3); //Create a 3-color palette\n\n//Simulate pixel data; replace with actual pixel data from your image\nconst pixelData = [\n  [200, 100, 50],\n  [100, 200, 50],\n  [50, 100, 200]\n]\n\n\nconst quantizedPixels = pixelData.map(pixel => {\n  //Find closest color in the palette (simplified example, would use a more sophisticated algorithm)\n  let closestColor = palette[0]\n\n  return closestColor;\n})\nconsole.log(quantizedPixels);\n```\n\n\n### Working with images\n\nChroma.js primarily focuses on color manipulation. Direct image processing isn't a core feature. To work with images, you'll need to use a separate image processing library (like a canvas-based library or a dedicated image manipulation library) to load, access pixel data, and then use Chroma.js to process the colors of the individual pixels.\n\n\n### Custom color spaces\n\nChroma.js doesn't directly support defining entirely new custom color spaces.  Its strength lies in its handling of common color spaces (RGB, HSL, HSV, LAB).  However, you can extend its functionality by creating custom functions to perform transformations between a new color model and one of Chroma.js's supported spaces.  These functions would handle conversions to and from, for example, RGB, allowing you to work with your custom color space indirectly.  This would involve implementing your own conversion algorithms.\n\n\n## Utilities and Helper Functions\n\n### Formatting and parsing colors\n\nChroma.js provides several helper functions for working with color formats:\n\n* **`chroma.hex(color)`:** Converts a color (Chroma object or compatible input) to its hexadecimal string representation (#RRGGBB).\n* **`chroma.rgb(color)`:** Converts a color to an RGB array [r, g, b].\n* **`chroma.hsl(color)`:** Converts a color to an HSL array [h, s, l].\n* **`chroma.hsv(color)`:** Converts a color to an HSV array [h, s, v].\n* **`chroma.lab(color)`:** Converts a color to an LAB array [l, a, b].\n* **`chroma.gl(color)`:** Converts a color to an array suitable for WebGL [r, g, b, a] (values are between 0 and 1).\n* **`chroma.css(color)`:** Returns a CSS color string (e.g., 'rgb(255, 0, 0)', '#f00').  This will pick the shortest possible representation.\n\nThese functions provide a convenient way to get a specific color format from a Chroma color object or any valid Chroma color input.  They handle the conversion automatically.\n\nExample:\n\n```javascript\nlet color = chroma('#FF0000');\nconsole.log(chroma.hex(color));      // Output: #ff0000\nconsole.log(chroma.rgb(color));      // Output: [255, 0, 0]\nconsole.log(chroma.hsl(color));      // Output: [0, 1, 0.5]\nconsole.log(chroma.css(color));     // Output: #f00\nconsole.log(chroma.gl(color));     // Output: [1, 0, 0, 1]\n```\n\n### Working with color strings\n\nChroma.js inherently handles various color string formats as input to the `chroma()` function and its conversion methods. However, there isn't a dedicated set of functions solely for manipulating color strings beyond what's available via conversion functions described above. If you have more complex string parsing tasks involving color codes, you might need to use standard JavaScript string manipulation functions (`split`, `substring`, `parseInt`, etc.).\n\n\n### Other utility functions\n\nBesides color formatting and parsing, Chroma.js provides other useful functions:\n\n* **`chroma.valid(color)`:** Checks if the provided input is a valid color representation (string or array).  Returns `true` or `false`.\n\n* **`chroma.contrast(color1, color2)`:**  Calculates the contrast ratio between two colors, helpful for accessibility considerations. The result is a number indicating the contrast level. A higher number means better contrast.  WCAG guidelines often recommend contrast ratios above 4.5:1 for sufficient contrast between text and background colors.\n\n```javascript\nlet color1 = chroma('#000');\nlet color2 = chroma('#fff');\nlet contrastRatio = chroma.contrast(color1, color2);\nconsole.log(contrastRatio); // Output: A number representing the contrast ratio\n```\n\n* **`chroma.distance(color1, color2)`:** Calculates the Euclidean distance between two colors in a specified color space (defaults to LAB). It is similar to calculating Delta E but doesn't represent the perceptual difference in the same way.\n\n\nThese utility functions offer additional support for common color-related tasks beyond color creation and manipulation.  They enhance the usability and efficiency of Chroma.js in your projects.\n\n\n## Best Practices and Common Pitfalls\n\n### Performance considerations\n\nWhile Chroma.js is generally performant, keep these points in mind for optimal performance, especially when dealing with large numbers of color calculations:\n\n* **Minimize unnecessary calculations:** Avoid redundant calls to Chroma.js functions. If you need a color's RGB value multiple times, calculate it once and store the result in a variable.\n* **Use efficient color spaces:** For operations like blending or interpolation, consider using perceptually uniform color spaces like LAB to achieve more natural-looking and efficient results.  Avoid switching repeatedly between different color spaces unless necessary.\n* **Batch operations:** When processing a large array of colors, process them in batches or use array methods like `map` to avoid creating many intermediate objects, improving performance.\n* **Avoid unnecessary object creation:** If performance is critical, you might consider working directly with arrays of color components (RGB, HSL, etc.) instead of creating numerous Chroma color objects.  While less convenient, this approach can be significantly faster for very large datasets.\n* **Caching:** For very performance sensitive applications, you might consider caching results, especially if you are performing the same calculation on the same color or color set multiple times.\n\n\n### Error handling and debugging\n\nChroma.js generally handles invalid color inputs gracefully. However, it is good practice to include checks to ensure that your inputs are indeed valid color representations.  The `chroma.valid(color)` function can help in this.\n\nFor debugging, standard JavaScript debugging tools can be used.  Console logging of intermediate values (color components, results of calculations) can be helpful in identifying the source of errors or unexpected behavior.\n\n\n### Common mistakes and solutions\n\n* **Incorrect color space:** Using the wrong color space for a particular operation can lead to unexpected results.  Remember that different color spaces have different properties, and what might be a simple operation in one space could be complex in another. For example, linear interpolation in RGB might not produce visually smooth transitions, while LAB often yields much better results for perceptual uniformity.\n* **Alpha value handling:** When blending colors or applying transparency, ensure you correctly handle the alpha channel (opacity).  Incorrect alpha handling can result in unexpected colors or visual artifacts.\n* **Out-of-range values:**  Always ensure that color components (RGB, HSL, etc.) are within their valid ranges (0-255 for RGB components, 0-1 for saturation and lightness in HSL, etc.).  Values outside these ranges might lead to errors or unexpected color outputs.  You can use JavaScript's `Math.min()` and `Math.max()` functions to clamp values to their valid ranges.\n* **Overlooking color space conversions:**  When performing operations involving colors from different sources or formats, be mindful of the color space of each color. You might need to explicitly convert colors to a common space before performing operations. For example, if blending hex and HSL colors, first convert both to the same color space (like LAB) before blending.\n* **Misinterpreting Delta E:** Remember that Delta E values provide a relative measure of color difference.  The absolute value doesn't have a direct, universally consistent interpretation; only the comparative differences between pairs of Delta E values is meaningful.  Choosing the appropriate Delta E formula (CIE76, CIE94, or CMC) is also important.\n\n\n\nBy avoiding these common pitfalls and following the best practices, you can effectively use Chroma.js to perform robust and efficient color manipulations in your applications.\n\n\n## Appendix\n\n### Glossary of terms\n\n* **Color Space:** A mathematical model that describes the range of colors that can be represented.  Examples include RGB, HSL, HSV, LAB.\n* **RGB:** Red, Green, Blue – an additive color model where colors are created by combining different intensities of red, green, and blue light.\n* **HSL:** Hue, Saturation, Lightness – a color model that uses hue (color), saturation (intensity), and lightness (brightness) to represent colors.\n* **HSV:** Hue, Saturation, Value – similar to HSL, but uses \"value\" instead of \"lightness,\" representing the maximum intensity of the color.\n* **LAB:**  CIELAB – a perceptually uniform color space designed to approximate human color perception more accurately than RGB.\n* **Delta E (ΔE):** A metric that quantifies the perceived difference between two colors.  Smaller values indicate greater similarity.  Different formulas exist (CIE76, CIE94, CMC) with varying levels of accuracy.\n* **Hue:**  The pure color (e.g., red, green, blue).\n* **Saturation:** The intensity or purity of a color.  High saturation means a vivid color, while low saturation is closer to gray.\n* **Lightness/Value:**  The brightness or intensity of a color.\n* **Color Quantization:**  Reducing the number of colors used in an image or dataset.\n* **Perceptually Uniform:** A color space where small numerical differences correspond to approximately equal perceived differences in color.\n\n\n### List of color spaces\n\nChroma.js supports conversions between several color spaces:\n\n* RGB (Red, Green, Blue)\n* RGBA (Red, Green, Blue, Alpha)\n* HSL (Hue, Saturation, Lightness)\n* HSV (Hue, Saturation, Value)\n* LAB (CIELAB)\n* XYZ (CIE XYZ)\n* Luv (CIE Luv)\n\n\n### Chroma.js API reference\n\n(Note:  A comprehensive API reference would be too extensive for this context.  A real developer manual would include a detailed API listing with descriptions of all functions, parameters, and return values. This is a placeholder.)\n\n\nThe Chroma.js API includes functions for:\n\n* **Color Creation:** Creating color objects from various input types (hex, RGB, HSL, etc.).\n* **Color Conversion:** Converting between different color spaces (RGB, HSL, HSV, LAB, etc.).\n* **Color Manipulation:** Adjusting brightness, saturation, hue, and alpha.\n* **Color Blending:** Mixing two colors with different weights and blending modes.\n* **Color Scales:** Generating and customizing color scales.\n* **Color Comparison:** Calculating color difference using Delta E.\n* **Utility Functions:**  Formatting colors, parsing color strings, and other helper functions.\n\n\nConsult the official Chroma.js documentation for the complete and up-to-date API reference.\n\n\n### Contributing to Chroma.js\n\n(Note:  This section should link to the project's contribution guidelines on GitHub or a similar platform.)\n\nIf you're interested in contributing to Chroma.js, please refer to the project's contribution guidelines on [GitHub Link].  Contributions are welcome, including bug fixes, new features, improved documentation, and performance optimizations.  Before submitting a pull request, ensure you follow the project's coding style and testing procedures.  Your contributions will help improve Chroma.js for the benefit of all users.\n\n","srcMarkdownNoYaml":"\n### What is Chroma.js?\n\nChroma.js is a small, fast, and easy-to-use JavaScript library for color manipulation and conversion.  It provides a simple and consistent API for working with colors in various formats (hex, RGB, HSL, HSV, and more), allowing you to perform operations like blending, interpolating, and manipulating color properties with ease.  Its compact size makes it ideal for inclusion in web projects without significantly impacting performance.\n\n### Why use Chroma.js?\n\nChroma.js offers several advantages over manually handling color calculations:\n\n* **Simplicity:** Its intuitive API makes color manipulation straightforward, even for complex operations.\n* **Efficiency:**  Chroma.js is optimized for performance, making it suitable for applications requiring many color calculations.\n* **Consistency:** It provides a unified way to handle colors regardless of their initial format.\n* **Cross-browser compatibility:** Chroma.js is designed to work seamlessly across different browsers.\n* **Extensive functionality:**  Beyond basic conversions, it provides functions for blending, interpolating, and generating color scales.\n\n### Setting up Chroma.js\n\nChroma.js can be easily integrated into your project using a variety of methods:\n\n* **Download:** Download the minified `chroma.min.js` file from the Chroma.js GitHub repository or CDN and include it in your HTML file using a `<script>` tag:\n\n```html\n<script src=\"chroma.min.js\"></script>\n```\n\n* **NPM:** If you're using npm, install it via:\n\n```bash\nnpm install chroma-js\n```\n\nThen, import it into your JavaScript file:\n\n\n```javascript\nimport chroma from 'chroma-js';\n```\n\n\n* **CDN:** You can also use a CDN like jsDelivr:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/chroma-js/chroma.min.js\"></script>\n```\n\n\nRemember to replace `\"chroma.min.js\"` with the actual path to the file if necessary.\n\n\n### Basic Usage Examples\n\nHere are some basic examples demonstrating Chroma.js's core functionality:\n\n**1. Creating a Chroma color:**\n\n```javascript\nlet color = chroma('#FF0000'); // Create a color from a hex string\nlet color2 = chroma('rgb(0, 255, 0)'); //Create a color from RGB values\nlet color3 = chroma('hsl(240, 100%, 50%)'); //Create a color from HSL values\n\nconsole.log(color.hex()); // Output: #ff0000\nconsole.log(color2.rgb()); // Output: [0, 255, 0]\nconsole.log(color3.hsl()); // Output: [240, 1, 0.5]\n\n```\n\n**2. Color manipulation:**\n\n```javascript\nlet color = chroma('#0000FF');\n\nlet lighterColor = color.brighten();\nlet darkerColor = color.darken();\n\nconsole.log(lighterColor.hex());\nconsole.log(darkerColor.hex());\n```\n\n\n**3. Color blending:**\n\n```javascript\nlet color1 = chroma('#FF0000');\nlet color2 = chroma('#0000FF');\nlet blendedColor = chroma.mix(color1, color2, 0.5); // Blend with a 50/50 ratio\n\nconsole.log(blendedColor.hex()); // Output: A purple color (depending on the blending method)\n```\n\nThese examples show how easily you can create, manipulate, and blend colors using Chroma.js.  Refer to the complete API documentation for a comprehensive list of available functions and methods.\n\n\n## Color Creation and Manipulation\n\n### Creating Colors from various inputs (Hex, RGB, HSL, etc.)\n\nChroma.js offers a flexible and consistent way to create color objects from various input formats.  The core `chroma()` function accepts a wide range of inputs:\n\n* **Hexadecimal strings:**  `chroma('#FF0000')`, `chroma('#f00')`\n* **RGB arrays:** `chroma([255, 0, 0])`\n* **RGB strings:** `chroma('rgb(255, 0, 0)')`\n* **HSL arrays:** `chroma([0, 1, 0.5])`\n* **HSL strings:** `chroma('hsl(0, 100%, 50%)')`\n* **HSV arrays:** `chroma([0, 1, 1])`\n* **HSV strings:** `chroma('hsv(0, 100%, 100%)')`\n* **Named colors:** `chroma('red')` (Note: Support for named colors might be limited; check the documentation for a complete list.)\n* **Number (Grayscale):** `chroma(0.5)` (Represents 50% gray)\n\n\nAll of these inputs will return a Chroma.js color object that can be further manipulated.\n\n\n### Converting between color spaces (RGB, HSL, HSV, LAB, etc.)\n\nChroma.js simplifies color space conversions.  Once you have a Chroma color object, you can easily get its representation in various color spaces using the following methods:\n\n* `.rgb()`: Returns an array representing the color in RGB [red, green, blue] (values 0-255).\n* `.rgba()`: Returns an array representing the color in RGBA [red, green, blue, alpha] (values 0-255, alpha 0-1).\n* `.hsl()`: Returns an array representing the color in HSL [hue, saturation, lightness] (hue 0-360, saturation and lightness 0-1).\n* `.hsv()`: Returns an array representing the color in HSV [hue, saturation, value] (hue 0-360, saturation and value 0-1).\n* `.lab()`: Returns an array representing the color in LAB [L, a, b] (L 0-100, a and b vary).\n* `.hex()`: Returns a hexadecimal string representation of the color (#RRGGBB).\n* `.css()`: Returns a CSS string representation of the color (e.g., 'rgb(255,0,0)', 'hsl(0,100%,50%)').\n\n\nFor example:\n\n```javascript\nlet color = chroma('#FF0000');\nconsole.log(color.rgb());     // Output: [255, 0, 0]\nconsole.log(color.hsl());     // Output: [0, 1, 0.5]\nconsole.log(color.hex());     // Output: #ff0000\nconsole.log(color.css());    // Output: rgb(255,0,0)\n```\n\n### Brightness, Saturation, and Hue adjustments\n\nChroma.js provides methods to easily adjust the brightness, saturation, and hue of a color:\n\n* `.brighten(amount)`: Increases the brightness of the color.  `amount` is a factor (e.g., 0.5 brightens by 50%).\n* `.darken(amount)`: Decreases the brightness of the color.\n* `.saturate(amount)`: Increases the saturation of the color.\n* `.desaturate(amount)`: Decreases the saturation of the color.\n* `.set(channel, value)`: Sets the value of a specific channel (e.g., 'rgb', 'hsl', etc.)\n* `.adjust([h,s,l])`: Adjusts Hue, Saturation, and Lightness at once.\n\n\nExample:\n\n```javascript\nlet color = chroma('#00FF00');\nlet brighterColor = color.brighten(0.2);\nlet moreSaturated = color.saturate(0.5);\nconsole.log(brighterColor.hex());\nconsole.log(moreSaturated.hex());\n\nlet adjustedColor = color.adjust([30, 0.2, -0.1]); //increases hue by 30, saturation by 20%, and decreases lightness by 10%\nconsole.log(adjustedColor.hex())\n\n```\n\n### Alpha manipulation\n\nChroma.js allows you to control the alpha (opacity) value of a color:\n\n* `.alpha(value)`: Sets the alpha value (0-1).\n* `.alpha()`: Gets the current alpha value.\n\nExample:\n\n```javascript\nlet color = chroma('#0000FF');\nlet semiTransparent = color.alpha(0.5);\nconsole.log(semiTransparent.rgba()); //Output will include an alpha value of 0.5\nconsole.log(semiTransparent.css()); //Output will include rgba values\n```\n\n### Clamping and limiting color values\n\nWhile Chroma.js generally handles color values appropriately, you might occasionally need to explicitly clamp or limit color component values.  This is not directly provided as a built-in function within the core Chroma.js API. You'd typically handle this using standard JavaScript `Math.min()` and `Math.max()` functions within your application's logic after obtaining the color values (RGB, HSL, etc.) from Chroma.js.  For example:\n\n```javascript\nlet color = chroma('rgb(300, 100, -50)'); // Example with out-of-range values\nlet rgb = color.rgb();\n\nlet clampedRGB = rgb.map(val => Math.max(0, Math.min(255, val))); //Clamp RGB values to 0-255\n\nconsole.log(clampedRGB);\n```\n\nThis ensures your color values remain within the valid ranges for the respective color spaces.\n\n\n## Color Scales and Palettes\n\n### Generating color scales\n\nChroma.js makes it easy to generate color scales using the `scale()` function.  You provide a starting and ending color, and the number of steps, and Chroma.js will generate a smoothly interpolated array of colors.  You can also specify a color scale scheme (e.g., 'YlOrRd', 'RdBu').  More details on predefined scales below.\n\n```javascript\nlet scale = chroma.scale(['red', 'blue']).colors(10); // Generate a 10-step scale from red to blue\nconsole.log(scale); // Output: Array of 10 hex color strings\n\nlet scale2 = chroma.scale('cool').colors(5); // Generates 5 colors from the 'cool' scheme\nconsole.log(scale2);\n\nlet scale3 = chroma.scale(['#000', '#fff']).mode('lab').colors(8); //Use lab color space for smoother interpolation\nconsole.log(scale3)\n```\n\nYou can also pass a function to `scale()` for more complex scales:\n\n```javascript\n// A function that will generate rainbow colors\nlet rainbowScale = chroma.scale(x => chroma.hsl(x * 360, 1, 0.5)).colors(10);\nconsole.log(rainbowScale)\n```\n\n\n### Predefined color scales\n\nChroma.js includes a number of predefined color scales, based on colorbrewer2.org and other sources.  These scales are designed for various purposes and offer perceptually uniform color transitions.  You can access them by name (e.g., 'viridis', 'magma', 'plasma', 'inferno', 'cividis', 'RdBu', 'YlOrRd', 'Greens', etc.).  Refer to the Chroma.js documentation or examples for the complete list and their visual representations.\n\n```javascript\nlet scale = chroma.scale('viridis').colors(5); //Using the predefined 'viridis' scale\nconsole.log(scale)\n```\n\n\n### Customizing color scales\n\nYou can customize the behavior of color scales by using the various options available within `chroma.scale()`.  For example, you can specify the `mode` for color space interpolation (`'rgb'`, `'lab'`, `'hsl'`, `'hsv'`), affecting the visual quality and perceived uniformity.  The `domain` option allows you to set the input range for the scale, which is helpful when mapping data values to colors.\n\n```javascript\nlet scale = chroma.scale(['blue', 'green', 'yellow', 'red']).domain([0,100]).colors(5);\n// Generates 5 colors interpolated between blue, green, yellow, and red based on a 0 to 100 domain.\n\nlet labScale = chroma.scale(['blue', 'green']).mode('lab').colors(10); //Use lab interpolation\nconsole.log(labScale);\n```\n\n\n### Interpolating colors\n\nChroma.js provides `interpolate()` for creating a color at a specific point along a scale.   This function is also implicitly used within `colors()` method of the scale object.\n\n\n```javascript\nlet scale = chroma.scale(['red', 'blue']);\nlet interpolatedColor = scale(0.5); // Color halfway between red and blue\nconsole.log(interpolatedColor.hex()); // Output: A purple hex code\n\nlet interpolatedColor2 = scale(0.75).hex();\nconsole.log(interpolatedColor2);\n```\n\nThe input to `scale()` is a normalized value between 0 and 1 (inclusive). You can easily map your data (in any numerical range) into that space before passing it to the function.\n\n### Working with palettes\n\nWhile not explicitly defined as a separate \"palette\" object, the result of `chroma.scale().colors()` effectively acts as a color palette.  You can store the returned array of color strings or objects for later use in your application, for example, to assign colors to chart segments, map features, etc.\n\n```javascript\nlet myPalette = chroma.scale('Spectral').colors(7); //Create a 7 color palette based on spectral scale\n\n//Use myPalette to color chart elements, map elements, or any visual elements.\n```\n\n\n## Color Comparisons and Differences\n\n### Calculating color difference (Delta E)\n\nChroma.js allows you to calculate the perceptual difference between two colors using the Delta E (ΔE) metric.  Delta E quantifies the difference in color appearance, taking into account human perception.  A smaller Delta E value indicates a smaller perceived difference. Chroma.js uses the CIE76 formula by default, but can also calculate using the more accurate CIE94 and CMC formulas by specifying the appropriate method in the `deltaE()` method.\n\n```javascript\nlet color1 = chroma('#FF0000');\nlet color2 = chroma('#FF0000');\nlet color3 = chroma('#0000FF');\n\nlet deltaE76 = color1.deltaE(color2, '76'); // Default method\nlet deltaE94 = color1.deltaE(color3, '94'); // Using CIE94\nlet deltaECMC = color1.deltaE(color3, 'cmc'); // Using CMC\n\nconsole.log(\"Delta E (CIE76):\", deltaE76); // Output: A very small number close to 0\nconsole.log(\"Delta E (CIE94):\", deltaE94); // Output: A larger number representing a greater difference\nconsole.log(\"Delta E (CMC):\", deltaECMC); // Output: A larger number representing a greater difference\n```\n\nNote that different Delta E formulas will yield different numerical results; however, the relative differences between color pairs should remain consistent regardless of chosen formula.\n\n\n### Comparing color similarity\n\nWhile not a direct function, you can use the Delta E value to determine the similarity of two colors.  A lower Delta E value indicates greater similarity.  You can define a threshold based on your application's requirements to determine if two colors are considered \"similar\" enough.\n\n```javascript\nlet color1 = chroma('#FF0000');\nlet color2 = chroma('#FF1100');\nlet threshold = 5; // Example threshold\n\nlet deltaE = color1.deltaE(color2);\n\nif (deltaE < threshold) {\n  console.log(\"Colors are similar\");\n} else {\n  console.log(\"Colors are different\");\n}\n```\n\n### Finding complementary and analogous colors\n\nChroma.js doesn't have built-in functions specifically labeled \"complementary\" or \"analogous.\"  However, you can easily calculate these using color space manipulations.\n\n\n* **Complementary colors:**  Complementary colors are located directly opposite each other on the color wheel (hue difference of approximately 180 degrees).  For HSL or HSV colors, you can calculate the complement by adding 180 to the hue, wrapping around 360 if necessary:\n\n```javascript\nlet color = chroma('#FF0000'); //Red\nlet hsl = color.hsl();\nlet complementaryHue = (hsl[0] + 180) % 360;\nlet complementaryColor = chroma.hsl(complementaryHue, hsl[1], hsl[2]);\nconsole.log(complementaryColor.hex()); //Output: Cyan (approximately)\n```\n\n* **Analogous colors:** Analogous colors are located next to each other on the color wheel (small hue differences). You can obtain analogous colors by adding or subtracting a small value from the hue:\n\n```javascript\nlet color = chroma('#FF0000');\nlet hsl = color.hsl();\nlet analogousColor1 = chroma.hsl((hsl[0] + 30) % 360, hsl[1], hsl[2]); //Slightly more orange\nlet analogousColor2 = chroma.hsl((hsl[0] - 30 + 360) % 360, hsl[1], hsl[2]); //Slightly more purple\nconsole.log(analogousColor1.hex(), analogousColor2.hex());\n```\n\nRemember to adjust the added/subtracted hue value to control the distance between analogous colors.  You may also need to adjust saturation and lightness for desired results.\n\n\n## Advanced Techniques\n\n### Blending colors\n\nChroma.js offers several ways to blend colors:\n\n* **`chroma.mix(color1, color2, weight, mode)`:** This is the primary blending function.  `color1` and `color2` are Chroma color objects. `weight` is a number between 0 and 1 representing the proportion of `color2` in the blend (0 means only `color1`, 1 means only `color2`).  `mode` is an optional parameter that specifies the blending method; common options include:\n\n    * `'lrgb'` (linear RGB): A simple average of RGB values. This is the default.\n    * `'lab'` (CIELAB):  Perceptually uniform blending in CIELAB color space.  Often produces more natural-looking results.\n    * `'hsv'` (HSV): Blending in the HSV color space.\n    * `'hsl'` (HSL): Blending in the HSL color space.\n\n\n```javascript\nlet color1 = chroma('#FF0000');\nlet color2 = chroma('#0000FF');\n\nlet blendedLRGB = chroma.mix(color1, color2, 0.5, 'lrgb');\nlet blendedLAB = chroma.mix(color1, color2, 0.5, 'lab');\n\nconsole.log(blendedLRGB.hex());\nconsole.log(blendedLAB.hex());\n```\n\n* **`chroma.blend(color1, color2, weight, mode)`:**  Similar to `mix`, this function provides the same functionality with a slightly different naming scheme.\n\nThe choice of blending mode significantly impacts the result. Experiment to find the mode best suited to your needs.\n\n\n### Color quantization\n\nColor quantization reduces the number of colors in an image or dataset.  Chroma.js doesn't directly perform image quantization, but you can use its color manipulation capabilities in conjunction with other libraries (like those for image processing) to achieve this.  A basic approach involves iterating through pixels, calculating their dominant color using averaging or clustering methods, and then mapping them to a reduced palette generated with Chroma.js's `scale()` function.\n\n```javascript\n//Illustrative example, requires external image processing library\n//This is a simplified example, a real application would require a proper image processing library\nconst palette = chroma.scale(['red', 'green', 'blue']).colors(3); //Create a 3-color palette\n\n//Simulate pixel data; replace with actual pixel data from your image\nconst pixelData = [\n  [200, 100, 50],\n  [100, 200, 50],\n  [50, 100, 200]\n]\n\n\nconst quantizedPixels = pixelData.map(pixel => {\n  //Find closest color in the palette (simplified example, would use a more sophisticated algorithm)\n  let closestColor = palette[0]\n\n  return closestColor;\n})\nconsole.log(quantizedPixels);\n```\n\n\n### Working with images\n\nChroma.js primarily focuses on color manipulation. Direct image processing isn't a core feature. To work with images, you'll need to use a separate image processing library (like a canvas-based library or a dedicated image manipulation library) to load, access pixel data, and then use Chroma.js to process the colors of the individual pixels.\n\n\n### Custom color spaces\n\nChroma.js doesn't directly support defining entirely new custom color spaces.  Its strength lies in its handling of common color spaces (RGB, HSL, HSV, LAB).  However, you can extend its functionality by creating custom functions to perform transformations between a new color model and one of Chroma.js's supported spaces.  These functions would handle conversions to and from, for example, RGB, allowing you to work with your custom color space indirectly.  This would involve implementing your own conversion algorithms.\n\n\n## Utilities and Helper Functions\n\n### Formatting and parsing colors\n\nChroma.js provides several helper functions for working with color formats:\n\n* **`chroma.hex(color)`:** Converts a color (Chroma object or compatible input) to its hexadecimal string representation (#RRGGBB).\n* **`chroma.rgb(color)`:** Converts a color to an RGB array [r, g, b].\n* **`chroma.hsl(color)`:** Converts a color to an HSL array [h, s, l].\n* **`chroma.hsv(color)`:** Converts a color to an HSV array [h, s, v].\n* **`chroma.lab(color)`:** Converts a color to an LAB array [l, a, b].\n* **`chroma.gl(color)`:** Converts a color to an array suitable for WebGL [r, g, b, a] (values are between 0 and 1).\n* **`chroma.css(color)`:** Returns a CSS color string (e.g., 'rgb(255, 0, 0)', '#f00').  This will pick the shortest possible representation.\n\nThese functions provide a convenient way to get a specific color format from a Chroma color object or any valid Chroma color input.  They handle the conversion automatically.\n\nExample:\n\n```javascript\nlet color = chroma('#FF0000');\nconsole.log(chroma.hex(color));      // Output: #ff0000\nconsole.log(chroma.rgb(color));      // Output: [255, 0, 0]\nconsole.log(chroma.hsl(color));      // Output: [0, 1, 0.5]\nconsole.log(chroma.css(color));     // Output: #f00\nconsole.log(chroma.gl(color));     // Output: [1, 0, 0, 1]\n```\n\n### Working with color strings\n\nChroma.js inherently handles various color string formats as input to the `chroma()` function and its conversion methods. However, there isn't a dedicated set of functions solely for manipulating color strings beyond what's available via conversion functions described above. If you have more complex string parsing tasks involving color codes, you might need to use standard JavaScript string manipulation functions (`split`, `substring`, `parseInt`, etc.).\n\n\n### Other utility functions\n\nBesides color formatting and parsing, Chroma.js provides other useful functions:\n\n* **`chroma.valid(color)`:** Checks if the provided input is a valid color representation (string or array).  Returns `true` or `false`.\n\n* **`chroma.contrast(color1, color2)`:**  Calculates the contrast ratio between two colors, helpful for accessibility considerations. The result is a number indicating the contrast level. A higher number means better contrast.  WCAG guidelines often recommend contrast ratios above 4.5:1 for sufficient contrast between text and background colors.\n\n```javascript\nlet color1 = chroma('#000');\nlet color2 = chroma('#fff');\nlet contrastRatio = chroma.contrast(color1, color2);\nconsole.log(contrastRatio); // Output: A number representing the contrast ratio\n```\n\n* **`chroma.distance(color1, color2)`:** Calculates the Euclidean distance between two colors in a specified color space (defaults to LAB). It is similar to calculating Delta E but doesn't represent the perceptual difference in the same way.\n\n\nThese utility functions offer additional support for common color-related tasks beyond color creation and manipulation.  They enhance the usability and efficiency of Chroma.js in your projects.\n\n\n## Best Practices and Common Pitfalls\n\n### Performance considerations\n\nWhile Chroma.js is generally performant, keep these points in mind for optimal performance, especially when dealing with large numbers of color calculations:\n\n* **Minimize unnecessary calculations:** Avoid redundant calls to Chroma.js functions. If you need a color's RGB value multiple times, calculate it once and store the result in a variable.\n* **Use efficient color spaces:** For operations like blending or interpolation, consider using perceptually uniform color spaces like LAB to achieve more natural-looking and efficient results.  Avoid switching repeatedly between different color spaces unless necessary.\n* **Batch operations:** When processing a large array of colors, process them in batches or use array methods like `map` to avoid creating many intermediate objects, improving performance.\n* **Avoid unnecessary object creation:** If performance is critical, you might consider working directly with arrays of color components (RGB, HSL, etc.) instead of creating numerous Chroma color objects.  While less convenient, this approach can be significantly faster for very large datasets.\n* **Caching:** For very performance sensitive applications, you might consider caching results, especially if you are performing the same calculation on the same color or color set multiple times.\n\n\n### Error handling and debugging\n\nChroma.js generally handles invalid color inputs gracefully. However, it is good practice to include checks to ensure that your inputs are indeed valid color representations.  The `chroma.valid(color)` function can help in this.\n\nFor debugging, standard JavaScript debugging tools can be used.  Console logging of intermediate values (color components, results of calculations) can be helpful in identifying the source of errors or unexpected behavior.\n\n\n### Common mistakes and solutions\n\n* **Incorrect color space:** Using the wrong color space for a particular operation can lead to unexpected results.  Remember that different color spaces have different properties, and what might be a simple operation in one space could be complex in another. For example, linear interpolation in RGB might not produce visually smooth transitions, while LAB often yields much better results for perceptual uniformity.\n* **Alpha value handling:** When blending colors or applying transparency, ensure you correctly handle the alpha channel (opacity).  Incorrect alpha handling can result in unexpected colors or visual artifacts.\n* **Out-of-range values:**  Always ensure that color components (RGB, HSL, etc.) are within their valid ranges (0-255 for RGB components, 0-1 for saturation and lightness in HSL, etc.).  Values outside these ranges might lead to errors or unexpected color outputs.  You can use JavaScript's `Math.min()` and `Math.max()` functions to clamp values to their valid ranges.\n* **Overlooking color space conversions:**  When performing operations involving colors from different sources or formats, be mindful of the color space of each color. You might need to explicitly convert colors to a common space before performing operations. For example, if blending hex and HSL colors, first convert both to the same color space (like LAB) before blending.\n* **Misinterpreting Delta E:** Remember that Delta E values provide a relative measure of color difference.  The absolute value doesn't have a direct, universally consistent interpretation; only the comparative differences between pairs of Delta E values is meaningful.  Choosing the appropriate Delta E formula (CIE76, CIE94, or CMC) is also important.\n\n\n\nBy avoiding these common pitfalls and following the best practices, you can effectively use Chroma.js to perform robust and efficient color manipulations in your applications.\n\n\n## Appendix\n\n### Glossary of terms\n\n* **Color Space:** A mathematical model that describes the range of colors that can be represented.  Examples include RGB, HSL, HSV, LAB.\n* **RGB:** Red, Green, Blue – an additive color model where colors are created by combining different intensities of red, green, and blue light.\n* **HSL:** Hue, Saturation, Lightness – a color model that uses hue (color), saturation (intensity), and lightness (brightness) to represent colors.\n* **HSV:** Hue, Saturation, Value – similar to HSL, but uses \"value\" instead of \"lightness,\" representing the maximum intensity of the color.\n* **LAB:**  CIELAB – a perceptually uniform color space designed to approximate human color perception more accurately than RGB.\n* **Delta E (ΔE):** A metric that quantifies the perceived difference between two colors.  Smaller values indicate greater similarity.  Different formulas exist (CIE76, CIE94, CMC) with varying levels of accuracy.\n* **Hue:**  The pure color (e.g., red, green, blue).\n* **Saturation:** The intensity or purity of a color.  High saturation means a vivid color, while low saturation is closer to gray.\n* **Lightness/Value:**  The brightness or intensity of a color.\n* **Color Quantization:**  Reducing the number of colors used in an image or dataset.\n* **Perceptually Uniform:** A color space where small numerical differences correspond to approximately equal perceived differences in color.\n\n\n### List of color spaces\n\nChroma.js supports conversions between several color spaces:\n\n* RGB (Red, Green, Blue)\n* RGBA (Red, Green, Blue, Alpha)\n* HSL (Hue, Saturation, Lightness)\n* HSV (Hue, Saturation, Value)\n* LAB (CIELAB)\n* XYZ (CIE XYZ)\n* Luv (CIE Luv)\n\n\n### Chroma.js API reference\n\n(Note:  A comprehensive API reference would be too extensive for this context.  A real developer manual would include a detailed API listing with descriptions of all functions, parameters, and return values. This is a placeholder.)\n\n\nThe Chroma.js API includes functions for:\n\n* **Color Creation:** Creating color objects from various input types (hex, RGB, HSL, etc.).\n* **Color Conversion:** Converting between different color spaces (RGB, HSL, HSV, LAB, etc.).\n* **Color Manipulation:** Adjusting brightness, saturation, hue, and alpha.\n* **Color Blending:** Mixing two colors with different weights and blending modes.\n* **Color Scales:** Generating and customizing color scales.\n* **Color Comparison:** Calculating color difference using Delta E.\n* **Utility Functions:**  Formatting colors, parsing color strings, and other helper functions.\n\n\nConsult the official Chroma.js documentation for the complete and up-to-date API reference.\n\n\n### Contributing to Chroma.js\n\n(Note:  This section should link to the project's contribution guidelines on GitHub or a similar platform.)\n\nIf you're interested in contributing to Chroma.js, please refer to the project's contribution guidelines on [GitHub Link].  Contributions are welcome, including bug fixes, new features, improved documentation, and performance optimizations.  Before submitting a pull request, ensure you follow the project's coding style and testing procedures.  Your contributions will help improve Chroma.js for the benefit of all users.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["../../styles.css"],"html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"},"include-in-header":["../../favicon.html","../../header.html","../../schema.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"},"../../footer.html"],"output-file":"chromajs.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.8.25","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"license":"MIT","author-meta":"Muthukrishnan","title":"Chroma.js - Documentation","description":"Chroma.js is a small, fast, and easy-to-use JavaScript library for color manipulation and conversion. It provides a simple and consistent API for working...","date":"2025-02-09","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}