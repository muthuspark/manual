{"title":"SortableJS - A Developer's Handbook","markdown":{"yaml":{"title":"SortableJS - A Developer's Handbook","categories":["JavaScript Libraries and Functions"]},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n### What is SortableJS?\n\nSortableJS is a minimalist JavaScript library for reorderable drag-and-drop lists on modern browsers and touch devices.  It provides a simple yet powerful API for creating highly customizable sortable interfaces without the need for complex configuration or extensive boilerplate code.  It focuses on performance and ease of use, making it ideal for a wide range of applications, from simple task lists to complex drag-and-drop interfaces within larger applications.  Unlike many other drag-and-drop libraries, SortableJS avoids unnecessary dependencies, keeping its footprint small and efficient.\n\n\n### Key Features and Benefits\n\n* **Lightweight and performant:** SortableJS has a small file size and is optimized for speed, ensuring a smooth user experience even with large lists.\n* **Cross-browser compatibility:** It works seamlessly across major modern browsers and touch devices.\n* **Simple API:**  The API is intuitive and easy to learn, allowing developers to quickly integrate sortable functionality into their projects.\n* **Extensible:**  SortableJS offers various options and events for extensive customization.\n* **No dependencies:** It doesn't rely on any other JavaScript libraries, simplifying integration and reducing potential conflicts.\n* **Touch support:** Built-in support for touch devices ensures a consistent experience across platforms.\n* **Multiple groups:**  Easily support dragging items between multiple sortable lists.\n\n\n### Getting Started: Installation and Setup\n\nSortableJS can be installed in several ways:\n\n* **CDN:** Include the SortableJS script directly from a CDN like jsDelivr:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js\"></script>\n```\n\n* **npm:** If you're using npm, install it via:\n\n```bash\nnpm install sortablejs\n```\n\nThen, import it into your JavaScript code:\n\n```javascript\nimport Sortable from 'sortablejs';\n```\n\n* **Yarn:**  If you are using Yarn, install with:\n\n```bash\nyarn add sortablejs\n```\n\nThen, import it into your JavaScript code:\n\n```javascript\nimport Sortable from 'sortablejs';\n```\n\n\nAfter installation, you're ready to start using SortableJS.\n\n\n### Basic Usage Example\n\nThis example demonstrates a simple sortable list:\n\n```html\n<ul id=\"my-list\">\n  <li>Item 1</li>\n  <li>Item 2</li>\n  <li>Item 3</li>\n</ul>\n\n<script>\n  new Sortable(document.getElementById('my-list'));\n</script>\n```\n\nThis code snippet initializes SortableJS on the `<ul>` element with the ID `my-list`.  This makes the list items draggable and re-orderable.  No further configuration is needed for basic functionality.  More advanced options and event handling are detailed in subsequent sections of this manual.\n\n\n## Core Concepts\n\n### Understanding SortableJS Elements\n\nSortableJS operates on a fundamental level by targeting HTML elements to enable drag-and-drop functionality. The core element is typically an unordered list (`<ul>`) or an ordered list (`<ol>`), though any element can technically be used.  The child elements of this container (e.g., `<li>` elements within a `<ul>`) are the items that are sortable.  SortableJS manipulates the DOM structure directly to reflect the changes in item order.  No hidden data structures are used; the visual order always reflects the actual order of the elements.  You can use attributes and data attributes on these elements to further customize the behavior and associate data with each sortable item.\n\n\n### Groups and Sorting\n\nSortableJS supports sorting items within a single list and also allows you to drag items between multiple lists.  This is achieved through the concept of \"groups\".  Items belonging to the same group can be freely dragged and dropped between each other.  Different groups can be defined using the `group` option.  If items belong to different groups, restrictions on dragging between them might be enforced, or you may choose to allow transfers between any groups by specifying a wildcard group (e.g., `group: { name: 'shared', pull: 'clone', put: false }`).  This gives you great flexibility in managing the interaction between multiple sortable lists.  The `pull` and `put` options within a group control whether items can be dragged *from* and *into* a specific list respectively.\n\n\n### Events and Callbacks\n\nSortableJS provides a rich set of events that allow you to respond to various actions during the drag-and-drop process.  These events are triggered at different stages:  `start`, `sort`, `update`, `remove`, `add`, `choose`, `unchoose`, `stop`, `clone`.  Each event provides relevant data, such as the item being dragged, its source and destination lists, and the old and new indices. You can attach custom callback functions to these events to perform actions like updating a database, saving state, or providing visual feedback to the user.   For example, the `update` event is fired whenever the order of items changes, allowing you to immediately update associated data structures.  Consult the documentation for a complete list of events and their parameters.\n\n\n### Data Transfer and Manipulation\n\nWhile SortableJS primarily focuses on DOM manipulation, it doesn't directly handle data transfer.  The library handles the visual rearrangement of items.  You are responsible for managing the associated data. You can achieve this using various techniques:\n\n* **Data Attributes:** Store data directly on the sortable items using HTML5 data attributes (`data-*`).  You can then access this data within the event callbacks to update your application's state.\n* **External Data Structures:** Maintain a separate data structure (e.g., an array or object) that mirrors the order of the sortable items.  Update this data structure within the `update`, `add`, and `remove` events.\n* **Data Binding:** Utilize a framework (like React, Vue, or Angular) that provides data binding capabilities.  This simplifies keeping your data structure synchronized with the visual order of the items.\n\nEssentially, SortableJS provides the drag-and-drop interface, but you're in control of how you handle and manage the data associated with the moved items.  The library empowers you to build dynamic interfaces synchronized with your application's data.\n\n\n## API Reference\n\n### Constructor Options\n\nThe SortableJS constructor accepts an options object as its second argument.  These options control various aspects of the sortable behavior.  Key options include:\n\n* **`group`:**  (String or Object) Defines the group to which the sortable belongs.  Items can only be dragged between lists belonging to the same group.  A group object can define `name`, `put`, and `pull` properties for finer control over dragging between lists.\n* **`animation`:** (Integer) Duration of the animation (in milliseconds) when items are moved.  Set to `0` to disable animation.\n* **`handle`:** (String or Function)  Specifies the element within each item that should be used as the drag handle.  This can be a CSS selector string or a function that returns a boolean indicating whether an element is a valid handle.\n* **`draggable`:** (String or Function) Specifies which items are draggable.  Similar to `handle`, this can be a CSS selector string or a function.\n* **`ghostClass`:** (String)  CSS class applied to the placeholder that visually indicates the position where the dragged item will be inserted.\n* **`chosenClass`:** (String) CSS class applied to the currently dragged item.\n* **`dataIdAttr`:** (String)  Attribute used to retrieve item ID for data transfer.\n* **`sort`:** (Boolean) Whether sorting is enabled.  Setting to `false` disables drag-and-drop.\n* **`delay`:** (Integer) Delay in milliseconds before the drag starts.  Useful to avoid accidental drags.\n* **`forceFallback`:** (Boolean) Forces the use of the fallback method (using a cloned element for dragging). Useful for improved compatibility with older browsers.\n* **`fallbackOnBody`:** (Boolean) Append the placeholder to the document body instead of the parent of the dragged element.  Can improve the dragging experience in complex layouts.\n* **`store`:** (Object) Enables persisting the sorting order across sessions.\n* **`filter`:** (String or Function)  Allows filtering the draggable items based on a CSS selector string or a custom function.\n* **`preventOnFilter`:** (Boolean) Whether to prevent dragging if an item matches the `filter` criteria.\n* **`onMove`:** (Function) Function triggered when an item is being moved.\n* **`onAdd`:** (Function) Function triggered when an item is added to the list.\n* **`onUpdate`:** (Function) Function triggered when the order of items changes.\n\nConsult the official documentation for the full list of options and their descriptions.\n\n\n### Methods: `sort`, `destroy`, `option`, etc.\n\nSortableJS provides several methods to interact with the instance:\n\n* **`sort(element, target, newIndex)`:**  Manually sorts an item.\n* **`destroy()`:**  Removes SortableJS from the element, restoring the original behavior.\n* **`option(optionName, value)`:**  Gets or sets the value of a constructor option.\n* **`serialize(options)`:**  Serializes the items into an array of their data IDs.\n* **`toArray()`:** Returns an array of the elements' IDs.\n* **`save()`:** Saves the current sort to the store.\n\n\n### Events: `sort`, `remove`, `add`, `update`, etc.\n\nSortableJS exposes a range of events that allow you to react to various stages of the drag-and-drop process:\n\n* **`sort`:**  Triggered when the item's position changes.\n* **`remove`:**  Triggered when an item is removed from the list.\n* **`add`:**  Triggered when an item is added to the list.\n* **`update`:** Triggered when the order of items changes.\n* **`start`:**  Triggered when a drag operation begins.\n* **`stop`:**  Triggered when a drag operation ends.\n* **`choose`:** Triggered when an item is chosen for dragging.\n* **`unchoose`:** Triggered when the chosen item is released (without being dropped).\n* **`clone`:**  Triggered when an item is cloned (if cloning is enabled).\n* **`filter`:** Triggered when a drag-and-drop operation is filtered.\n* **`move`:**  Triggered when a potential move is in progress.\n\nEach event provides an event object containing details of the event, such as the old and new indices of the item, the item itself, and related elements.\n\n\n### Event Handling and Customizations\n\nEvent handling is done by attaching listeners to the SortableJS instance using the `on` method:\n\n```javascript\nlet sortable = new Sortable(list, { /* options */ });\n\nsortable.on('update', function (evt) {\n  // Handle the update event\n  console.log('Order updated:', evt.oldIndex, evt.newIndex);\n});\n```\n\nThis approach allows you to respond to specific events and perform custom actions.  You can combine the events and options to build complex and highly customized drag-and-drop interfaces. Remember to consult the full API documentation for a complete list of available options and events and their specific parameters.\n\n\n## Advanced Techniques\n\n### Handling Nested Sortables\n\nSortableJS supports nested sortable lists.  This means you can have sortable lists within other sortable lists, creating hierarchical structures.  To achieve this, you need to create multiple Sortable instances, one for each level of nesting.  Be mindful of the `group` option when working with nested sortables.  If you want items to be freely moved between different levels of nesting, ensure that the relevant lists share the same group name.  However, if you want to restrict movement between levels, use different group names.  Properly managing group names is crucial for controlling the allowed drag-and-drop interactions within your nested structures.  Within event handlers, you can examine the `oldDraggableIndex` and `newDraggableIndex` properties to understand where an item has been moved to relative to its original position.\n\n### Implementing Drag Handles and Placeholders\n\nBy default, SortableJS allows dragging items by clicking and dragging anywhere on the item itself. However, you can customize this behavior to allow dragging only from specific elements (drag handles) using the `handle` option. This option accepts either a CSS selector string or a function that returns `true` if an element is a valid handle.   The `ghostClass` option controls the visual appearance of the placeholder that indicates where the dragged item will be inserted.  You can style this placeholder using CSS to create a visually appealing drag-and-drop experience.  Customizing the appearance of the drag handle and placeholder improves user experience by providing visual cues and clarity during the drag-and-drop interaction.\n\n### Customizing Animations and Transitions\n\nSortableJS allows you to control the animation of items during dragging and dropping using the `animation` option. This option specifies the duration of the animation in milliseconds. Setting it to `0` disables animations entirely.  For more advanced animation control,  you can leverage CSS transitions and animations in conjunction with the `chosenClass` and `ghostClass` options.  This gives you fine-grained control over the visual aspects of the drag-and-drop process, allowing you to create smooth and visually appealing transitions.  Remember that excessive or complex animations can impact performance, particularly with large lists, so choose appropriate animation styles to optimize the user experience.\n\n### Integrating with Other Libraries\n\nSortableJS is designed to be lightweight and non-intrusive, making it easy to integrate with other JavaScript libraries.  However, care must be taken to avoid conflicts.  Potential conflicts could arise if other libraries manipulate the DOM in ways that interfere with SortableJS's internal mechanisms.  If you're using a framework such as React, Vue, or Angular, you'll typically need to manage data synchronization manually, ensuring that changes in the DOM reflected by SortableJS are mirrored in your framework's data model.  When integrating with other drag-and-drop libraries, ensure they don't operate on the same elements to avoid conflicts and unexpected behavior.  Testing thoroughly is crucial to ensure seamless integration and identify any potential conflicts between libraries.\n\n\n## Troubleshooting\n\n### Common Issues and Solutions\n\n* **Items not draggable:**  Double-check that you've included the SortableJS script correctly and that you've initialized SortableJS on the correct element.  Ensure that the element you're targeting is actually in the DOM when the script runs.  Verify that CSS styles aren't accidentally preventing dragging (e.g., `pointer-events: none;`). If using a `handle` or `draggable` option, make sure your selectors or functions are correctly identifying the draggable elements.\n\n* **Unexpected behavior with nested lists:**  Ensure that the `group` option is correctly configured for nested lists.  Incorrect group settings can lead to unexpected drag-and-drop restrictions.  Carefully examine the nested structure to ensure that you've initialized SortableJS on each nested list correctly.\n\n* **Animations not working:** Verify that the `animation` option is set to a value greater than 0. Ensure that there are no CSS rules overriding the default animation styles applied by SortableJS.\n\n* **Data not updating correctly:** This usually indicates a problem in your event handling logic.  Double-check that you are correctly accessing and updating your data within the relevant event handlers (e.g., `update`, `add`, `remove`). Ensure your data update logic correctly reflects the changes made by SortableJS.\n\n* **Conflicts with other libraries:**  If you encounter conflicts with other JavaScript libraries, try disabling other libraries temporarily to isolate the problem.   Ensure that no other script is manipulating the same DOM elements concurrently with SortableJS.\n\n\n### Debugging Strategies\n\n* **Console logging:**  Use `console.log()` statements within your event handlers to track the values of relevant variables and the sequence of events.  This helps identify inconsistencies in data or unexpected event flows.\n\n* **Browser developer tools:** Utilize your browser's developer tools (usually accessed by pressing F12) to inspect the DOM structure, network requests, and console messages.  This is crucial for identifying DOM manipulation conflicts or unexpected behavior within SortableJS.  The debugger can be used to step through the code and identify the point of failure.\n\n* **Simplifying the code:**  Try temporarily removing or simplifying parts of your code to isolate the source of the problem.  Creating a minimal reproducible example can assist in identifying the root cause.\n\n\n### Performance Optimization\n\n* **Minimize animations:**  Excessive or complex animations can significantly impact performance, especially with large lists.  Consider simplifying or disabling animations if performance becomes an issue.\n\n* **Optimize DOM manipulation:** Avoid unnecessary DOM manipulation within event handlers, as this can lead to performance degradation.  Batch updates whenever possible.\n\n* **Use virtualization techniques:** For very large lists, consider using virtualization techniques to render only the visible items.  This can significantly improve rendering performance.\n\n* **Avoid heavy CSS:** Overly complex CSS styles can affect performance.  Ensure that your CSS selectors are efficient and that you're not unnecessarily applying styles to a large number of elements.  Consider using CSS preprocessors (like Sass or Less) to optimize your CSS.\n\n* **Profile your code:**  Use your browser's performance profiling tools to identify performance bottlenecks within your code.  This helps pinpoint areas where optimization efforts will have the greatest impact.\n\n\n## Examples and Use Cases\n\n### Simple List Sorting\n\nThis is the most basic use case.  You can create a simple sortable list with minimal code:\n\n```html\n<ul id=\"my-list\">\n  <li>Item 1</li>\n  <li>Item 2</li>\n  <li>Item 3</li>\n</ul>\n\n<script>\n  new Sortable(document.getElementById('my-list'));\n</script>\n```\n\nThis code makes the list items draggable and reorderable.  The `update` event can be used to capture the new order of items and update your application's data accordingly.\n\n\n### Drag-and-Drop File Uploads\n\nSortableJS can enhance file upload functionality by allowing users to reorder files before uploading.  This involves combining SortableJS with an HTML file input element:\n\n```html\n<input type=\"file\" id=\"file-upload\" multiple>\n<ul id=\"file-list\"></ul>\n\n<script>\n  const fileList = document.getElementById('file-list');\n  const fileUpload = document.getElementById('file-upload');\n\n  fileUpload.addEventListener('change', (e) => {\n    for (let file of e.target.files) {\n      let li = document.createElement('li');\n      li.textContent = file.name;\n      fileList.appendChild(li);\n    }\n    new Sortable(fileList); // Initialize SortableJS after adding files\n  });\n\n  // Handle the 'update' event to get the reordered file list\n</script>\n```\n\nThis example adds file names to a list as they are selected, and SortableJS enables reordering. You would then need to handle the updated order in the upload process.\n\n\n### Kanban Board Implementation\n\nA Kanban board is a common use case for sortable lists.  You can represent columns as separate sortable lists and allow users to drag tasks between columns:\n\n```html\n<div class=\"kanban-column\">\n  <h3>To Do</h3>\n  <ul id=\"to-do-list\">\n    <li>Task 1</li>\n    <li>Task 2</li>\n  </ul>\n</div>\n<div class=\"kanban-column\">\n  <h3>In Progress</h3>\n  <ul id=\"in-progress-list\"> </ul>\n</div>\n\n<script>\n  const todoList = new Sortable(document.getElementById('to-do-list'), { group: 'kanban' });\n  const inProgressList = new Sortable(document.getElementById('in-progress-list'), { group: 'kanban' });\n</script>\n```\n\nHere, both lists share the `kanban` group, allowing items to be dragged between them.  You would need to add more columns and handle the data updates reflecting the task movements.\n\n\n### Advanced Drag-and-Drop Interactions\n\nSortableJS allows for highly customized drag-and-drop behaviors.  This includes:\n\n* **Custom drag handles:** Use the `handle` option to specify elements that act as drag handles.\n* **Filtering draggable items:** Use the `filter` option to restrict which items are draggable.\n* **Cloning items:** Use the `group` option with `pull: 'clone'` to create copies of items when dragging them to a different list.\n* **Custom animations and transitions:**  Use CSS and the `animation` option to customize the visual appearance of the drag-and-drop operation.\n* **Multiple groups and complex group configurations:**  Create more complex interactions by using multiple groups with custom `put` and `pull` settings.  You can define complex rules about which groups allow dragging from and into them.\n\nThese advanced features allow you to create highly customized and sophisticated drag-and-drop interfaces tailored to specific application needs.  Combining these techniques with appropriate event handling creates a powerful and flexible drag-and-drop system.\n\n\n## Contributing\n\n### Reporting Bugs\n\nWhen reporting bugs, please provide as much detail as possible to help us reproduce and fix the issue.  A minimal reproducible example is highly valuable.  Include the following information:\n\n* **SortableJS version:** Specify the exact version number you're using.\n* **Browser and operating system:**  State the browser and operating system you encountered the bug on.\n* **Steps to reproduce:**  Provide clear and concise steps to reproduce the bug.\n* **Expected behavior:**  Describe what you expected to happen.\n* **Actual behavior:**  Describe what actually happened.\n* **Code snippet:**  Provide a minimal code snippet that demonstrates the bug.  If possible, create a standalone example that can be easily run and tested.\n* **Error messages (if any):**  Include any error messages you received in your console.\n* **Screenshots or screen recordings (if applicable):** Visual aids can be helpful in explaining the problem.\n\n\n### Submitting Feature Requests\n\nFeature requests are welcome!  When submitting a feature request, clearly describe the proposed feature and its intended functionality.  Explain the use case and how this feature would improve SortableJS.  Consider the following:\n\n* **Clear description:** Provide a concise and clear description of the feature.\n* **Use cases:**  Explain the use cases where this feature would be beneficial.\n* **Potential implementation:**  If you have any ideas on how to implement the feature, please share them.  This will help us assess the feasibility and complexity of the implementation.\n* **Alternatives considered:**  Mention any alternative approaches you considered and why this proposed feature is preferred.\n\n\n### Coding Style Guide\n\nTo ensure consistency and readability, please follow these guidelines when contributing code:\n\n* **Indentation:** Use 2 spaces for indentation.\n* **Line length:** Keep lines under 80 characters.\n* **Naming conventions:** Use camelCase for variables and functions.\n* **Comments:**  Write clear and concise comments to explain complex logic.\n* **Semicolons:** Use semicolons at the end of statements.\n* **ES6 features:**  Use modern JavaScript features where appropriate.\n\n\n### Testing and Development\n\nBefore submitting a pull request, ensure that your changes are thoroughly tested.  The project uses a testing framework (you should specify the testing framework used, if available, e.g., Jest, Mocha).   Make sure your changes pass all existing tests and add new tests for any new features or bug fixes.  The testing process helps to ensure the quality and stability of SortableJS.  Run the tests using the project's instructions.  If you are adding new features, creating comprehensive test cases is essential to demonstrate the functionality and handle edge cases.  Testing increases confidence in the reliability and robustness of the codebase.\n\n","srcMarkdownNoYaml":"\n## Introduction\n\n### What is SortableJS?\n\nSortableJS is a minimalist JavaScript library for reorderable drag-and-drop lists on modern browsers and touch devices.  It provides a simple yet powerful API for creating highly customizable sortable interfaces without the need for complex configuration or extensive boilerplate code.  It focuses on performance and ease of use, making it ideal for a wide range of applications, from simple task lists to complex drag-and-drop interfaces within larger applications.  Unlike many other drag-and-drop libraries, SortableJS avoids unnecessary dependencies, keeping its footprint small and efficient.\n\n\n### Key Features and Benefits\n\n* **Lightweight and performant:** SortableJS has a small file size and is optimized for speed, ensuring a smooth user experience even with large lists.\n* **Cross-browser compatibility:** It works seamlessly across major modern browsers and touch devices.\n* **Simple API:**  The API is intuitive and easy to learn, allowing developers to quickly integrate sortable functionality into their projects.\n* **Extensible:**  SortableJS offers various options and events for extensive customization.\n* **No dependencies:** It doesn't rely on any other JavaScript libraries, simplifying integration and reducing potential conflicts.\n* **Touch support:** Built-in support for touch devices ensures a consistent experience across platforms.\n* **Multiple groups:**  Easily support dragging items between multiple sortable lists.\n\n\n### Getting Started: Installation and Setup\n\nSortableJS can be installed in several ways:\n\n* **CDN:** Include the SortableJS script directly from a CDN like jsDelivr:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js\"></script>\n```\n\n* **npm:** If you're using npm, install it via:\n\n```bash\nnpm install sortablejs\n```\n\nThen, import it into your JavaScript code:\n\n```javascript\nimport Sortable from 'sortablejs';\n```\n\n* **Yarn:**  If you are using Yarn, install with:\n\n```bash\nyarn add sortablejs\n```\n\nThen, import it into your JavaScript code:\n\n```javascript\nimport Sortable from 'sortablejs';\n```\n\n\nAfter installation, you're ready to start using SortableJS.\n\n\n### Basic Usage Example\n\nThis example demonstrates a simple sortable list:\n\n```html\n<ul id=\"my-list\">\n  <li>Item 1</li>\n  <li>Item 2</li>\n  <li>Item 3</li>\n</ul>\n\n<script>\n  new Sortable(document.getElementById('my-list'));\n</script>\n```\n\nThis code snippet initializes SortableJS on the `<ul>` element with the ID `my-list`.  This makes the list items draggable and re-orderable.  No further configuration is needed for basic functionality.  More advanced options and event handling are detailed in subsequent sections of this manual.\n\n\n## Core Concepts\n\n### Understanding SortableJS Elements\n\nSortableJS operates on a fundamental level by targeting HTML elements to enable drag-and-drop functionality. The core element is typically an unordered list (`<ul>`) or an ordered list (`<ol>`), though any element can technically be used.  The child elements of this container (e.g., `<li>` elements within a `<ul>`) are the items that are sortable.  SortableJS manipulates the DOM structure directly to reflect the changes in item order.  No hidden data structures are used; the visual order always reflects the actual order of the elements.  You can use attributes and data attributes on these elements to further customize the behavior and associate data with each sortable item.\n\n\n### Groups and Sorting\n\nSortableJS supports sorting items within a single list and also allows you to drag items between multiple lists.  This is achieved through the concept of \"groups\".  Items belonging to the same group can be freely dragged and dropped between each other.  Different groups can be defined using the `group` option.  If items belong to different groups, restrictions on dragging between them might be enforced, or you may choose to allow transfers between any groups by specifying a wildcard group (e.g., `group: { name: 'shared', pull: 'clone', put: false }`).  This gives you great flexibility in managing the interaction between multiple sortable lists.  The `pull` and `put` options within a group control whether items can be dragged *from* and *into* a specific list respectively.\n\n\n### Events and Callbacks\n\nSortableJS provides a rich set of events that allow you to respond to various actions during the drag-and-drop process.  These events are triggered at different stages:  `start`, `sort`, `update`, `remove`, `add`, `choose`, `unchoose`, `stop`, `clone`.  Each event provides relevant data, such as the item being dragged, its source and destination lists, and the old and new indices. You can attach custom callback functions to these events to perform actions like updating a database, saving state, or providing visual feedback to the user.   For example, the `update` event is fired whenever the order of items changes, allowing you to immediately update associated data structures.  Consult the documentation for a complete list of events and their parameters.\n\n\n### Data Transfer and Manipulation\n\nWhile SortableJS primarily focuses on DOM manipulation, it doesn't directly handle data transfer.  The library handles the visual rearrangement of items.  You are responsible for managing the associated data. You can achieve this using various techniques:\n\n* **Data Attributes:** Store data directly on the sortable items using HTML5 data attributes (`data-*`).  You can then access this data within the event callbacks to update your application's state.\n* **External Data Structures:** Maintain a separate data structure (e.g., an array or object) that mirrors the order of the sortable items.  Update this data structure within the `update`, `add`, and `remove` events.\n* **Data Binding:** Utilize a framework (like React, Vue, or Angular) that provides data binding capabilities.  This simplifies keeping your data structure synchronized with the visual order of the items.\n\nEssentially, SortableJS provides the drag-and-drop interface, but you're in control of how you handle and manage the data associated with the moved items.  The library empowers you to build dynamic interfaces synchronized with your application's data.\n\n\n## API Reference\n\n### Constructor Options\n\nThe SortableJS constructor accepts an options object as its second argument.  These options control various aspects of the sortable behavior.  Key options include:\n\n* **`group`:**  (String or Object) Defines the group to which the sortable belongs.  Items can only be dragged between lists belonging to the same group.  A group object can define `name`, `put`, and `pull` properties for finer control over dragging between lists.\n* **`animation`:** (Integer) Duration of the animation (in milliseconds) when items are moved.  Set to `0` to disable animation.\n* **`handle`:** (String or Function)  Specifies the element within each item that should be used as the drag handle.  This can be a CSS selector string or a function that returns a boolean indicating whether an element is a valid handle.\n* **`draggable`:** (String or Function) Specifies which items are draggable.  Similar to `handle`, this can be a CSS selector string or a function.\n* **`ghostClass`:** (String)  CSS class applied to the placeholder that visually indicates the position where the dragged item will be inserted.\n* **`chosenClass`:** (String) CSS class applied to the currently dragged item.\n* **`dataIdAttr`:** (String)  Attribute used to retrieve item ID for data transfer.\n* **`sort`:** (Boolean) Whether sorting is enabled.  Setting to `false` disables drag-and-drop.\n* **`delay`:** (Integer) Delay in milliseconds before the drag starts.  Useful to avoid accidental drags.\n* **`forceFallback`:** (Boolean) Forces the use of the fallback method (using a cloned element for dragging). Useful for improved compatibility with older browsers.\n* **`fallbackOnBody`:** (Boolean) Append the placeholder to the document body instead of the parent of the dragged element.  Can improve the dragging experience in complex layouts.\n* **`store`:** (Object) Enables persisting the sorting order across sessions.\n* **`filter`:** (String or Function)  Allows filtering the draggable items based on a CSS selector string or a custom function.\n* **`preventOnFilter`:** (Boolean) Whether to prevent dragging if an item matches the `filter` criteria.\n* **`onMove`:** (Function) Function triggered when an item is being moved.\n* **`onAdd`:** (Function) Function triggered when an item is added to the list.\n* **`onUpdate`:** (Function) Function triggered when the order of items changes.\n\nConsult the official documentation for the full list of options and their descriptions.\n\n\n### Methods: `sort`, `destroy`, `option`, etc.\n\nSortableJS provides several methods to interact with the instance:\n\n* **`sort(element, target, newIndex)`:**  Manually sorts an item.\n* **`destroy()`:**  Removes SortableJS from the element, restoring the original behavior.\n* **`option(optionName, value)`:**  Gets or sets the value of a constructor option.\n* **`serialize(options)`:**  Serializes the items into an array of their data IDs.\n* **`toArray()`:** Returns an array of the elements' IDs.\n* **`save()`:** Saves the current sort to the store.\n\n\n### Events: `sort`, `remove`, `add`, `update`, etc.\n\nSortableJS exposes a range of events that allow you to react to various stages of the drag-and-drop process:\n\n* **`sort`:**  Triggered when the item's position changes.\n* **`remove`:**  Triggered when an item is removed from the list.\n* **`add`:**  Triggered when an item is added to the list.\n* **`update`:** Triggered when the order of items changes.\n* **`start`:**  Triggered when a drag operation begins.\n* **`stop`:**  Triggered when a drag operation ends.\n* **`choose`:** Triggered when an item is chosen for dragging.\n* **`unchoose`:** Triggered when the chosen item is released (without being dropped).\n* **`clone`:**  Triggered when an item is cloned (if cloning is enabled).\n* **`filter`:** Triggered when a drag-and-drop operation is filtered.\n* **`move`:**  Triggered when a potential move is in progress.\n\nEach event provides an event object containing details of the event, such as the old and new indices of the item, the item itself, and related elements.\n\n\n### Event Handling and Customizations\n\nEvent handling is done by attaching listeners to the SortableJS instance using the `on` method:\n\n```javascript\nlet sortable = new Sortable(list, { /* options */ });\n\nsortable.on('update', function (evt) {\n  // Handle the update event\n  console.log('Order updated:', evt.oldIndex, evt.newIndex);\n});\n```\n\nThis approach allows you to respond to specific events and perform custom actions.  You can combine the events and options to build complex and highly customized drag-and-drop interfaces. Remember to consult the full API documentation for a complete list of available options and events and their specific parameters.\n\n\n## Advanced Techniques\n\n### Handling Nested Sortables\n\nSortableJS supports nested sortable lists.  This means you can have sortable lists within other sortable lists, creating hierarchical structures.  To achieve this, you need to create multiple Sortable instances, one for each level of nesting.  Be mindful of the `group` option when working with nested sortables.  If you want items to be freely moved between different levels of nesting, ensure that the relevant lists share the same group name.  However, if you want to restrict movement between levels, use different group names.  Properly managing group names is crucial for controlling the allowed drag-and-drop interactions within your nested structures.  Within event handlers, you can examine the `oldDraggableIndex` and `newDraggableIndex` properties to understand where an item has been moved to relative to its original position.\n\n### Implementing Drag Handles and Placeholders\n\nBy default, SortableJS allows dragging items by clicking and dragging anywhere on the item itself. However, you can customize this behavior to allow dragging only from specific elements (drag handles) using the `handle` option. This option accepts either a CSS selector string or a function that returns `true` if an element is a valid handle.   The `ghostClass` option controls the visual appearance of the placeholder that indicates where the dragged item will be inserted.  You can style this placeholder using CSS to create a visually appealing drag-and-drop experience.  Customizing the appearance of the drag handle and placeholder improves user experience by providing visual cues and clarity during the drag-and-drop interaction.\n\n### Customizing Animations and Transitions\n\nSortableJS allows you to control the animation of items during dragging and dropping using the `animation` option. This option specifies the duration of the animation in milliseconds. Setting it to `0` disables animations entirely.  For more advanced animation control,  you can leverage CSS transitions and animations in conjunction with the `chosenClass` and `ghostClass` options.  This gives you fine-grained control over the visual aspects of the drag-and-drop process, allowing you to create smooth and visually appealing transitions.  Remember that excessive or complex animations can impact performance, particularly with large lists, so choose appropriate animation styles to optimize the user experience.\n\n### Integrating with Other Libraries\n\nSortableJS is designed to be lightweight and non-intrusive, making it easy to integrate with other JavaScript libraries.  However, care must be taken to avoid conflicts.  Potential conflicts could arise if other libraries manipulate the DOM in ways that interfere with SortableJS's internal mechanisms.  If you're using a framework such as React, Vue, or Angular, you'll typically need to manage data synchronization manually, ensuring that changes in the DOM reflected by SortableJS are mirrored in your framework's data model.  When integrating with other drag-and-drop libraries, ensure they don't operate on the same elements to avoid conflicts and unexpected behavior.  Testing thoroughly is crucial to ensure seamless integration and identify any potential conflicts between libraries.\n\n\n## Troubleshooting\n\n### Common Issues and Solutions\n\n* **Items not draggable:**  Double-check that you've included the SortableJS script correctly and that you've initialized SortableJS on the correct element.  Ensure that the element you're targeting is actually in the DOM when the script runs.  Verify that CSS styles aren't accidentally preventing dragging (e.g., `pointer-events: none;`). If using a `handle` or `draggable` option, make sure your selectors or functions are correctly identifying the draggable elements.\n\n* **Unexpected behavior with nested lists:**  Ensure that the `group` option is correctly configured for nested lists.  Incorrect group settings can lead to unexpected drag-and-drop restrictions.  Carefully examine the nested structure to ensure that you've initialized SortableJS on each nested list correctly.\n\n* **Animations not working:** Verify that the `animation` option is set to a value greater than 0. Ensure that there are no CSS rules overriding the default animation styles applied by SortableJS.\n\n* **Data not updating correctly:** This usually indicates a problem in your event handling logic.  Double-check that you are correctly accessing and updating your data within the relevant event handlers (e.g., `update`, `add`, `remove`). Ensure your data update logic correctly reflects the changes made by SortableJS.\n\n* **Conflicts with other libraries:**  If you encounter conflicts with other JavaScript libraries, try disabling other libraries temporarily to isolate the problem.   Ensure that no other script is manipulating the same DOM elements concurrently with SortableJS.\n\n\n### Debugging Strategies\n\n* **Console logging:**  Use `console.log()` statements within your event handlers to track the values of relevant variables and the sequence of events.  This helps identify inconsistencies in data or unexpected event flows.\n\n* **Browser developer tools:** Utilize your browser's developer tools (usually accessed by pressing F12) to inspect the DOM structure, network requests, and console messages.  This is crucial for identifying DOM manipulation conflicts or unexpected behavior within SortableJS.  The debugger can be used to step through the code and identify the point of failure.\n\n* **Simplifying the code:**  Try temporarily removing or simplifying parts of your code to isolate the source of the problem.  Creating a minimal reproducible example can assist in identifying the root cause.\n\n\n### Performance Optimization\n\n* **Minimize animations:**  Excessive or complex animations can significantly impact performance, especially with large lists.  Consider simplifying or disabling animations if performance becomes an issue.\n\n* **Optimize DOM manipulation:** Avoid unnecessary DOM manipulation within event handlers, as this can lead to performance degradation.  Batch updates whenever possible.\n\n* **Use virtualization techniques:** For very large lists, consider using virtualization techniques to render only the visible items.  This can significantly improve rendering performance.\n\n* **Avoid heavy CSS:** Overly complex CSS styles can affect performance.  Ensure that your CSS selectors are efficient and that you're not unnecessarily applying styles to a large number of elements.  Consider using CSS preprocessors (like Sass or Less) to optimize your CSS.\n\n* **Profile your code:**  Use your browser's performance profiling tools to identify performance bottlenecks within your code.  This helps pinpoint areas where optimization efforts will have the greatest impact.\n\n\n## Examples and Use Cases\n\n### Simple List Sorting\n\nThis is the most basic use case.  You can create a simple sortable list with minimal code:\n\n```html\n<ul id=\"my-list\">\n  <li>Item 1</li>\n  <li>Item 2</li>\n  <li>Item 3</li>\n</ul>\n\n<script>\n  new Sortable(document.getElementById('my-list'));\n</script>\n```\n\nThis code makes the list items draggable and reorderable.  The `update` event can be used to capture the new order of items and update your application's data accordingly.\n\n\n### Drag-and-Drop File Uploads\n\nSortableJS can enhance file upload functionality by allowing users to reorder files before uploading.  This involves combining SortableJS with an HTML file input element:\n\n```html\n<input type=\"file\" id=\"file-upload\" multiple>\n<ul id=\"file-list\"></ul>\n\n<script>\n  const fileList = document.getElementById('file-list');\n  const fileUpload = document.getElementById('file-upload');\n\n  fileUpload.addEventListener('change', (e) => {\n    for (let file of e.target.files) {\n      let li = document.createElement('li');\n      li.textContent = file.name;\n      fileList.appendChild(li);\n    }\n    new Sortable(fileList); // Initialize SortableJS after adding files\n  });\n\n  // Handle the 'update' event to get the reordered file list\n</script>\n```\n\nThis example adds file names to a list as they are selected, and SortableJS enables reordering. You would then need to handle the updated order in the upload process.\n\n\n### Kanban Board Implementation\n\nA Kanban board is a common use case for sortable lists.  You can represent columns as separate sortable lists and allow users to drag tasks between columns:\n\n```html\n<div class=\"kanban-column\">\n  <h3>To Do</h3>\n  <ul id=\"to-do-list\">\n    <li>Task 1</li>\n    <li>Task 2</li>\n  </ul>\n</div>\n<div class=\"kanban-column\">\n  <h3>In Progress</h3>\n  <ul id=\"in-progress-list\"> </ul>\n</div>\n\n<script>\n  const todoList = new Sortable(document.getElementById('to-do-list'), { group: 'kanban' });\n  const inProgressList = new Sortable(document.getElementById('in-progress-list'), { group: 'kanban' });\n</script>\n```\n\nHere, both lists share the `kanban` group, allowing items to be dragged between them.  You would need to add more columns and handle the data updates reflecting the task movements.\n\n\n### Advanced Drag-and-Drop Interactions\n\nSortableJS allows for highly customized drag-and-drop behaviors.  This includes:\n\n* **Custom drag handles:** Use the `handle` option to specify elements that act as drag handles.\n* **Filtering draggable items:** Use the `filter` option to restrict which items are draggable.\n* **Cloning items:** Use the `group` option with `pull: 'clone'` to create copies of items when dragging them to a different list.\n* **Custom animations and transitions:**  Use CSS and the `animation` option to customize the visual appearance of the drag-and-drop operation.\n* **Multiple groups and complex group configurations:**  Create more complex interactions by using multiple groups with custom `put` and `pull` settings.  You can define complex rules about which groups allow dragging from and into them.\n\nThese advanced features allow you to create highly customized and sophisticated drag-and-drop interfaces tailored to specific application needs.  Combining these techniques with appropriate event handling creates a powerful and flexible drag-and-drop system.\n\n\n## Contributing\n\n### Reporting Bugs\n\nWhen reporting bugs, please provide as much detail as possible to help us reproduce and fix the issue.  A minimal reproducible example is highly valuable.  Include the following information:\n\n* **SortableJS version:** Specify the exact version number you're using.\n* **Browser and operating system:**  State the browser and operating system you encountered the bug on.\n* **Steps to reproduce:**  Provide clear and concise steps to reproduce the bug.\n* **Expected behavior:**  Describe what you expected to happen.\n* **Actual behavior:**  Describe what actually happened.\n* **Code snippet:**  Provide a minimal code snippet that demonstrates the bug.  If possible, create a standalone example that can be easily run and tested.\n* **Error messages (if any):**  Include any error messages you received in your console.\n* **Screenshots or screen recordings (if applicable):** Visual aids can be helpful in explaining the problem.\n\n\n### Submitting Feature Requests\n\nFeature requests are welcome!  When submitting a feature request, clearly describe the proposed feature and its intended functionality.  Explain the use case and how this feature would improve SortableJS.  Consider the following:\n\n* **Clear description:** Provide a concise and clear description of the feature.\n* **Use cases:**  Explain the use cases where this feature would be beneficial.\n* **Potential implementation:**  If you have any ideas on how to implement the feature, please share them.  This will help us assess the feasibility and complexity of the implementation.\n* **Alternatives considered:**  Mention any alternative approaches you considered and why this proposed feature is preferred.\n\n\n### Coding Style Guide\n\nTo ensure consistency and readability, please follow these guidelines when contributing code:\n\n* **Indentation:** Use 2 spaces for indentation.\n* **Line length:** Keep lines under 80 characters.\n* **Naming conventions:** Use camelCase for variables and functions.\n* **Comments:**  Write clear and concise comments to explain complex logic.\n* **Semicolons:** Use semicolons at the end of statements.\n* **ES6 features:**  Use modern JavaScript features where appropriate.\n\n\n### Testing and Development\n\nBefore submitting a pull request, ensure that your changes are thoroughly tested.  The project uses a testing framework (you should specify the testing framework used, if available, e.g., Jest, Mocha).   Make sure your changes pass all existing tests and add new tests for any new features or bug fixes.  The testing process helps to ensure the quality and stability of SortableJS.  Run the tests using the project's instructions.  If you are adding new features, creating comprehensive test cases is essential to demonstrate the functionality and handle edge cases.  Testing increases confidence in the reliability and robustness of the codebase.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"}],"output-file":"sortablejs.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"title":"SortableJS - A Developer's Handbook","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}