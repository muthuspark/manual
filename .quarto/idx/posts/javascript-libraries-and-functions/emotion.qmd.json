{"title":"Emotion - A Developer's Handbook","markdown":{"yaml":{"title":"Emotion - A Developer's Handbook","categories":["JavaScript Libraries and Functions"]},"headingText":"Introduction to Emotion","containsRefs":false,"markdown":"\n\n### What is Emotion?\n\nEmotion is a CSS-in-JS library for React (and other frameworks via adapters).  It allows you to write CSS directly in your JavaScript components, leveraging the power of JavaScript's expressiveness and dynamism to create styles.  Instead of managing separate CSS files, you define styles as JavaScript objects, enabling powerful features like dynamic styling, theming, and server-side rendering (SSR) without the complexities of traditional CSS methodologies.  Emotion compiles your styles into highly optimized CSS, minimizing the impact on your application's performance.\n\n\n### Why use Emotion?\n\n* **Maintainability:**  Keeps your styles tightly coupled with the components they affect, leading to better organization and easier maintenance.  No more hunting through separate CSS files.\n\n* **Dynamic Styling:** Easily create styles that change based on component props or application state.  This is ideal for responsive design and interactive UIs.\n\n* **Theming:**  Implement global themes and easily switch between them, creating consistent branding across your application.\n\n* **SSR Support:**  Works seamlessly with server-side rendering, ensuring your styles are rendered correctly on the initial page load.\n\n* **Performance:** Emotion compiles styles into optimized CSS, minimizing bundle size and improving load times.  It avoids unnecessary CSS generation, only producing the styles actually used in your application.\n\n* **Extensibility:**  Offers various features and plugins to extend its functionality, such as CSS-in-JS features like `styled-components` (though it has its own unique approach).\n\n* **Community and Support:**  Emotion boasts a large and active community, providing ample resources and support.\n\n\n### Setting up Emotion\n\nThe simplest way to add Emotion to your React project is via npm or yarn:\n\n```bash\nnpm install @emotion/react @emotion/styled\n# or\nyarn add @emotion/react @emotion/styled\n```\n\nYou'll primarily be using `@emotion/react` for inline styling and `@emotion/styled` for creating styled components.  Ensure these packages are correctly installed and referenced in your project setup.\n\n\n### Basic Usage\n\n**Inline Styles with `@emotion/react`:**\n\n```javascript\nimport { css } from '@emotion/react';\n\nfunction MyComponent() {\n  const myStyles = css`\n    color: blue;\n    font-size: 16px;\n  `;\n\n  return <div css={myStyles}>Hello, Emotion!</div>;\n}\n```\n\n**Styled Components with `@emotion/styled`:**\n\n```javascript\nimport styled from '@emotion/styled';\n\nconst MyButton = styled.button`\n  background-color: #4CAF50;\n  border: none;\n  color: white;\n  padding: 15px 32px;\n  text-align: center;\n  text-decoration: none;\n  display: inline-block;\n  font-size: 16px;\n  margin: 4px 2px;\n  cursor: pointer;\n`;\n\nfunction MyComponent() {\n  return <MyButton>Click Me</MyButton>;\n}\n```\n\nThese examples demonstrate the core principles of using Emotion: defining styles as JavaScript objects and applying them directly to React components.  Further exploration of advanced features (e.g., theming, media queries, pseudo-selectors) is available in the Emotion documentation.\n\n\n## Core Concepts\n\n### Styled Components\n\nEmotion's `styled` API allows you to create reusable, styled components.  These components are essentially React components that have styles attached directly to them. This approach promotes code organization and reusability.  You create styled components by calling `styled` with a base React component (like `div`, `span`, `button`, etc.) and then providing a template literal containing your CSS.\n\n```javascript\nimport styled from '@emotion/styled';\n\nconst MyButton = styled.button`\n  background-color: blue;\n  color: white;\n  padding: 10px 20px;\n  border: none;\n  cursor: pointer;\n`;\n\n// Usage:\n<MyButton>Click me</MyButton>\n```\n\nStyled components inherit the props of their base component and allow you to add dynamic styles based on props.\n\n\n### CSS-in-JS\n\nEmotion is a CSS-in-JS library. This means you write CSS directly within your JavaScript code, as opposed to in separate CSS files.  This approach offers several advantages, including dynamic styling, improved code organization, and better tooling integration.  Emotion processes this CSS and generates highly optimized CSS at runtime or build time.\n\n\n### The `css` prop\n\nThe `css` prop is a fundamental part of Emotion. It allows you to apply styles inline to any React component.  You pass a CSS object or a template literal to the `css` prop.\n\n```javascript\nimport { css } from '@emotion/react';\n\nconst myStyles = css`\n  color: red;\n  font-size: 18px;\n`;\n\n// Usage:\n<div css={myStyles}>This text is red and 18px.</div>\n```\n\nThe `css` prop can also accept dynamic values.\n\n\n### Interpolation\n\nInterpolation allows you to inject JavaScript variables and expressions into your CSS template literals. This is incredibly useful for dynamic styling based on component props or application state.\n\n```javascript\nimport { css } from '@emotion/react';\n\nconst MyComponent = ({ color }) => {\n  const myStyles = css`\n    background-color: ${color};\n    padding: 10px;\n  `;\n  return <div css={myStyles}>Dynamically Styled!</div>;\n};\n```\n\nThis allows you to create responsive and data-driven styles with ease.\n\n\n### Theme\n\nEmotion supports theming through context providers. You can define a theme object and make it available to your styled components via context.  This makes it easy to apply consistent styling throughout your application and switch between different themes (e.g., light/dark mode).\n\n\n```javascript\nimport { ThemeProvider, css } from '@emotion/react';\nconst theme = {\n  colors: {\n    primary: 'blue',\n    secondary: 'green'\n  }\n};\n\nconst MyComponent = () => (\n  <div css={theme => css`background-color: ${theme.colors.primary};`}>\n    Styled with theme\n  </div>\n);\n\n\n<ThemeProvider theme={theme}>\n  <MyComponent />\n</ThemeProvider>\n```\n\n### Media Queries\n\nEmotion allows you to use media queries within your styled components and `css` prop.  This allows you to create responsive designs that adapt to different screen sizes and devices.\n\n```javascript\nimport styled from '@emotion/styled';\n\nconst MyDiv = styled.div`\n  width: 100%;\n  @media (min-width: 768px) {\n    width: 50%;\n  }\n`;\n```\n\n\n### Pseudo-selectors\n\nEmotion supports all standard CSS pseudo-selectors like `:hover`, `:focus`, `:active`, `:before`, `:after`, etc.  You use these just like you would in regular CSS.\n\n```javascript\nimport styled from '@emotion/styled';\n\nconst MyButton = styled.button`\n  background-color: blue;\n  color: white;\n  &:hover {\n    background-color: green;\n  }\n`;\n```\n\n### Keyframes\n\nEmotion allows you to define and use CSS keyframes for animations.\n\n\n```javascript\nimport { keyframes, css } from '@emotion/react';\n\nconst fadeIn = keyframes`\n  from { opacity: 0; }\n  to { opacity: 1; }\n`;\n\nconst MyComponent = () => (\n  <div css={css`animation: ${fadeIn} 1s ease-in-out;`}>Fading In</div>\n);\n```\n\nRemember to consult the official Emotion documentation for more advanced usage and detailed explanations of each feature.\n\n\n## Advanced Techniques\n\n### Composition\n\nEmotion encourages component composition. You can nest styled components or combine them using the `css` prop to create complex and reusable UI elements.  This promotes modularity and reduces code duplication.  For example:\n\n```javascript\nimport styled from '@emotion/styled';\n\nconst Box = styled.div`\n  border: 1px solid black;\n  padding: 10px;\n`;\n\nconst Button = styled.button`\n  background-color: blue;\n  color: white;\n`;\n\nconst MyComponent = () => (\n  <Box>\n    <Button>Click me</Button>\n  </Box>\n);\n```\n\nThis approach leads to cleaner and more maintainable code.\n\n\n### Inheritance\n\nStyled components inherit styles from their parent components. This simplifies styling and promotes consistency across your application.  Styles defined in a parent component will cascade down to its children unless overridden.  Consider this:\n\n```javascript\nimport styled from '@emotion/styled';\n\nconst Container = styled.div`\n  font-family: sans-serif;\n`;\n\nconst Item = styled.div`\n  color: blue;\n`;\n\n<Container>\n  <Item>This text inherits the sans-serif font-family.</Item>\n</Container>\n```\n\n\n### Utilities\n\nEmotion doesn't provide built-in utility classes like some CSS frameworks. However, you can easily create your own set of utility styled components or use a separate utility library alongside Emotion.  This keeps your style management flexible and tailored to your project's needs.  For example, a simple utility:\n\n```javascript\nimport styled from '@emotion/styled';\n\nconst Flex = styled.div`\n  display: flex;\n`;\n```\n\n\n### Global Styles\n\nEmotion allows injecting global styles that apply to your entire application.  This is useful for setting default styles or applying consistent design patterns.\n\n```javascript\nimport { Global } from '@emotion/react';\n\nconst globalStyles = {\n  body: {\n    margin: 0,\n    fontFamily: 'sans-serif',\n  },\n};\n\n// ... inside your app:\n<Global styles={globalStyles} />\n```\n\n\n### Server-Side Rendering (SSR)\n\nEmotion is designed to work seamlessly with server-side rendering.   This ensures that your styles are rendered correctly on the server and the client, preventing the \"flash of unstyled content\" (FOUC) problem. Make sure you follow Emotion's recommended setup for SSR in your framework.  Correct hydration is crucial for performance.\n\n\n### Styling React Components\n\nEmotion excels at styling functional and class components. You can apply styles using the `css` prop or by creating styled components that wrap your existing components. This allows you to integrate Emotion into existing React codebases without significant refactoring.\n\n\n### Advanced theming\n\nBeyond basic theming, Emotion allows for more complex theming strategies. You can use techniques like nested theme objects, theme functions, and custom context providers to manage highly dynamic and customizable themes. This allows for powerful design systems and component variations.\n\n\n### Customizing the styling process\n\nFor very specific needs, you can customize Emotion's styling process using plugins or by directly interacting with its internal APIs.  This level of customization allows you to integrate with other tools or to optimize Emotion for particular performance needs. However, proceed with caution as this requires a more in-depth understanding of Emotion's internals.  Refer to the advanced sections of the official Emotion documentation for guidance on this.\n\n\n## Integration and Best Practices\n\n### Integrating with other libraries\n\nEmotion generally integrates well with other popular React libraries.  However, some considerations may apply depending on the library:\n\n* **Component Libraries:**  Most component libraries (e.g., Material-UI, Chakra UI) either use CSS-in-JS solutions themselves or can be styled using Emotion. You'll typically need to ensure that styles from other libraries don't conflict with your Emotion styles.  Be mindful of style specificity and potentially use techniques like CSS Modules or scoped styles to avoid conflicts.\n\n* **CSS Frameworks:**  While Emotion allows for CSS-in-JS, you can use it alongside a CSS framework (e.g., Bootstrap, Tailwind CSS).  However, this requires careful management to avoid style clashes.  Consider using Emotion for more dynamic or component-specific styles, while keeping the framework for more general utility classes.\n\n* **State Management Libraries:**  Libraries like Redux or Zustand work seamlessly with Emotion.  You can use state management to dynamically change styles based on application state.\n\n\n### Testing and debugging\n\nTesting and debugging Emotion styles is similar to testing and debugging regular React components.\n\n* **Unit Tests:**  You can test your styled components by rendering them in your unit tests and verifying their output using libraries like Jest and React Testing Library.  Snapshot testing is useful for verifying the visual output of styled components.\n\n* **Integration Tests:**  For complex interactions, integration tests can help ensure that styles are applied correctly in various scenarios.\n\n* **Debugging:**  Use your browser's developer tools to inspect styles and identify issues.  You can inspect the generated CSS to troubleshoot style conflicts or unexpected behavior.  Emotion's developer tools (if available for your setup) can provide additional insights.\n\n\n### Performance optimization\n\nEmotion is designed to be performant, but there are strategies to further optimize your application:\n\n* **Minimize unnecessary styles:** Avoid over-engineering your styles. Only define the styles you truly need.\n\n* **Use styled components effectively:**  Reuse styled components to reduce the amount of redundant CSS generated.\n\n* **Optimize media queries:**  Ensure your media queries are efficient and target only necessary breakpoints.\n\n* **Lazy loading:**  Use techniques like code splitting (see below) to load styles only when they are needed.\n\n* **Avoid excessive nesting:** Deeply nested styled components can sometimes impact performance.  Try to maintain a reasonable level of nesting for improved render times.\n\n\n### Accessibility\n\nAlways consider accessibility when writing your styles. Ensure your styles adhere to WCAG guidelines and provide sufficient contrast, proper focus states, and semantic HTML.\n\n* **Use semantic HTML:**  Choose appropriate HTML elements to convey the meaning and purpose of content.\n\n* **Ensure sufficient color contrast:**  Use tools to check the contrast between text and background colors.\n\n* **Provide adequate focus styles:**  Style focus states clearly for keyboard users.\n\n* **Use ARIA attributes:**  If necessary, use ARIA attributes to provide additional accessibility information.\n\n\n### Code splitting\n\nFor larger applications, code splitting is essential for improved performance and reduced initial load times.  Import styled components only when they're needed to avoid loading unnecessary CSS during the initial page load.  This usually involves dynamically importing modules or using techniques provided by your bundler (e.g., Webpack's dynamic `import()`).  For example:\n\n```javascript\nconst MyComponent = () => {\n  const [showComponent, setShowComponent] = useState(false);\n\n  const loadComponent = () => import('./MyStyledComponent').then(module => {\n      // Use module.default here\n  });\n\n  return (\n    <>\n       <button onClick={() => {setShowComponent(true); loadComponent()}}>Load Component</button>\n       {showComponent && <MyComponent />}\n    </>\n  );\n};\n```\n\nThis approach loads the styled component only when the user interacts with the component.  This can significantly improve initial load times for large applications.\n\n\n## Migration and Troubleshooting\n\n### Migrating from other styling solutions\n\nMigrating from other styling solutions to Emotion requires a careful approach, depending on the source.\n\n* **From CSS:**  The most significant change is moving from external CSS files to inline styles within your JavaScript components.  You'll need to rewrite your CSS rules as JavaScript objects or template literals using Emotion's `css` prop or `styled` API.  The process can be automated partially using tools or scripts depending on the complexity of your CSS, but manual review is usually necessary.\n\n* **From other CSS-in-JS libraries (e.g., styled-components):**  While the core concept is similar, the APIs differ. You'll need to rewrite your styles using Emotion's syntax and functionalities.  The transition might be smoother for simpler projects but could be complex for large applications with deeply nested components and custom theming logic.  The Emotion documentation often provides migration guides for common CSS-in-JS libraries.\n\n* **From inline styles (without a library):**  If you're using plain inline styles in your React components, the transition is relatively straightforward. You can simply wrap your inline styles with Emotion's `css` function, which provides more advanced features and better organization.\n\nRegardless of the source, thorough testing is crucial after migration to ensure all styles are working correctly.\n\n\n### Common issues and solutions\n\n* **Style conflicts:** If styles aren't applied as expected, it could be due to style specificity conflicts. Ensure that your Emotion styles have sufficient specificity to override other styles.  Use the browser's developer tools to inspect the CSS cascade.\n\n* **Missing styles:** Check your imports and ensure that the necessary Emotion packages are correctly installed and that you're using the appropriate APIs (`css`, `styled`, etc.). Also, check for typos in class names or selectors.\n\n* **Dynamic styles not updating:**  Confirm that the state or props you're using to drive dynamic styles are correctly updated.  React's reconciliation process should automatically update the rendered styles. If not, inspect your component's render cycles.\n\n* **SSR issues (see below):**  SSR issues are often related to hydration problems or incorrect setup.\n\n* **Unexpected behavior with media queries or pseudo-selectors:** Verify the syntax of your media queries and pseudo-selectors and ensure they are correctly interpreted by Emotion.  Browser developer tools can help debug this.\n\n\n### Debugging tips\n\n* **Browser developer tools:** The browser's developer tools (especially the \"Elements\" panel) are essential for debugging CSS. Inspect the rendered HTML and CSS to identify any discrepancies.\n\n* **Console logging:**  Log relevant state and prop values to track how dynamic styles are changing.\n\n* **Simplify your styles:** If you encounter complex issues, temporarily simplify your styles to isolate the problem.  Start with minimal styles to ensure basic functionality before adding complexity.\n\n* **Emotion's developer tools (if applicable):** Check if Emotion offers any browser extensions or tools that provide insights into the styling process.\n\n* **Check Emotion's documentation and community resources:**  The Emotion documentation and community forums are excellent resources for finding solutions to common problems and debugging strategies.\n\n\n### Troubleshooting SSR issues\n\nServer-side rendering issues with Emotion often stem from hydration problems.  Ensure you've followed Emotion's recommendations for setting up SSR in your framework.\n\n* **Hydration mismatch:**  If the client-side rendering doesn't match the server-side rendering, inspect the rendered HTML for any discrepancies.  Ensure the server and client have the same Emotion version and configuration.\n\n* **Missing styles on the server:**  Verify that your styles are correctly generated and included in the server-side rendered HTML.  Inspect the HTML source to check if the styles are present.\n\n* **Incorrect setup:**  Ensure you have correctly configured Emotion's SSR features, following the specific guidelines for your framework (Next.js, Gatsby, etc.).  Check the Emotion documentation for your framework.\n\n* **Caching issues:**  Incorrect caching can lead to stale styles being rendered.  Ensure your caching strategy is appropriate for your application.\n\n* **Use Emotion's SSR helpers:** Emotion often provides helper functions to assist with SSR.  Refer to the documentation to utilize these functions to ensure correct hydration.\n\n\n\n\n## API Reference\n\n**Note:**  The specifics of certain Emotion APIs might vary slightly depending on the version.  Always refer to the official Emotion documentation for the most up-to-date and accurate information.  This section provides a general overview.\n\n### `css` prop\n\nThe `css` prop is a function that allows you to inject styles into a React component. It accepts a CSS object, a template literal, or a function that returns a CSS object or template literal.\n\n**Basic usage:**\n\n```javascript\nimport { css } from '@emotion/react';\n\nconst myStyles = css`\n  color: blue;\n  font-size: 16px;\n`;\n\n<div css={myStyles}>Styled text</div>\n```\n\n**Usage with dynamic values:**\n\n```javascript\nimport { css } from '@emotion/react';\n\nconst MyComponent = ({ color }) => (\n  <div css={css`color: ${color};`}>Dynamically styled text</div>\n);\n```\n\n**Advanced usage (with theme):**\n\n```javascript\nimport { css, ThemeProvider } from '@emotion/react';\n\nconst theme = { colors: { primary: 'blue' } };\n\nconst MyComponent = () => (\n  <div css={theme => css`color: ${theme.colors.primary};`}>Themed text</div>\n);\n\n<ThemeProvider theme={theme}>\n  <MyComponent />\n</ThemeProvider>\n```\n\n\n### `cache`\n\nThe `cache` object provides low-level access to Emotion's internal styling cache.  It's primarily useful for advanced customization and integration with other tools.  Direct manipulation of the cache is generally not necessary for most use cases.  Consult the advanced section of the Emotion documentation for details on its usage.\n\n\n### `injectGlobal`\n\n(Note:  The use of `injectGlobal` is generally discouraged in favor of the `Global` component from `@emotion/react`, which provides better type safety and maintainability).  `injectGlobal` was a function for injecting global styles into the document's `<head>`.  The recommended modern approach is to use the `Global` component as shown in the Advanced Techniques section.\n\n\n### `keyframes`\n\nThe `keyframes` function allows you to define CSS keyframes for animations.\n\n```javascript\nimport { keyframes, css } from '@emotion/react';\n\nconst fadeIn = keyframes`\n  from { opacity: 0; }\n  to { opacity: 1; }\n`;\n\n<div css={css`animation: ${fadeIn} 1s ease;`}>Animated element</div>\n```\n\n\n### `ThemeProvider`\n\nThe `ThemeProvider` component provides a way to manage and inject a theme into your application.  It uses React context to make the theme available to all components within its scope.\n\n```javascript\nimport { ThemeProvider } from '@emotion/react';\n\nconst theme = {\n  colors: {\n    primary: 'blue',\n    secondary: 'green',\n  },\n};\n\n<ThemeProvider theme={theme}>\n  {/* Components using the theme */}\n</ThemeProvider>\n```\n\n\n### `withEmotionCache`\n\nThe `withEmotionCache` higher-order component (HOC) is used to inject Emotion's styling cache into a component's props.  This is mostly useful for advanced scenarios, such as integrating with server-side rendering or specialized styling solutions and not usually needed in typical development.  Refer to the Emotion documentation for specific examples and use cases.\n\n\n\n","srcMarkdownNoYaml":"\n## Introduction to Emotion\n\n### What is Emotion?\n\nEmotion is a CSS-in-JS library for React (and other frameworks via adapters).  It allows you to write CSS directly in your JavaScript components, leveraging the power of JavaScript's expressiveness and dynamism to create styles.  Instead of managing separate CSS files, you define styles as JavaScript objects, enabling powerful features like dynamic styling, theming, and server-side rendering (SSR) without the complexities of traditional CSS methodologies.  Emotion compiles your styles into highly optimized CSS, minimizing the impact on your application's performance.\n\n\n### Why use Emotion?\n\n* **Maintainability:**  Keeps your styles tightly coupled with the components they affect, leading to better organization and easier maintenance.  No more hunting through separate CSS files.\n\n* **Dynamic Styling:** Easily create styles that change based on component props or application state.  This is ideal for responsive design and interactive UIs.\n\n* **Theming:**  Implement global themes and easily switch between them, creating consistent branding across your application.\n\n* **SSR Support:**  Works seamlessly with server-side rendering, ensuring your styles are rendered correctly on the initial page load.\n\n* **Performance:** Emotion compiles styles into optimized CSS, minimizing bundle size and improving load times.  It avoids unnecessary CSS generation, only producing the styles actually used in your application.\n\n* **Extensibility:**  Offers various features and plugins to extend its functionality, such as CSS-in-JS features like `styled-components` (though it has its own unique approach).\n\n* **Community and Support:**  Emotion boasts a large and active community, providing ample resources and support.\n\n\n### Setting up Emotion\n\nThe simplest way to add Emotion to your React project is via npm or yarn:\n\n```bash\nnpm install @emotion/react @emotion/styled\n# or\nyarn add @emotion/react @emotion/styled\n```\n\nYou'll primarily be using `@emotion/react` for inline styling and `@emotion/styled` for creating styled components.  Ensure these packages are correctly installed and referenced in your project setup.\n\n\n### Basic Usage\n\n**Inline Styles with `@emotion/react`:**\n\n```javascript\nimport { css } from '@emotion/react';\n\nfunction MyComponent() {\n  const myStyles = css`\n    color: blue;\n    font-size: 16px;\n  `;\n\n  return <div css={myStyles}>Hello, Emotion!</div>;\n}\n```\n\n**Styled Components with `@emotion/styled`:**\n\n```javascript\nimport styled from '@emotion/styled';\n\nconst MyButton = styled.button`\n  background-color: #4CAF50;\n  border: none;\n  color: white;\n  padding: 15px 32px;\n  text-align: center;\n  text-decoration: none;\n  display: inline-block;\n  font-size: 16px;\n  margin: 4px 2px;\n  cursor: pointer;\n`;\n\nfunction MyComponent() {\n  return <MyButton>Click Me</MyButton>;\n}\n```\n\nThese examples demonstrate the core principles of using Emotion: defining styles as JavaScript objects and applying them directly to React components.  Further exploration of advanced features (e.g., theming, media queries, pseudo-selectors) is available in the Emotion documentation.\n\n\n## Core Concepts\n\n### Styled Components\n\nEmotion's `styled` API allows you to create reusable, styled components.  These components are essentially React components that have styles attached directly to them. This approach promotes code organization and reusability.  You create styled components by calling `styled` with a base React component (like `div`, `span`, `button`, etc.) and then providing a template literal containing your CSS.\n\n```javascript\nimport styled from '@emotion/styled';\n\nconst MyButton = styled.button`\n  background-color: blue;\n  color: white;\n  padding: 10px 20px;\n  border: none;\n  cursor: pointer;\n`;\n\n// Usage:\n<MyButton>Click me</MyButton>\n```\n\nStyled components inherit the props of their base component and allow you to add dynamic styles based on props.\n\n\n### CSS-in-JS\n\nEmotion is a CSS-in-JS library. This means you write CSS directly within your JavaScript code, as opposed to in separate CSS files.  This approach offers several advantages, including dynamic styling, improved code organization, and better tooling integration.  Emotion processes this CSS and generates highly optimized CSS at runtime or build time.\n\n\n### The `css` prop\n\nThe `css` prop is a fundamental part of Emotion. It allows you to apply styles inline to any React component.  You pass a CSS object or a template literal to the `css` prop.\n\n```javascript\nimport { css } from '@emotion/react';\n\nconst myStyles = css`\n  color: red;\n  font-size: 18px;\n`;\n\n// Usage:\n<div css={myStyles}>This text is red and 18px.</div>\n```\n\nThe `css` prop can also accept dynamic values.\n\n\n### Interpolation\n\nInterpolation allows you to inject JavaScript variables and expressions into your CSS template literals. This is incredibly useful for dynamic styling based on component props or application state.\n\n```javascript\nimport { css } from '@emotion/react';\n\nconst MyComponent = ({ color }) => {\n  const myStyles = css`\n    background-color: ${color};\n    padding: 10px;\n  `;\n  return <div css={myStyles}>Dynamically Styled!</div>;\n};\n```\n\nThis allows you to create responsive and data-driven styles with ease.\n\n\n### Theme\n\nEmotion supports theming through context providers. You can define a theme object and make it available to your styled components via context.  This makes it easy to apply consistent styling throughout your application and switch between different themes (e.g., light/dark mode).\n\n\n```javascript\nimport { ThemeProvider, css } from '@emotion/react';\nconst theme = {\n  colors: {\n    primary: 'blue',\n    secondary: 'green'\n  }\n};\n\nconst MyComponent = () => (\n  <div css={theme => css`background-color: ${theme.colors.primary};`}>\n    Styled with theme\n  </div>\n);\n\n\n<ThemeProvider theme={theme}>\n  <MyComponent />\n</ThemeProvider>\n```\n\n### Media Queries\n\nEmotion allows you to use media queries within your styled components and `css` prop.  This allows you to create responsive designs that adapt to different screen sizes and devices.\n\n```javascript\nimport styled from '@emotion/styled';\n\nconst MyDiv = styled.div`\n  width: 100%;\n  @media (min-width: 768px) {\n    width: 50%;\n  }\n`;\n```\n\n\n### Pseudo-selectors\n\nEmotion supports all standard CSS pseudo-selectors like `:hover`, `:focus`, `:active`, `:before`, `:after`, etc.  You use these just like you would in regular CSS.\n\n```javascript\nimport styled from '@emotion/styled';\n\nconst MyButton = styled.button`\n  background-color: blue;\n  color: white;\n  &:hover {\n    background-color: green;\n  }\n`;\n```\n\n### Keyframes\n\nEmotion allows you to define and use CSS keyframes for animations.\n\n\n```javascript\nimport { keyframes, css } from '@emotion/react';\n\nconst fadeIn = keyframes`\n  from { opacity: 0; }\n  to { opacity: 1; }\n`;\n\nconst MyComponent = () => (\n  <div css={css`animation: ${fadeIn} 1s ease-in-out;`}>Fading In</div>\n);\n```\n\nRemember to consult the official Emotion documentation for more advanced usage and detailed explanations of each feature.\n\n\n## Advanced Techniques\n\n### Composition\n\nEmotion encourages component composition. You can nest styled components or combine them using the `css` prop to create complex and reusable UI elements.  This promotes modularity and reduces code duplication.  For example:\n\n```javascript\nimport styled from '@emotion/styled';\n\nconst Box = styled.div`\n  border: 1px solid black;\n  padding: 10px;\n`;\n\nconst Button = styled.button`\n  background-color: blue;\n  color: white;\n`;\n\nconst MyComponent = () => (\n  <Box>\n    <Button>Click me</Button>\n  </Box>\n);\n```\n\nThis approach leads to cleaner and more maintainable code.\n\n\n### Inheritance\n\nStyled components inherit styles from their parent components. This simplifies styling and promotes consistency across your application.  Styles defined in a parent component will cascade down to its children unless overridden.  Consider this:\n\n```javascript\nimport styled from '@emotion/styled';\n\nconst Container = styled.div`\n  font-family: sans-serif;\n`;\n\nconst Item = styled.div`\n  color: blue;\n`;\n\n<Container>\n  <Item>This text inherits the sans-serif font-family.</Item>\n</Container>\n```\n\n\n### Utilities\n\nEmotion doesn't provide built-in utility classes like some CSS frameworks. However, you can easily create your own set of utility styled components or use a separate utility library alongside Emotion.  This keeps your style management flexible and tailored to your project's needs.  For example, a simple utility:\n\n```javascript\nimport styled from '@emotion/styled';\n\nconst Flex = styled.div`\n  display: flex;\n`;\n```\n\n\n### Global Styles\n\nEmotion allows injecting global styles that apply to your entire application.  This is useful for setting default styles or applying consistent design patterns.\n\n```javascript\nimport { Global } from '@emotion/react';\n\nconst globalStyles = {\n  body: {\n    margin: 0,\n    fontFamily: 'sans-serif',\n  },\n};\n\n// ... inside your app:\n<Global styles={globalStyles} />\n```\n\n\n### Server-Side Rendering (SSR)\n\nEmotion is designed to work seamlessly with server-side rendering.   This ensures that your styles are rendered correctly on the server and the client, preventing the \"flash of unstyled content\" (FOUC) problem. Make sure you follow Emotion's recommended setup for SSR in your framework.  Correct hydration is crucial for performance.\n\n\n### Styling React Components\n\nEmotion excels at styling functional and class components. You can apply styles using the `css` prop or by creating styled components that wrap your existing components. This allows you to integrate Emotion into existing React codebases without significant refactoring.\n\n\n### Advanced theming\n\nBeyond basic theming, Emotion allows for more complex theming strategies. You can use techniques like nested theme objects, theme functions, and custom context providers to manage highly dynamic and customizable themes. This allows for powerful design systems and component variations.\n\n\n### Customizing the styling process\n\nFor very specific needs, you can customize Emotion's styling process using plugins or by directly interacting with its internal APIs.  This level of customization allows you to integrate with other tools or to optimize Emotion for particular performance needs. However, proceed with caution as this requires a more in-depth understanding of Emotion's internals.  Refer to the advanced sections of the official Emotion documentation for guidance on this.\n\n\n## Integration and Best Practices\n\n### Integrating with other libraries\n\nEmotion generally integrates well with other popular React libraries.  However, some considerations may apply depending on the library:\n\n* **Component Libraries:**  Most component libraries (e.g., Material-UI, Chakra UI) either use CSS-in-JS solutions themselves or can be styled using Emotion. You'll typically need to ensure that styles from other libraries don't conflict with your Emotion styles.  Be mindful of style specificity and potentially use techniques like CSS Modules or scoped styles to avoid conflicts.\n\n* **CSS Frameworks:**  While Emotion allows for CSS-in-JS, you can use it alongside a CSS framework (e.g., Bootstrap, Tailwind CSS).  However, this requires careful management to avoid style clashes.  Consider using Emotion for more dynamic or component-specific styles, while keeping the framework for more general utility classes.\n\n* **State Management Libraries:**  Libraries like Redux or Zustand work seamlessly with Emotion.  You can use state management to dynamically change styles based on application state.\n\n\n### Testing and debugging\n\nTesting and debugging Emotion styles is similar to testing and debugging regular React components.\n\n* **Unit Tests:**  You can test your styled components by rendering them in your unit tests and verifying their output using libraries like Jest and React Testing Library.  Snapshot testing is useful for verifying the visual output of styled components.\n\n* **Integration Tests:**  For complex interactions, integration tests can help ensure that styles are applied correctly in various scenarios.\n\n* **Debugging:**  Use your browser's developer tools to inspect styles and identify issues.  You can inspect the generated CSS to troubleshoot style conflicts or unexpected behavior.  Emotion's developer tools (if available for your setup) can provide additional insights.\n\n\n### Performance optimization\n\nEmotion is designed to be performant, but there are strategies to further optimize your application:\n\n* **Minimize unnecessary styles:** Avoid over-engineering your styles. Only define the styles you truly need.\n\n* **Use styled components effectively:**  Reuse styled components to reduce the amount of redundant CSS generated.\n\n* **Optimize media queries:**  Ensure your media queries are efficient and target only necessary breakpoints.\n\n* **Lazy loading:**  Use techniques like code splitting (see below) to load styles only when they are needed.\n\n* **Avoid excessive nesting:** Deeply nested styled components can sometimes impact performance.  Try to maintain a reasonable level of nesting for improved render times.\n\n\n### Accessibility\n\nAlways consider accessibility when writing your styles. Ensure your styles adhere to WCAG guidelines and provide sufficient contrast, proper focus states, and semantic HTML.\n\n* **Use semantic HTML:**  Choose appropriate HTML elements to convey the meaning and purpose of content.\n\n* **Ensure sufficient color contrast:**  Use tools to check the contrast between text and background colors.\n\n* **Provide adequate focus styles:**  Style focus states clearly for keyboard users.\n\n* **Use ARIA attributes:**  If necessary, use ARIA attributes to provide additional accessibility information.\n\n\n### Code splitting\n\nFor larger applications, code splitting is essential for improved performance and reduced initial load times.  Import styled components only when they're needed to avoid loading unnecessary CSS during the initial page load.  This usually involves dynamically importing modules or using techniques provided by your bundler (e.g., Webpack's dynamic `import()`).  For example:\n\n```javascript\nconst MyComponent = () => {\n  const [showComponent, setShowComponent] = useState(false);\n\n  const loadComponent = () => import('./MyStyledComponent').then(module => {\n      // Use module.default here\n  });\n\n  return (\n    <>\n       <button onClick={() => {setShowComponent(true); loadComponent()}}>Load Component</button>\n       {showComponent && <MyComponent />}\n    </>\n  );\n};\n```\n\nThis approach loads the styled component only when the user interacts with the component.  This can significantly improve initial load times for large applications.\n\n\n## Migration and Troubleshooting\n\n### Migrating from other styling solutions\n\nMigrating from other styling solutions to Emotion requires a careful approach, depending on the source.\n\n* **From CSS:**  The most significant change is moving from external CSS files to inline styles within your JavaScript components.  You'll need to rewrite your CSS rules as JavaScript objects or template literals using Emotion's `css` prop or `styled` API.  The process can be automated partially using tools or scripts depending on the complexity of your CSS, but manual review is usually necessary.\n\n* **From other CSS-in-JS libraries (e.g., styled-components):**  While the core concept is similar, the APIs differ. You'll need to rewrite your styles using Emotion's syntax and functionalities.  The transition might be smoother for simpler projects but could be complex for large applications with deeply nested components and custom theming logic.  The Emotion documentation often provides migration guides for common CSS-in-JS libraries.\n\n* **From inline styles (without a library):**  If you're using plain inline styles in your React components, the transition is relatively straightforward. You can simply wrap your inline styles with Emotion's `css` function, which provides more advanced features and better organization.\n\nRegardless of the source, thorough testing is crucial after migration to ensure all styles are working correctly.\n\n\n### Common issues and solutions\n\n* **Style conflicts:** If styles aren't applied as expected, it could be due to style specificity conflicts. Ensure that your Emotion styles have sufficient specificity to override other styles.  Use the browser's developer tools to inspect the CSS cascade.\n\n* **Missing styles:** Check your imports and ensure that the necessary Emotion packages are correctly installed and that you're using the appropriate APIs (`css`, `styled`, etc.). Also, check for typos in class names or selectors.\n\n* **Dynamic styles not updating:**  Confirm that the state or props you're using to drive dynamic styles are correctly updated.  React's reconciliation process should automatically update the rendered styles. If not, inspect your component's render cycles.\n\n* **SSR issues (see below):**  SSR issues are often related to hydration problems or incorrect setup.\n\n* **Unexpected behavior with media queries or pseudo-selectors:** Verify the syntax of your media queries and pseudo-selectors and ensure they are correctly interpreted by Emotion.  Browser developer tools can help debug this.\n\n\n### Debugging tips\n\n* **Browser developer tools:** The browser's developer tools (especially the \"Elements\" panel) are essential for debugging CSS. Inspect the rendered HTML and CSS to identify any discrepancies.\n\n* **Console logging:**  Log relevant state and prop values to track how dynamic styles are changing.\n\n* **Simplify your styles:** If you encounter complex issues, temporarily simplify your styles to isolate the problem.  Start with minimal styles to ensure basic functionality before adding complexity.\n\n* **Emotion's developer tools (if applicable):** Check if Emotion offers any browser extensions or tools that provide insights into the styling process.\n\n* **Check Emotion's documentation and community resources:**  The Emotion documentation and community forums are excellent resources for finding solutions to common problems and debugging strategies.\n\n\n### Troubleshooting SSR issues\n\nServer-side rendering issues with Emotion often stem from hydration problems.  Ensure you've followed Emotion's recommendations for setting up SSR in your framework.\n\n* **Hydration mismatch:**  If the client-side rendering doesn't match the server-side rendering, inspect the rendered HTML for any discrepancies.  Ensure the server and client have the same Emotion version and configuration.\n\n* **Missing styles on the server:**  Verify that your styles are correctly generated and included in the server-side rendered HTML.  Inspect the HTML source to check if the styles are present.\n\n* **Incorrect setup:**  Ensure you have correctly configured Emotion's SSR features, following the specific guidelines for your framework (Next.js, Gatsby, etc.).  Check the Emotion documentation for your framework.\n\n* **Caching issues:**  Incorrect caching can lead to stale styles being rendered.  Ensure your caching strategy is appropriate for your application.\n\n* **Use Emotion's SSR helpers:** Emotion often provides helper functions to assist with SSR.  Refer to the documentation to utilize these functions to ensure correct hydration.\n\n\n\n\n## API Reference\n\n**Note:**  The specifics of certain Emotion APIs might vary slightly depending on the version.  Always refer to the official Emotion documentation for the most up-to-date and accurate information.  This section provides a general overview.\n\n### `css` prop\n\nThe `css` prop is a function that allows you to inject styles into a React component. It accepts a CSS object, a template literal, or a function that returns a CSS object or template literal.\n\n**Basic usage:**\n\n```javascript\nimport { css } from '@emotion/react';\n\nconst myStyles = css`\n  color: blue;\n  font-size: 16px;\n`;\n\n<div css={myStyles}>Styled text</div>\n```\n\n**Usage with dynamic values:**\n\n```javascript\nimport { css } from '@emotion/react';\n\nconst MyComponent = ({ color }) => (\n  <div css={css`color: ${color};`}>Dynamically styled text</div>\n);\n```\n\n**Advanced usage (with theme):**\n\n```javascript\nimport { css, ThemeProvider } from '@emotion/react';\n\nconst theme = { colors: { primary: 'blue' } };\n\nconst MyComponent = () => (\n  <div css={theme => css`color: ${theme.colors.primary};`}>Themed text</div>\n);\n\n<ThemeProvider theme={theme}>\n  <MyComponent />\n</ThemeProvider>\n```\n\n\n### `cache`\n\nThe `cache` object provides low-level access to Emotion's internal styling cache.  It's primarily useful for advanced customization and integration with other tools.  Direct manipulation of the cache is generally not necessary for most use cases.  Consult the advanced section of the Emotion documentation for details on its usage.\n\n\n### `injectGlobal`\n\n(Note:  The use of `injectGlobal` is generally discouraged in favor of the `Global` component from `@emotion/react`, which provides better type safety and maintainability).  `injectGlobal` was a function for injecting global styles into the document's `<head>`.  The recommended modern approach is to use the `Global` component as shown in the Advanced Techniques section.\n\n\n### `keyframes`\n\nThe `keyframes` function allows you to define CSS keyframes for animations.\n\n```javascript\nimport { keyframes, css } from '@emotion/react';\n\nconst fadeIn = keyframes`\n  from { opacity: 0; }\n  to { opacity: 1; }\n`;\n\n<div css={css`animation: ${fadeIn} 1s ease;`}>Animated element</div>\n```\n\n\n### `ThemeProvider`\n\nThe `ThemeProvider` component provides a way to manage and inject a theme into your application.  It uses React context to make the theme available to all components within its scope.\n\n```javascript\nimport { ThemeProvider } from '@emotion/react';\n\nconst theme = {\n  colors: {\n    primary: 'blue',\n    secondary: 'green',\n  },\n};\n\n<ThemeProvider theme={theme}>\n  {/* Components using the theme */}\n</ThemeProvider>\n```\n\n\n### `withEmotionCache`\n\nThe `withEmotionCache` higher-order component (HOC) is used to inject Emotion's styling cache into a component's props.  This is mostly useful for advanced scenarios, such as integrating with server-side rendering or specialized styling solutions and not usually needed in typical development.  Refer to the Emotion documentation for specific examples and use cases.\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"}],"output-file":"emotion.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"title":"Emotion - A Developer's Handbook","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}