{"title":"Typed.js - A Developer's Handbook","markdown":{"yaml":{"title":"Typed.js - A Developer's Handbook","categories":["JavaScript Libraries and Functions"]},"headingText":"Getting Started","containsRefs":false,"markdown":"\n\n### Installation\n\nTyped.js can be easily installed via npm or yarn.  For npm, use the following command in your terminal:\n\n```bash\nnpm install typed.js\n```\n\nFor yarn, use:\n\n```bash\nyarn add typed.js\n```\n\nAlternatively, you can include Typed.js directly from a CDN. Add the following `<script>` tag to your HTML file, replacing `<version>` with the latest version number (check the project's website for the current version):\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/typed.js@<version>/lib/typed.min.js\"></script>\n```\n\n\n### Basic Usage\n\nAfter installation, you can initialize Typed.js on any HTML element containing the text you want to type.  The core functionality relies on the `new Typed()` constructor.  This constructor takes two arguments:  the selector for the target element and an options object (optional).  The options object allows for customization of the typing behavior.  See the options section for a complete list.\n\nA basic initialization would look like this:\n\n```javascript\nconst typed = new Typed('.element', {\n  strings: [\"These are my strings\"],\n  typeSpeed: 50,\n  // other options...\n});\n```\n\nThis code will type out the text \"These are my strings\" into the element with the class \"element\".  `typeSpeed` is set to 50 milliseconds per character.\n\n\n### First Example\n\nLet's create a simple example that types out a few different phrases.  First, include Typed.js in your HTML (using either the CDN or your installed version).  Then, add a `<span>` element to your HTML where the typing will occur:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Typed.js Example</title>\n</head>\n<body>\n  <span id=\"typed-text\"></span>\n\n  <script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.16/lib/typed.min.js\"></script>  <!-- Replace with your version or local path -->\n  <script>\n    var typed = new Typed('#typed-text', {\n      strings: [\"Hello, world!\", \"This is Typed.js\", \"It's easy to use!\"],\n      typeSpeed: 30,\n      backSpeed: 20,\n      loop: true\n    });\n  </script>\n</body>\n</html>\n```\n\nThis example uses the `#typed-text` selector to target the `<span>` element. The `strings` array defines the phrases to be typed. `typeSpeed` controls how fast the text is typed, `backSpeed` controls how fast it is deleted, and `loop` makes the typing cycle through the strings repeatedly. Remember to replace the CDN link with your installation path if you installed it via npm or yarn.\n\n\n## Core Concepts\n\n### Strings and Typing\n\nTyped.js's core function is to dynamically type out strings of text.  These strings are provided to the `Typed` constructor via the `strings` option.  This option accepts an array of strings, where each string represents a phrase to be typed. Typed.js will sequentially type out each string in the array.\n\nThe order of strings is important; Typed.js will follow the order exactly as defined in the array. You can include HTML tags within your strings, but be mindful that Typed.js treats them as literal characters.  It doesn't interpret or render them as active HTML elements during the typing process; the browser will render them after the typing is complete.\n\n\n### Options and Customization\n\nTyped.js offers extensive options for customization. These options are passed to the `Typed` constructor as a JavaScript object.  Here are some key options:\n\n* **`strings` (Array of strings):** The array of strings to be typed.  Required.\n* **`typeSpeed` (Number):** The typing speed in milliseconds per character.  Defaults to 50.\n* **`backSpeed` (Number):** The deleting speed in milliseconds per character. Defaults to 0 (no deleting).\n* **`startDelay` (Number):** The delay in milliseconds before typing begins. Defaults to 0.\n* **`backDelay` (Number):** The delay in milliseconds after a string is typed before it is deleted. Defaults to 500.\n* **`loop` (Boolean):** Whether to loop through the strings continuously. Defaults to false.\n* **`loopCount` (Number):** The number of times to loop through the strings. Defaults to Infinity (loops indefinitely if `loop` is true).\n* **`showCursor` (Boolean):** Whether to show the cursor. Defaults to true.\n* **`cursorChar` (String):** The character used for the cursor. Defaults to \"|\".\n* **`attr` (Object):** Allows modifying attributes of the target element during typing. Useful for things like adding classes dynamically.  This is an object where keys are attribute names and values are functions that return the updated attribute value.\n\nFor a complete list of options and their detailed descriptions, refer to the project's documentation.\n\n\n### Event Handling\n\nTyped.js doesn't directly support custom event handling in the traditional `addEventListener` sense. However, you can achieve similar functionality by using callbacks.  Events effectively occur at specific points in the typing process, allowing you to execute code at those moments.  The main callback to utilize is `onComplete`.\n\n\n### Callbacks\n\nCallbacks provide a way to trigger custom functions at specific stages of the typing process. The most common callback is `onComplete`, which is executed when all strings have been typed and, if `loop` is false, the typing process completes. Other callbacks include `onStringTyped`, `onTyped`, `onCursorChange`, and `onReset`.  These are defined within the options object.  For example:\n\n```javascript\nconst typed = new Typed('.element', {\n  strings: [\"String 1\", \"String 2\"],\n  onComplete: function() {\n    console.log(\"All strings typed!\");\n    // Add your custom code here\n  },\n    onStringTyped: function(arrayPos, self){\n        console.log(\"String \" + arrayPos + \" typed!\");\n    }\n});\n```\n\nThe `onComplete` callback is called once all strings have been typed.  The `self` parameter provides a reference to the Typed instance.  `arrayPos` within `onStringTyped` indicates the index of the currently typed string.  Consult the project documentation for details on all available callbacks and their parameters.\n\n\n## Advanced Techniques\n\n### Custom Elements\n\nWhile Typed.js primarily targets simple text elements, you can use it with more complex HTML structures.  The key is to ensure that the selector you provide to the `Typed` constructor accurately targets the element(s) where you want the typing to occur.  If you want to type within specific elements *inside* a larger structure, you'll need to target those inner elements appropriately.  For example, if you have a `<div>` containing multiple `<span>` elements, and you only want to type within one of the spans, you must use a selector that specifically targets that span.\n\nAvoid directly manipulating the DOM within your Typed.js callbacks unless absolutely necessary.  If you need to update other parts of the page based on the typing, it's generally best practice to trigger those updates from your callbacks rather than altering the Typed.js target element's structure directly.\n\n\n### Multiple Instances\n\nYou can easily create multiple Typed.js instances on a single page.  Each instance is independent and operates on its own target element.  Simply create new `Typed` objects, each with its own selector and options.  This allows for creating complex, coordinated typing effects across different parts of a page.\n\n```javascript\nconst typed1 = new Typed('.element1', { /* options */ });\nconst typed2 = new Typed('.element2', { /* options */ });\n```\n\n\n### Chaining and Sequencing\n\nTo create more elaborate typing sequences, you can chain or sequence multiple Typed.js instances.  You can use callbacks like `onComplete` to trigger the initialization of subsequent instances.  This allows for a controlled progression of typing effects.  For example, you could have one instance finish typing before another begins.\n\n```javascript\nconst typed1 = new Typed('.element1', {\n  strings: [\"First set of strings\"],\n  onComplete: function() {\n    const typed2 = new Typed('.element2', { strings: [\"Second set of strings\"] });\n  }\n});\n```\n\n\n### Looping and Iteration\n\nThe `loop` and `loopCount` options provide control over how many times Typed.js iterates through the provided strings.  Setting `loop` to `true` and `loopCount` to `Infinity` will create an endless loop, continuously typing and deleting the strings.  You can control the number of loops using `loopCount`.  Careful consideration is needed when using continuous loops to avoid performance issues on resource-constrained devices.\n\n\n### Asynchronous Operations\n\nIf you need to integrate Typed.js with asynchronous operations (like fetching data from an API), ensure that the `Typed` instance is created *after* the data has been received and processed.  You can use promises or callbacks to manage the asynchronous flow and initialize Typed.js once the necessary data is available.  Do not attempt to dynamically change the `strings` array after initialization; create a new instance instead.\n\n```javascript\nfetch('/data.json')\n  .then(response => response.json())\n  .then(data => {\n    const strings = data.map(item => item.text);  // Extract strings from data\n    const typed = new Typed('.element', { strings: strings });\n  });\n```\n\n\n## Styling and Theming\n\n### CSS Customization\n\nTyped.js relies heavily on CSS for styling its output.  The library itself doesn't provide many styling options directly; instead, it leverages CSS classes to control the appearance of the typed text and the cursor.  You can completely customize the look and feel of Typed.js by targeting these classes with your own CSS rules.  The core classes you'll likely interact with include (but aren't limited to):\n\n* **`.typed-cursor`**: Styles the cursor element.\n* **`.typed-line`**: Styles each line of typed text.\n\n\nYou can add your custom CSS rules to your stylesheet to override the default styling or create entirely new looks. For example:\n\n```css\n.typed-cursor {\n  color: #ff0000; /* Red cursor */\n  font-size: 2em;\n}\n\n.typed-line {\n  font-family: 'Arial', sans-serif;\n  color: #008000; /* Green text */\n}\n```\n\n\n### Class Names and Selectors\n\nTyped.js uses specific class names that can be targeted with CSS selectors to modify the appearance of the typed text and the cursor.  Understanding these class names is crucial for effective styling.  You can inspect the rendered HTML elements in your browser's developer tools to identify the exact class names used in your specific setup.  Be aware that future versions might introduce minor changes to class names, so it's always advisable to inspect the rendered HTML to verify current class names.\n\nYou can use various CSS selectors (like class selectors, element selectors, and pseudo-classes) to style the elements precisely.\n\n### Inline Styles\n\nWhile possible, directly applying inline styles to the target element or its children is generally discouraged. Using inline styles overrides external stylesheets, making your CSS less maintainable and harder to debug.  It's much better to manage all your styling through external stylesheets or embedded `<style>` tags.  Inline styles should only be considered as a last resort for very specific, one-off styling needs.\n\n\n### Predefined Themes\n\nTyped.js itself does not come with predefined themes.  However, you can easily create your own reusable stylesheets and apply them to multiple instances of Typed.js to achieve a consistent thematic look across your web application.  You can abstract your common CSS rules into separate CSS files and include them in your HTML using `<link>` tags.  This approach promotes reusability and maintainability of your styles.  Consider using CSS preprocessors (like Sass or Less) for organizing and managing larger styling projects.\n\n\n## Troubleshooting and Debugging\n\n### Common Errors\n\nSeveral common errors can arise when using Typed.js.  Here are some of the most frequently encountered issues and their potential solutions:\n\n* **`TypeError: Cannot read properties of undefined (reading 'length')` or similar:** This often indicates that the selector used to target the element is incorrect. Double-check that the selector (e.g., `#myElement`, `.myElement`) accurately points to an existing element in your HTML.  Use your browser's developer tools to inspect the element and ensure it's correctly structured.\n\n* **No text appears:** Verify that the `strings` array in your Typed.js options is not empty and contains at least one string.  Also, check that the `typeSpeed` value is not excessively high (resulting in imperceptible typing).\n\n* **Unexpected behavior or errors:**  Ensure that you're using the correct version of Typed.js. Check for conflicting JavaScript code or libraries that might interfere with Typed.js.\n\n* **Cursor issues:** If the cursor is not displayed correctly, check your CSS rules for `.typed-cursor` to ensure they are not accidentally hiding or misplacing it.\n\n* **Callback functions not executing:** Confirm that your callback functions (like `onComplete`) are correctly defined and that their names are accurately specified in the options object.  Check your browser's console for JavaScript errors.\n\n\n\n### Debugging Tips\n\nHere are some debugging tips to help you resolve issues with Typed.js:\n\n* **Use your browser's developer tools:** The browser's developer tools (usually accessed by pressing F12) are invaluable for debugging.  Check the console for JavaScript errors, and use the debugger to step through your code and inspect variables.\n\n* **Simplify your code:** Isolate the problem by creating a minimal, reproducible example.  Start with a basic Typed.js setup and gradually add features until you identify the source of the issue.\n\n* **Check your CSS:** Carefully examine your CSS rules to ensure they are not unintentionally affecting the appearance or behavior of the Typed.js output.\n\n* **Consult the documentation:** The official Typed.js documentation often provides solutions to common problems and helpful examples.\n\n\n### Browser Compatibility\n\nTyped.js is designed to work across a wide range of modern browsers.  However, very old or outdated browsers might have limited support.  Generally, browsers supporting modern JavaScript features should work without significant issues.  If you encounter compatibility problems with a specific browser, you might need to check the browser's JavaScript engine capabilities and ensure they meet the minimum requirements of Typed.js (or consider providing polyfills for any missing features).  For the best experience, aim to support commonly used modern browsers.  Testing on different browsers is highly recommended before deployment to catch any unexpected compatibility problems.\n\n\n## API Reference\n\n### Typed.js Constructor\n\nThe core of Typed.js is its constructor function: `new Typed(selector, options)`.\n\n* **`selector` (String):** A CSS selector specifying the HTML element where the typing effect should occur.  This is required.  The selector should target a single element;  multiple elements might lead to unexpected behavior.\n\n* **`options` (Object):** An object containing options to customize the typing effect.  This is optional but highly recommended for controlling various aspects of the typing behavior.  See the \"Options\" section below for a detailed list.\n\n\nExample:\n\n```javascript\nconst typed = new Typed('#myElement', {\n    strings: ['Hello, world!'],\n    typeSpeed: 30\n});\n```\n\n\n### Options\n\nThe `options` object accepts numerous parameters to configure the typing effect.  Here's a summary; refer to the full documentation for complete details on each option:\n\n\n* **`strings` (Array of strings):** An array of strings to be typed sequentially. This is required.\n\n* **`typeSpeed` (Number):** Typing speed in milliseconds per character (default: 50).\n\n* **`backSpeed` (Number):** Deleting speed in milliseconds per character (default: 0).\n\n* **`startDelay` (Number):** Delay in milliseconds before typing begins (default: 0).\n\n* **`backDelay` (Number):** Delay in milliseconds after a string is typed before it's deleted (default: 500).\n\n* **`loop` (Boolean):** Enables continuous looping (default: `false`).\n\n* **`loopCount` (Number):** Number of times to loop (default: `Infinity` if `loop` is `true`).\n\n* **`showCursor` (Boolean):** Shows the typing cursor (default: `true`).\n\n* **`cursorChar` (String):** Character used for the cursor (default: `|`).\n\n* **`attr` (Object):** Allows modifying attributes of the target element dynamically during typing.\n\n* **`onComplete` (Function):** Callback function executed when all strings are typed.\n\n* **`onStringTyped` (Function):** Callback function executed when a single string is typed.\n\n* **`onTyped` (Function):** Callback function executed when each character is typed.\n\n* **`onCursorChange` (Function):** Callback function executed when the cursor state changes.\n\n* **`onReset` (Function):** Callback function executed when the typing effect is reset.\n\n\n### Methods\n\nTyped.js instances expose several methods:\n\n* **`destroy()`:** Stops the typing effect and removes the instance from the DOM.\n\n* **`reset()`:** Resets the typing effect to the beginning.\n\n* **`start()`:** Starts the typing effect if it's paused.\n\n* **`stop()`:** Pauses the typing effect.\n\n\n### Events\n\nWhile Typed.js doesn't use the standard `addEventListener` model for events, the callbacks specified in the `options` object act as event handlers.  These callbacks allow you to respond to specific stages of the typing process:\n\n* **`onComplete`**: Fired when all strings are typed.\n* **`onStringTyped`**: Fired after each string is typed.\n* **`onTyped`**: Fired after each character is typed.\n* **`onCursorChange`**: Fired when the cursor state (visible/invisible) changes.\n* **`onReset`**: Fired when the typing is reset.\n\nThese functions are called with context (`this`) referring to the Typed instance itself and relevant parameters (e.g., array position, typed string).  Leverage these callbacks to integrate custom actions and other dynamic elements to your application.\n\n\n## Examples and Use Cases\n\n### Simple Text Typing\n\nThe most basic use case is typing out a set of strings.  This is ideal for simple introductions, headlines, or short messages.\n\n```html\n<span id=\"typed-text\"></span>\n<script>\n  new Typed('#typed-text', {\n    strings: [\"Hello,\", \"world!\", \"This is Typed.js\"],\n    typeSpeed: 50\n  });\n</script>\n```\n\nThis code will type out each string sequentially into the `<span>` element with the ID \"typed-text\".\n\n\n### Animated Text Effects\n\nTyped.js can be used to create more engaging text animations.  By combining it with CSS animations or transitions, you can create visually appealing effects. For example, you might change the color of the text or add a scaling animation as each character is typed. This requires a deeper integration with CSS styling.\n\n\n```html\n<span id=\"animated-text\"></span>\n<style>\n  #animated-text span {\n    transition: transform 0.2s ease-in-out; /* Example animation */\n  }\n  #animated-text span.active {\n    transform: scale(1.1);\n  }\n</style>\n<script>\n  new Typed('#animated-text', {\n    strings: [\"Animated text\"],\n    typeSpeed: 20,\n    onTyped: function(arrayPos, self) {\n      // Add \"active\" class on character typing to trigger CSS transition\n      this.el.querySelector('span:nth-child('+arrayPos+')').classList.add('active');\n    }\n  });\n</script>\n```\n\nThis example uses `onTyped` callback to add a CSS class to each element dynamically during typing.  You need to adjust the CSS selector to match your HTML structure if you are using different elements than `<span>` elements.\n\n\n### Data-Driven Typing\n\nFor dynamic content, you can fetch strings from an external data source (e.g., an API) and use them as the input for Typed.js.  This is particularly useful when the text to be typed changes frequently.\n\n```javascript\nfetch('/api/strings')\n  .then(response => response.json())\n  .then(data => {\n    const strings = data.map(item => item.text);\n    new Typed('#data-driven-text', { strings: strings });\n  });\n```\n\nThis example fetches an array of strings from an API endpoint and uses the result to populate the `strings` option.  Remember to handle potential errors during the fetch operation.\n\n\n\n### Integration with Other Libraries\n\nTyped.js can be integrated with other JavaScript libraries to create even more sophisticated effects. For instance:\n\n* **Animation Libraries (GreenSock, Anime.js):** Combine Typed.js with animation libraries for complex visual effects that go beyond simple typing.\n* **UI Frameworks (React, Vue, Angular):**  You can seamlessly integrate Typed.js into any popular JavaScript framework, using it within component lifecycles or as part of a larger application.  Just remember to mount Typed.js after the component's DOM element has been rendered.\n* **Game Engines:** While uncommon, technically you could use Typed.js for text displays within a game or interactive application.\n\n\nRemember that integrating with other libraries requires careful consideration of timing and potential conflicts.  Use the callbacks (e.g., `onComplete`) to coordinate actions between Typed.js and other libraries.\n\n","srcMarkdownNoYaml":"\n## Getting Started\n\n### Installation\n\nTyped.js can be easily installed via npm or yarn.  For npm, use the following command in your terminal:\n\n```bash\nnpm install typed.js\n```\n\nFor yarn, use:\n\n```bash\nyarn add typed.js\n```\n\nAlternatively, you can include Typed.js directly from a CDN. Add the following `<script>` tag to your HTML file, replacing `<version>` with the latest version number (check the project's website for the current version):\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/typed.js@<version>/lib/typed.min.js\"></script>\n```\n\n\n### Basic Usage\n\nAfter installation, you can initialize Typed.js on any HTML element containing the text you want to type.  The core functionality relies on the `new Typed()` constructor.  This constructor takes two arguments:  the selector for the target element and an options object (optional).  The options object allows for customization of the typing behavior.  See the options section for a complete list.\n\nA basic initialization would look like this:\n\n```javascript\nconst typed = new Typed('.element', {\n  strings: [\"These are my strings\"],\n  typeSpeed: 50,\n  // other options...\n});\n```\n\nThis code will type out the text \"These are my strings\" into the element with the class \"element\".  `typeSpeed` is set to 50 milliseconds per character.\n\n\n### First Example\n\nLet's create a simple example that types out a few different phrases.  First, include Typed.js in your HTML (using either the CDN or your installed version).  Then, add a `<span>` element to your HTML where the typing will occur:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Typed.js Example</title>\n</head>\n<body>\n  <span id=\"typed-text\"></span>\n\n  <script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.16/lib/typed.min.js\"></script>  <!-- Replace with your version or local path -->\n  <script>\n    var typed = new Typed('#typed-text', {\n      strings: [\"Hello, world!\", \"This is Typed.js\", \"It's easy to use!\"],\n      typeSpeed: 30,\n      backSpeed: 20,\n      loop: true\n    });\n  </script>\n</body>\n</html>\n```\n\nThis example uses the `#typed-text` selector to target the `<span>` element. The `strings` array defines the phrases to be typed. `typeSpeed` controls how fast the text is typed, `backSpeed` controls how fast it is deleted, and `loop` makes the typing cycle through the strings repeatedly. Remember to replace the CDN link with your installation path if you installed it via npm or yarn.\n\n\n## Core Concepts\n\n### Strings and Typing\n\nTyped.js's core function is to dynamically type out strings of text.  These strings are provided to the `Typed` constructor via the `strings` option.  This option accepts an array of strings, where each string represents a phrase to be typed. Typed.js will sequentially type out each string in the array.\n\nThe order of strings is important; Typed.js will follow the order exactly as defined in the array. You can include HTML tags within your strings, but be mindful that Typed.js treats them as literal characters.  It doesn't interpret or render them as active HTML elements during the typing process; the browser will render them after the typing is complete.\n\n\n### Options and Customization\n\nTyped.js offers extensive options for customization. These options are passed to the `Typed` constructor as a JavaScript object.  Here are some key options:\n\n* **`strings` (Array of strings):** The array of strings to be typed.  Required.\n* **`typeSpeed` (Number):** The typing speed in milliseconds per character.  Defaults to 50.\n* **`backSpeed` (Number):** The deleting speed in milliseconds per character. Defaults to 0 (no deleting).\n* **`startDelay` (Number):** The delay in milliseconds before typing begins. Defaults to 0.\n* **`backDelay` (Number):** The delay in milliseconds after a string is typed before it is deleted. Defaults to 500.\n* **`loop` (Boolean):** Whether to loop through the strings continuously. Defaults to false.\n* **`loopCount` (Number):** The number of times to loop through the strings. Defaults to Infinity (loops indefinitely if `loop` is true).\n* **`showCursor` (Boolean):** Whether to show the cursor. Defaults to true.\n* **`cursorChar` (String):** The character used for the cursor. Defaults to \"|\".\n* **`attr` (Object):** Allows modifying attributes of the target element during typing. Useful for things like adding classes dynamically.  This is an object where keys are attribute names and values are functions that return the updated attribute value.\n\nFor a complete list of options and their detailed descriptions, refer to the project's documentation.\n\n\n### Event Handling\n\nTyped.js doesn't directly support custom event handling in the traditional `addEventListener` sense. However, you can achieve similar functionality by using callbacks.  Events effectively occur at specific points in the typing process, allowing you to execute code at those moments.  The main callback to utilize is `onComplete`.\n\n\n### Callbacks\n\nCallbacks provide a way to trigger custom functions at specific stages of the typing process. The most common callback is `onComplete`, which is executed when all strings have been typed and, if `loop` is false, the typing process completes. Other callbacks include `onStringTyped`, `onTyped`, `onCursorChange`, and `onReset`.  These are defined within the options object.  For example:\n\n```javascript\nconst typed = new Typed('.element', {\n  strings: [\"String 1\", \"String 2\"],\n  onComplete: function() {\n    console.log(\"All strings typed!\");\n    // Add your custom code here\n  },\n    onStringTyped: function(arrayPos, self){\n        console.log(\"String \" + arrayPos + \" typed!\");\n    }\n});\n```\n\nThe `onComplete` callback is called once all strings have been typed.  The `self` parameter provides a reference to the Typed instance.  `arrayPos` within `onStringTyped` indicates the index of the currently typed string.  Consult the project documentation for details on all available callbacks and their parameters.\n\n\n## Advanced Techniques\n\n### Custom Elements\n\nWhile Typed.js primarily targets simple text elements, you can use it with more complex HTML structures.  The key is to ensure that the selector you provide to the `Typed` constructor accurately targets the element(s) where you want the typing to occur.  If you want to type within specific elements *inside* a larger structure, you'll need to target those inner elements appropriately.  For example, if you have a `<div>` containing multiple `<span>` elements, and you only want to type within one of the spans, you must use a selector that specifically targets that span.\n\nAvoid directly manipulating the DOM within your Typed.js callbacks unless absolutely necessary.  If you need to update other parts of the page based on the typing, it's generally best practice to trigger those updates from your callbacks rather than altering the Typed.js target element's structure directly.\n\n\n### Multiple Instances\n\nYou can easily create multiple Typed.js instances on a single page.  Each instance is independent and operates on its own target element.  Simply create new `Typed` objects, each with its own selector and options.  This allows for creating complex, coordinated typing effects across different parts of a page.\n\n```javascript\nconst typed1 = new Typed('.element1', { /* options */ });\nconst typed2 = new Typed('.element2', { /* options */ });\n```\n\n\n### Chaining and Sequencing\n\nTo create more elaborate typing sequences, you can chain or sequence multiple Typed.js instances.  You can use callbacks like `onComplete` to trigger the initialization of subsequent instances.  This allows for a controlled progression of typing effects.  For example, you could have one instance finish typing before another begins.\n\n```javascript\nconst typed1 = new Typed('.element1', {\n  strings: [\"First set of strings\"],\n  onComplete: function() {\n    const typed2 = new Typed('.element2', { strings: [\"Second set of strings\"] });\n  }\n});\n```\n\n\n### Looping and Iteration\n\nThe `loop` and `loopCount` options provide control over how many times Typed.js iterates through the provided strings.  Setting `loop` to `true` and `loopCount` to `Infinity` will create an endless loop, continuously typing and deleting the strings.  You can control the number of loops using `loopCount`.  Careful consideration is needed when using continuous loops to avoid performance issues on resource-constrained devices.\n\n\n### Asynchronous Operations\n\nIf you need to integrate Typed.js with asynchronous operations (like fetching data from an API), ensure that the `Typed` instance is created *after* the data has been received and processed.  You can use promises or callbacks to manage the asynchronous flow and initialize Typed.js once the necessary data is available.  Do not attempt to dynamically change the `strings` array after initialization; create a new instance instead.\n\n```javascript\nfetch('/data.json')\n  .then(response => response.json())\n  .then(data => {\n    const strings = data.map(item => item.text);  // Extract strings from data\n    const typed = new Typed('.element', { strings: strings });\n  });\n```\n\n\n## Styling and Theming\n\n### CSS Customization\n\nTyped.js relies heavily on CSS for styling its output.  The library itself doesn't provide many styling options directly; instead, it leverages CSS classes to control the appearance of the typed text and the cursor.  You can completely customize the look and feel of Typed.js by targeting these classes with your own CSS rules.  The core classes you'll likely interact with include (but aren't limited to):\n\n* **`.typed-cursor`**: Styles the cursor element.\n* **`.typed-line`**: Styles each line of typed text.\n\n\nYou can add your custom CSS rules to your stylesheet to override the default styling or create entirely new looks. For example:\n\n```css\n.typed-cursor {\n  color: #ff0000; /* Red cursor */\n  font-size: 2em;\n}\n\n.typed-line {\n  font-family: 'Arial', sans-serif;\n  color: #008000; /* Green text */\n}\n```\n\n\n### Class Names and Selectors\n\nTyped.js uses specific class names that can be targeted with CSS selectors to modify the appearance of the typed text and the cursor.  Understanding these class names is crucial for effective styling.  You can inspect the rendered HTML elements in your browser's developer tools to identify the exact class names used in your specific setup.  Be aware that future versions might introduce minor changes to class names, so it's always advisable to inspect the rendered HTML to verify current class names.\n\nYou can use various CSS selectors (like class selectors, element selectors, and pseudo-classes) to style the elements precisely.\n\n### Inline Styles\n\nWhile possible, directly applying inline styles to the target element or its children is generally discouraged. Using inline styles overrides external stylesheets, making your CSS less maintainable and harder to debug.  It's much better to manage all your styling through external stylesheets or embedded `<style>` tags.  Inline styles should only be considered as a last resort for very specific, one-off styling needs.\n\n\n### Predefined Themes\n\nTyped.js itself does not come with predefined themes.  However, you can easily create your own reusable stylesheets and apply them to multiple instances of Typed.js to achieve a consistent thematic look across your web application.  You can abstract your common CSS rules into separate CSS files and include them in your HTML using `<link>` tags.  This approach promotes reusability and maintainability of your styles.  Consider using CSS preprocessors (like Sass or Less) for organizing and managing larger styling projects.\n\n\n## Troubleshooting and Debugging\n\n### Common Errors\n\nSeveral common errors can arise when using Typed.js.  Here are some of the most frequently encountered issues and their potential solutions:\n\n* **`TypeError: Cannot read properties of undefined (reading 'length')` or similar:** This often indicates that the selector used to target the element is incorrect. Double-check that the selector (e.g., `#myElement`, `.myElement`) accurately points to an existing element in your HTML.  Use your browser's developer tools to inspect the element and ensure it's correctly structured.\n\n* **No text appears:** Verify that the `strings` array in your Typed.js options is not empty and contains at least one string.  Also, check that the `typeSpeed` value is not excessively high (resulting in imperceptible typing).\n\n* **Unexpected behavior or errors:**  Ensure that you're using the correct version of Typed.js. Check for conflicting JavaScript code or libraries that might interfere with Typed.js.\n\n* **Cursor issues:** If the cursor is not displayed correctly, check your CSS rules for `.typed-cursor` to ensure they are not accidentally hiding or misplacing it.\n\n* **Callback functions not executing:** Confirm that your callback functions (like `onComplete`) are correctly defined and that their names are accurately specified in the options object.  Check your browser's console for JavaScript errors.\n\n\n\n### Debugging Tips\n\nHere are some debugging tips to help you resolve issues with Typed.js:\n\n* **Use your browser's developer tools:** The browser's developer tools (usually accessed by pressing F12) are invaluable for debugging.  Check the console for JavaScript errors, and use the debugger to step through your code and inspect variables.\n\n* **Simplify your code:** Isolate the problem by creating a minimal, reproducible example.  Start with a basic Typed.js setup and gradually add features until you identify the source of the issue.\n\n* **Check your CSS:** Carefully examine your CSS rules to ensure they are not unintentionally affecting the appearance or behavior of the Typed.js output.\n\n* **Consult the documentation:** The official Typed.js documentation often provides solutions to common problems and helpful examples.\n\n\n### Browser Compatibility\n\nTyped.js is designed to work across a wide range of modern browsers.  However, very old or outdated browsers might have limited support.  Generally, browsers supporting modern JavaScript features should work without significant issues.  If you encounter compatibility problems with a specific browser, you might need to check the browser's JavaScript engine capabilities and ensure they meet the minimum requirements of Typed.js (or consider providing polyfills for any missing features).  For the best experience, aim to support commonly used modern browsers.  Testing on different browsers is highly recommended before deployment to catch any unexpected compatibility problems.\n\n\n## API Reference\n\n### Typed.js Constructor\n\nThe core of Typed.js is its constructor function: `new Typed(selector, options)`.\n\n* **`selector` (String):** A CSS selector specifying the HTML element where the typing effect should occur.  This is required.  The selector should target a single element;  multiple elements might lead to unexpected behavior.\n\n* **`options` (Object):** An object containing options to customize the typing effect.  This is optional but highly recommended for controlling various aspects of the typing behavior.  See the \"Options\" section below for a detailed list.\n\n\nExample:\n\n```javascript\nconst typed = new Typed('#myElement', {\n    strings: ['Hello, world!'],\n    typeSpeed: 30\n});\n```\n\n\n### Options\n\nThe `options` object accepts numerous parameters to configure the typing effect.  Here's a summary; refer to the full documentation for complete details on each option:\n\n\n* **`strings` (Array of strings):** An array of strings to be typed sequentially. This is required.\n\n* **`typeSpeed` (Number):** Typing speed in milliseconds per character (default: 50).\n\n* **`backSpeed` (Number):** Deleting speed in milliseconds per character (default: 0).\n\n* **`startDelay` (Number):** Delay in milliseconds before typing begins (default: 0).\n\n* **`backDelay` (Number):** Delay in milliseconds after a string is typed before it's deleted (default: 500).\n\n* **`loop` (Boolean):** Enables continuous looping (default: `false`).\n\n* **`loopCount` (Number):** Number of times to loop (default: `Infinity` if `loop` is `true`).\n\n* **`showCursor` (Boolean):** Shows the typing cursor (default: `true`).\n\n* **`cursorChar` (String):** Character used for the cursor (default: `|`).\n\n* **`attr` (Object):** Allows modifying attributes of the target element dynamically during typing.\n\n* **`onComplete` (Function):** Callback function executed when all strings are typed.\n\n* **`onStringTyped` (Function):** Callback function executed when a single string is typed.\n\n* **`onTyped` (Function):** Callback function executed when each character is typed.\n\n* **`onCursorChange` (Function):** Callback function executed when the cursor state changes.\n\n* **`onReset` (Function):** Callback function executed when the typing effect is reset.\n\n\n### Methods\n\nTyped.js instances expose several methods:\n\n* **`destroy()`:** Stops the typing effect and removes the instance from the DOM.\n\n* **`reset()`:** Resets the typing effect to the beginning.\n\n* **`start()`:** Starts the typing effect if it's paused.\n\n* **`stop()`:** Pauses the typing effect.\n\n\n### Events\n\nWhile Typed.js doesn't use the standard `addEventListener` model for events, the callbacks specified in the `options` object act as event handlers.  These callbacks allow you to respond to specific stages of the typing process:\n\n* **`onComplete`**: Fired when all strings are typed.\n* **`onStringTyped`**: Fired after each string is typed.\n* **`onTyped`**: Fired after each character is typed.\n* **`onCursorChange`**: Fired when the cursor state (visible/invisible) changes.\n* **`onReset`**: Fired when the typing is reset.\n\nThese functions are called with context (`this`) referring to the Typed instance itself and relevant parameters (e.g., array position, typed string).  Leverage these callbacks to integrate custom actions and other dynamic elements to your application.\n\n\n## Examples and Use Cases\n\n### Simple Text Typing\n\nThe most basic use case is typing out a set of strings.  This is ideal for simple introductions, headlines, or short messages.\n\n```html\n<span id=\"typed-text\"></span>\n<script>\n  new Typed('#typed-text', {\n    strings: [\"Hello,\", \"world!\", \"This is Typed.js\"],\n    typeSpeed: 50\n  });\n</script>\n```\n\nThis code will type out each string sequentially into the `<span>` element with the ID \"typed-text\".\n\n\n### Animated Text Effects\n\nTyped.js can be used to create more engaging text animations.  By combining it with CSS animations or transitions, you can create visually appealing effects. For example, you might change the color of the text or add a scaling animation as each character is typed. This requires a deeper integration with CSS styling.\n\n\n```html\n<span id=\"animated-text\"></span>\n<style>\n  #animated-text span {\n    transition: transform 0.2s ease-in-out; /* Example animation */\n  }\n  #animated-text span.active {\n    transform: scale(1.1);\n  }\n</style>\n<script>\n  new Typed('#animated-text', {\n    strings: [\"Animated text\"],\n    typeSpeed: 20,\n    onTyped: function(arrayPos, self) {\n      // Add \"active\" class on character typing to trigger CSS transition\n      this.el.querySelector('span:nth-child('+arrayPos+')').classList.add('active');\n    }\n  });\n</script>\n```\n\nThis example uses `onTyped` callback to add a CSS class to each element dynamically during typing.  You need to adjust the CSS selector to match your HTML structure if you are using different elements than `<span>` elements.\n\n\n### Data-Driven Typing\n\nFor dynamic content, you can fetch strings from an external data source (e.g., an API) and use them as the input for Typed.js.  This is particularly useful when the text to be typed changes frequently.\n\n```javascript\nfetch('/api/strings')\n  .then(response => response.json())\n  .then(data => {\n    const strings = data.map(item => item.text);\n    new Typed('#data-driven-text', { strings: strings });\n  });\n```\n\nThis example fetches an array of strings from an API endpoint and uses the result to populate the `strings` option.  Remember to handle potential errors during the fetch operation.\n\n\n\n### Integration with Other Libraries\n\nTyped.js can be integrated with other JavaScript libraries to create even more sophisticated effects. For instance:\n\n* **Animation Libraries (GreenSock, Anime.js):** Combine Typed.js with animation libraries for complex visual effects that go beyond simple typing.\n* **UI Frameworks (React, Vue, Angular):**  You can seamlessly integrate Typed.js into any popular JavaScript framework, using it within component lifecycles or as part of a larger application.  Just remember to mount Typed.js after the component's DOM element has been rendered.\n* **Game Engines:** While uncommon, technically you could use Typed.js for text displays within a game or interactive application.\n\n\nRemember that integrating with other libraries requires careful consideration of timing and potential conflicts.  Use the callbacks (e.g., `onComplete`) to coordinate actions between Typed.js and other libraries.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"}],"output-file":"typedjs.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"title":"Typed.js - A Developer's Handbook","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}