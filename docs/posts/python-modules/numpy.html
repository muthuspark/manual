<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Muthukrishnan">
<meta name="dcterms.date" content="2025-02-09">
<meta name="description" content="NumPy (Numerical Python) is a fundamental library for scientific computing in Python. It provides powerful tools for working with multi-dimensional arrays…">

<title>numpy - Documentation – Technical Manuals</title>
<style>
html {
  color: #1a1a1a;
  background-color: #fdfdfd;
}
body {
  margin: 0 auto;
  max-width: 36em;
  padding-left: 50px;
  padding-right: 50px;
  padding-top: 50px;
  padding-bottom: 50px;
  hyphens: auto;
  overflow-wrap: break-word;
  text-rendering: optimizeLegibility;
  font-kerning: normal;
}
@media (max-width: 600px) {
  body {
    font-size: 0.9em;
    padding: 12px;
  }
  h1 {
    font-size: 1.8em;
  }
}
@media print {
  html {
    background-color: white;
  }
  body {
    background-color: transparent;
    color: black;
    font-size: 12pt;
  }
  p, h2, h3 {
    orphans: 3;
    widows: 3;
  }
  h2, h3, h4 {
    page-break-after: avoid;
  }
}
p {
  margin: 1em 0;
}
a {
  color: #1a1a1a;
}
a:visited {
  color: #1a1a1a;
}
img {
  max-width: 100%;
}
svg {
  height; auto;
  max-width: 100%;
}
h1, h2, h3, h4, h5, h6 {
  margin-top: 1.4em;
}
h5, h6 {
  font-size: 1em;
  font-style: italic;
}
h6 {
  font-weight: normal;
}
ol, ul {
  padding-left: 1.7em;
  margin-top: 1em;
}
li > ol, li > ul {
  margin-top: 0;
}
ul > li:not(:has(> p)) > ul,
ol > li:not(:has(> p)) > ul,
ul > li:not(:has(> p)) > ol,
ol > li:not(:has(> p)) > ol {
  margin-bottom: 0;
}
ul > li:not(:has(> p)) > ul > li:has(> p),
ol > li:not(:has(> p)) > ul > li:has(> p),
ul > li:not(:has(> p)) > ol > li:has(> p),
ol > li:not(:has(> p)) > ol > li:has(> p) {
  margin-top: 1rem;
}
blockquote {
  margin: 1em 0 1em 1.7em;
  padding-left: 1em;
  border-left: 2px solid #e6e6e6;
  color: #606060;
}
code {
  font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
  font-size: 85%;
  margin: 0;
  hyphens: manual;
}
pre {
  margin: 1em 0;
  overflow: auto;
}
pre code {
  padding: 0;
  overflow: visible;
  overflow-wrap: normal;
}
.sourceCode {
 background-color: transparent;
 overflow: visible;
}
hr {
  border: none;
  border-top: 1px solid #1a1a1a;
  height: 1px;
  margin: 1em 0;
}
table {
  margin: 1em 0;
  border-collapse: collapse;
  width: 100%;
  overflow-x: auto;
  display: block;
  font-variant-numeric: lining-nums tabular-nums;
}
table caption {
  margin-bottom: 0.75em;
}
tbody {
  margin-top: 0.5em;
  border-top: 1px solid #1a1a1a;
  border-bottom: 1px solid #1a1a1a;
}
th {
  border-top: 1px solid #1a1a1a;
  padding: 0.25em 0.5em 0.25em 0.5em;
}
td {
  padding: 0.125em 0.5em 0.25em 0.5em;
}
header {
  margin-bottom: 4em;
  text-align: center;
}
#TOC li {
  list-style: none;
}
#TOC ul {
  padding-left: 1.3em;
}
#TOC > ul {
  padding-left: 0;
}
#TOC a:not(:hover) {
  text-decoration: none;
}
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<link href="../../favicon.ico" rel="icon">
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-MXDPF6L5TL"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-MXDPF6L5TL', { 'anonymize_ip': true});
</script>
<link rel="icon" type="image/x-icon" href="favicon.ico">
<meta property="og:title" content="numpy - Documentation – Technical Manuals">
<meta property="og:description" content="Comprehensive technical documentation and tutorials for JavaScript libraries and Python modules.">
<meta property="og:image" content="https://manuals.muthu.co//og-image.png">
<meta property="og:site_name" content="Technical Manuals">
<meta property="og:locale" content="en_US">
<meta property="og:image:height" content="630">
<meta property="og:image:width" content="1200">
<meta name="twitter:title" content="numpy - Documentation – Technical Manuals">
<meta name="twitter:description" content="Comprehensive technical documentation and tutorials for JavaScript libraries and Python modules.">
<meta name="twitter:image" content="https://manuals.muthu.co//og-image.png">
<meta name="twitter:creator" content="@krimuthu">
<meta name="twitter:site" content="@krimuthu">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image-height" content="630">
<meta name="twitter:image-width" content="1200">
</head><body><div class="navigation-header">
    <nav>
        <div>
            <div class="logo">
                <a href="../../" aria-label="Home">
                    <span>Technical Manuals - Home</span>
                </a>
            </div>
            <div class="nav-menu">
                <ul>
                    <li>
                        <a href="../../about.html">
                            <span class="menu-text">About</span>
                        </a>
                    </li>
                    <li> 
                        <a href="https://github.com/muthuspark" target="_blank">
                            <span class="menu-text">Github</span>
                        </a>
                    </li>
                    <li>
                        <a href="https://linkedin.com/in/krimuthu" target="_blank">
                            <span class="menu-text">Linkedin</span>
                        </a>
                    </li>
                    <li>
                        <button onclick="window.print()" class="print-button">
                            <svg width="20" height="20" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <path d="M6 9V2h12v7"></path>
                              <path d="M6 18H4a2 2 0 01-2-2v-5a2 2 0 012-2h16a2 2 0 012 2v5a2 2 0 01-2 2h-2"></path>
                              <path d="M6 14h12v8H6z"></path>
                            </svg>
                            Print Page
                        </button>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
</div>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebSite",
  "name": "Technical Manuals",
  "url": "https://manuals.muthu.co/",
  "description": "Comprehensive technical documentation and tutorials for JavaScript libraries and Python modules.",
  "author": {
    "@type": "Person",
    "name": "Muthukrishnan",
    "url": "https://manuals.muthu.co/about.html",
    "sameAs": [
      "https://github.com/muthuspark",
      "https://linkedin.com/in/krimuthu",
      "https://twitter.com/krimuthu"
    ]
  },
  "publisher": {
    "@type": "Person",
    "name": "Muthukrishnan"
  },
  "inLanguage": "en-US",
  "potentialAction": {
    "@type": "SearchAction",
    "target": "https://manuals.muthu.co/?q={search_term_string}",
    "query-input": "required name=search_term_string"
  }
}
</script>
<meta name="author" content="Muthukrishnan">
<meta name="robots" content="index, follow">
<meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
<link rel="author" href="https://manuals.muthu.co/about.html">
<script>
// Dynamically set canonical URL based on current page
(function() {
  var link = document.createElement('link');
  link.rel = 'canonical';
  link.href = window.location.protocol + '//manuals.muthu.co' + window.location.pathname;
  document.head.appendChild(link);
})();
</script>


<link rel="stylesheet" href="../../styles.css">





<header id="title-block-header">
<h1 class="title">numpy - Documentation</h1>

<p class="date">2025-02-09</p>
</header>

<nav id="TOC" role="doc-toc">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#what-is-numpy" id="toc-what-is-numpy">What is NumPy?</a></li>
  <li><a href="#key-features-and-benefits" id="toc-key-features-and-benefits">Key Features and Benefits</a></li>
  <li><a href="#installation-and-setup" id="toc-installation-and-setup">Installation and Setup</a></li>
  <li><a href="#numpys-core-data-structure-the-ndarray" id="toc-numpys-core-data-structure-the-ndarray">NumPy’s Core Data Structure: The ndarray</a></li>
  <li><a href="#arrays-creation-and-manipulation" id="toc-arrays-creation-and-manipulation">Arrays: Creation and Manipulation</a>
  <ul>
  <li><a href="#creating-arrays" id="toc-creating-arrays">Creating Arrays</a></li>
  <li><a href="#array-attributes" id="toc-array-attributes">Array Attributes</a></li>
  <li><a href="#data-types" id="toc-data-types">Data Types</a></li>
  <li><a href="#array-shape-manipulation-reshaping-flattening" id="toc-array-shape-manipulation-reshaping-flattening">Array Shape Manipulation (Reshaping, Flattening)</a></li>
  <li><a href="#array-slicing-and-indexing" id="toc-array-slicing-and-indexing">Array Slicing and Indexing</a></li>
  <li><a href="#array-concatenation-and-splitting" id="toc-array-concatenation-and-splitting">Array Concatenation and Splitting</a></li>
  <li><a href="#copying-arrays" id="toc-copying-arrays">Copying Arrays</a></li>
  </ul></li>
  <li><a href="#array-operations" id="toc-array-operations">Array Operations</a>
  <ul>
  <li><a href="#arithmetic-operations" id="toc-arithmetic-operations">Arithmetic Operations</a></li>
  <li><a href="#logical-operations" id="toc-logical-operations">Logical Operations</a></li>
  <li><a href="#comparison-operations" id="toc-comparison-operations">Comparison Operations</a></li>
  <li><a href="#broadcasting" id="toc-broadcasting">Broadcasting</a></li>
  <li><a href="#linear-algebra" id="toc-linear-algebra">Linear Algebra</a></li>
  <li><a href="#statistical-functions" id="toc-statistical-functions">Statistical Functions</a></li>
  <li><a href="#mathematical-functions" id="toc-mathematical-functions">Mathematical Functions</a></li>
  </ul></li>
  <li><a href="#advanced-array-manipulation" id="toc-advanced-array-manipulation">Advanced Array Manipulation</a>
  <ul>
  <li><a href="#fancy-indexing" id="toc-fancy-indexing">Fancy Indexing</a></li>
  <li><a href="#boolean-indexing" id="toc-boolean-indexing">Boolean Indexing</a></li>
  <li><a href="#structured-arrays" id="toc-structured-arrays">Structured Arrays</a></li>
  <li><a href="#record-arrays" id="toc-record-arrays">Record Arrays</a></li>
  </ul></li>
  <li><a href="#input-and-output" id="toc-input-and-output">Input and Output</a>
  <ul>
  <li><a href="#saving-and-loading-arrays" id="toc-saving-and-loading-arrays">Saving and Loading Arrays</a></li>
  <li><a href="#working-with-text-files" id="toc-working-with-text-files">Working with Text Files</a></li>
  <li><a href="#working-with-binary-files" id="toc-working-with-binary-files">Working with Binary Files</a></li>
  </ul></li>
  <li><a href="#linear-algebra-with-numpy" id="toc-linear-algebra-with-numpy">Linear Algebra with NumPy</a>
  <ul>
  <li><a href="#matrix-operations" id="toc-matrix-operations">Matrix Operations</a></li>
  <li><a href="#eigenvalues-and-eigenvectors" id="toc-eigenvalues-and-eigenvectors">Eigenvalues and Eigenvectors</a></li>
  <li><a href="#singular-value-decomposition-svd" id="toc-singular-value-decomposition-svd">Singular Value Decomposition (SVD)</a></li>
  <li><a href="#solving-linear-equations" id="toc-solving-linear-equations">Solving Linear Equations</a></li>
  </ul></li>
  <li><a href="#random-number-generation" id="toc-random-number-generation">Random Number Generation</a>
  <ul>
  <li><a href="#generating-random-numbers" id="toc-generating-random-numbers">Generating Random Numbers</a></li>
  <li><a href="#distributions" id="toc-distributions">Distributions</a></li>
  <li><a href="#seeding" id="toc-seeding">Seeding</a></li>
  <li><a href="#random-walks" id="toc-random-walks">Random Walks</a></li>
  </ul></li>
  <li><a href="#fourier-transforms" id="toc-fourier-transforms">Fourier Transforms</a>
  <ul>
  <li><a href="#discrete-fourier-transforms-dft" id="toc-discrete-fourier-transforms-dft">Discrete Fourier Transforms (DFT)</a></li>
  <li><a href="#fast-fourier-transforms-fft" id="toc-fast-fourier-transforms-fft">Fast Fourier Transforms (FFT)</a></li>
  <li><a href="#applications-of-fft" id="toc-applications-of-fft">Applications of FFT</a></li>
  </ul></li>
  <li><a href="#polynomials" id="toc-polynomials">Polynomials</a>
  <ul>
  <li><a href="#polynomial-representation" id="toc-polynomial-representation">Polynomial Representation</a></li>
  <li><a href="#polynomial-operations" id="toc-polynomial-operations">Polynomial Operations</a></li>
  <li><a href="#roots-of-polynomials" id="toc-roots-of-polynomials">Roots of Polynomials</a></li>
  </ul></li>
  <li><a href="#numpy-and-other-libraries" id="toc-numpy-and-other-libraries">NumPy and Other Libraries</a>
  <ul>
  <li><a href="#numpy-with-scipy" id="toc-numpy-with-scipy">NumPy with SciPy</a></li>
  <li><a href="#numpy-with-pandas" id="toc-numpy-with-pandas">NumPy with Pandas</a></li>
  <li><a href="#numpy-with-matplotlib" id="toc-numpy-with-matplotlib">NumPy with Matplotlib</a></li>
  </ul></li>
  <li><a href="#advanced-topics" id="toc-advanced-topics">Advanced Topics</a>
  <ul>
  <li><a href="#memory-management" id="toc-memory-management">Memory Management</a></li>
  <li><a href="#performance-optimization" id="toc-performance-optimization">Performance Optimization</a></li>
  <li><a href="#extension-types" id="toc-extension-types">Extension Types</a></li>
  <li><a href="#universal-functions-ufuncs" id="toc-universal-functions-ufuncs">Universal Functions (ufuncs)</a></li>
  </ul></li>
  </ul>
</nav>
<h3 id="what-is-numpy">What is NumPy?</h3>
<p>NumPy (Numerical Python) is a fundamental library for scientific computing in Python. It provides powerful tools for working with multi-dimensional arrays (ndarrays), mathematical functions operating on these arrays, and linear algebra routines. NumPy forms the foundation for many other scientific Python libraries, including SciPy, pandas, and scikit-learn. Its efficient array operations, implemented largely in C, significantly speed up numerical computations compared to using standard Python lists.</p>
<h3 id="key-features-and-benefits">Key Features and Benefits</h3>
<ul>
<li><p><strong>High-performance multi-dimensional arrays:</strong> NumPy’s ndarray is the cornerstone. It’s a highly optimized data structure for storing and manipulating large amounts of numerical data. Operations are vectorized, meaning they operate on entire arrays at once, leading to substantial performance improvements.</p></li>
<li><p><strong>Broadcasting:</strong> A powerful mechanism that allows NumPy to perform operations on arrays of different shapes under certain conditions, simplifying code and improving efficiency.</p></li>
<li><p><strong>Mathematical and logical operations:</strong> NumPy provides a rich collection of functions for performing mathematical and logical operations on arrays, including linear algebra, Fourier transforms, random number generation, and more.</p></li>
<li><p><strong>Integration with other libraries:</strong> NumPy’s seamless integration with other scientific computing libraries makes it a crucial component of the Python scientific ecosystem.</p></li>
<li><p><strong>Efficient memory management:</strong> NumPy’s efficient memory management minimizes memory usage and improves performance, especially when working with large datasets.</p></li>
</ul>
<h3 id="installation-and-setup">Installation and Setup</h3>
<p>NumPy is typically installed using <code>pip</code>, the Python package installer:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install numpy</span></code></pre></div>
<p>Alternatively, you can use conda, a package manager often used in scientific Python environments:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">conda</span> install numpy</span></code></pre></div>
<p>After installation, verify the installation by importing NumPy in a Python interpreter:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(np.__version__) <span class="co">#Displays the installed NumPy version</span></span></code></pre></div>
<p>Ensure that you have a compatible version of Python (3.7 or higher is generally recommended).</p>
<h3 id="numpys-core-data-structure-the-ndarray">NumPy’s Core Data Structure: The ndarray</h3>
<p>The ndarray (N-dimensional array) is NumPy’s primary data structure. It’s a homogeneous multi-dimensional container of items of the same type and size. Key characteristics include:</p>
<ul>
<li><p><strong>Shape:</strong> Defines the dimensions of the array (e.g., a 2x3 array has a shape of (2, 3)).</p></li>
<li><p><strong>Data type (dtype):</strong> Specifies the type of elements stored in the array (e.g., <code>int32</code>, <code>float64</code>, <code>complex128</code>). NumPy automatically infers the data type based on the input data unless explicitly specified.</p></li>
<li><p><strong>Strides:</strong> Determine how to traverse the array in memory. Understanding strides is crucial for efficient memory access and advanced array manipulation.</p></li>
<li><p><strong>Memory layout:</strong> ndarrays store data in contiguous blocks of memory, optimizing access speed. Different memory orders (C-order and F-order) are available.</p></li>
</ul>
<p>Creating ndarrays is straightforward:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># From a list</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>arr1 <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>])</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">#From a nested list to create a multi-dimensional array</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>arr2 <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]])</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">#Using the arange function</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>arr3 <span class="op">=</span> np.arange(<span class="dv">10</span>) <span class="co">#creates an array of values from 0 to 9</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co">#Specifying data type</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>arr4 <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], dtype<span class="op">=</span>np.float64)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(arr1.shape, arr1.dtype)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(arr2.shape, arr2.dtype)</span></code></pre></div>
<p>The <code>shape</code> and <code>dtype</code> attributes provide information about the array’s dimensions and data type. Many other attributes and methods facilitate manipulation and analysis of ndarrays.</p>
<h2 id="arrays-creation-and-manipulation">Arrays: Creation and Manipulation</h2>
<h3 id="creating-arrays">Creating Arrays</h3>
<p>NumPy offers several ways to create arrays:</p>
<ul>
<li><strong>From lists or tuples:</strong> The simplest method involves passing Python lists or tuples to the <code>numpy.array()</code> function. Nested lists/tuples create multi-dimensional arrays.</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])  <span class="co"># 1D array</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">4</span>]])  <span class="co"># 2D array</span></span></code></pre></div>
<ul>
<li><p><strong>Using array creation functions:</strong> NumPy provides functions to create arrays with specific characteristics:</p>
<ul>
<li><code>np.zeros((rows, cols))</code>: Creates an array filled with zeros.</li>
<li><code>np.ones((rows, cols))</code>: Creates an array filled with ones.</li>
<li><code>np.empty((rows, cols))</code>: Creates an uninitialized array (values are unpredictable).</li>
<li><code>np.arange(start, stop, step)</code>: Creates an array with evenly spaced values within a given interval.</li>
<li><code>np.linspace(start, stop, num)</code>: Creates an array with evenly spaced numbers over a specified interval.</li>
<li><code>np.full((rows, cols), value)</code>: Creates an array filled with a specified value.</li>
<li><code>np.eye(n)</code>: Creates an identity matrix (square array with ones on the diagonal and zeros elsewhere).</li>
<li><code>np.random.rand(rows, cols)</code>: Creates an array with random values drawn from a uniform distribution between 0 and 1.</li>
<li><code>np.random.randn(rows, cols)</code>: Creates an array with random values drawn from a standard normal distribution.</li>
</ul></li>
<li><p><strong>From files:</strong> NumPy can load arrays from various file formats, such as text files, CSV files, and binary files (using functions like <code>np.loadtxt</code>, <code>np.genfromtxt</code>, and <code>np.fromfile</code>).</p></li>
</ul>
<h3 id="array-attributes">Array Attributes</h3>
<p>Several attributes provide information about an array:</p>
<ul>
<li><code>shape</code>: A tuple representing the dimensions of the array.</li>
<li><code>dtype</code>: The data type of the array elements.</li>
<li><code>ndim</code>: The number of dimensions (axes) of the array.</li>
<li><code>size</code>: The total number of elements in the array.</li>
<li><code>itemsize</code>: The size (in bytes) of each element in the array.</li>
<li><code>nbytes</code>: The total size (in bytes) of the array.</li>
<li><code>T</code> (or <code>.transpose()</code>): Returns the transpose of the array.</li>
</ul>
<h3 id="data-types">Data Types</h3>
<p>NumPy supports a wide range of data types, including integers (<code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>), floating-point numbers (<code>float16</code>, <code>float32</code>, <code>float64</code>), complex numbers, booleans, and more. The <code>dtype</code> attribute specifies the data type of an array. You can explicitly set the <code>dtype</code> when creating an array or convert an array’s data type using the <code>astype()</code> method.</p>
<h3 id="array-shape-manipulation-reshaping-flattening">Array Shape Manipulation (Reshaping, Flattening)</h3>
<ul>
<li><strong>Reshaping:</strong> Changes the shape of an array without altering its data. The <code>reshape()</code> method is used for this purpose. The total number of elements must remain the same.</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.arange(<span class="dv">12</span>).reshape(<span class="dv">3</span>, <span class="dv">4</span>) <span class="co">#Reshapes a 1D array into a 3x4 array</span></span></code></pre></div>
<ul>
<li><strong>Flattening:</strong> Converts a multi-dimensional array into a 1D array. The <code>flatten()</code> method or the <code>ravel()</code> method can achieve this ( <code>ravel</code> may return a view, while <code>flatten</code> always returns a copy).</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.arange(<span class="dv">12</span>).reshape(<span class="dv">3</span>, <span class="dv">4</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> a.flatten() <span class="co">#Flattens the array</span></span></code></pre></div>
<h3 id="array-slicing-and-indexing">Array Slicing and Indexing</h3>
<p>Similar to Python lists, NumPy arrays support slicing and indexing to access individual elements or subsets of the array. Multi-dimensional arrays use comma-separated indices.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>], [<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>]])</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a[<span class="dv">0</span>, <span class="dv">1</span>])  <span class="co"># Accesses element at row 0, column 1 (value: 2)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a[<span class="dv">1</span>:<span class="dv">3</span>, <span class="dv">0</span>:<span class="dv">2</span>]) <span class="co">#Slices a subarray</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a[:, <span class="dv">1</span>]) <span class="co">#Slices the entire second column</span></span></code></pre></div>
<p>Boolean indexing allows selecting elements based on a boolean condition:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>a[a <span class="op">&gt;</span> <span class="dv">5</span>] <span class="co">#Selects elements greater than 5</span></span></code></pre></div>
<h3 id="array-concatenation-and-splitting">Array Concatenation and Splitting</h3>
<ul>
<li><p><strong>Concatenation:</strong> Combines multiple arrays into a single array. The <code>concatenate()</code> function is used along with the <code>axis</code> parameter to specify the concatenation axis. <code>vstack</code> and <code>hstack</code> provide convenience for vertical and horizontal stacking, respectively.</p></li>
<li><p><strong>Splitting:</strong> Divides an array into multiple sub-arrays. The <code>split()</code> function, <code>vsplit</code>, and <code>hsplit</code> are used for this purpose.</p></li>
</ul>
<h3 id="copying-arrays">Copying Arrays</h3>
<p>Direct assignment creates a <em>view</em> of the original array, not a copy. Modifications to the view affect the original array. To create an independent copy, use the <code>copy()</code> method.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> a  <span class="co"># b is a view of a</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a.copy() <span class="co"># c is a copy of a</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>b[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">10</span>  <span class="co"># Modifies both a and b</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a) <span class="co"># a is modified</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(c) <span class="co"># c remains unchanged</span></span></code></pre></div>
<h2 id="array-operations">Array Operations</h2>
<h3 id="arithmetic-operations">Arithmetic Operations</h3>
<p>NumPy supports element-wise arithmetic operations on arrays. These operations are vectorized, meaning they are applied to each element of the array without explicit looping. Standard arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>) work directly on arrays.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.array([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>])</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a <span class="op">+</span> b  <span class="co"># Element-wise addition</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> a <span class="op">*</span> b  <span class="co"># Element-wise multiplication</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>e <span class="op">=</span> a <span class="op">/</span> b  <span class="co"># Element-wise division</span></span></code></pre></div>
<h3 id="logical-operations">Logical Operations</h3>
<p>NumPy provides element-wise logical operations:</p>
<ul>
<li><code>np.logical_and(a, b)</code>: Element-wise logical AND.</li>
<li><code>np.logical_or(a, b)</code>: Element-wise logical OR.</li>
<li><code>np.logical_not(a)</code>: Element-wise logical NOT.</li>
<li><code>np.logical_xor(a, b)</code>: Element-wise logical XOR.</li>
</ul>
<p>These functions return boolean arrays.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([<span class="va">True</span>, <span class="va">False</span>, <span class="va">True</span>])</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.array([<span class="va">False</span>, <span class="va">True</span>, <span class="va">True</span>])</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> np.logical_and(a, b) <span class="co"># Returns [False, False, True]</span></span></code></pre></div>
<h3 id="comparison-operations">Comparison Operations</h3>
<p>Element-wise comparison operations are also supported:</p>
<ul>
<li><code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li>
</ul>
<p>These return boolean arrays indicating the result of the comparison at each element.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.array([<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>])</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a <span class="op">==</span> b  <span class="co"># Returns [False, True, False]</span></span></code></pre></div>
<h3 id="broadcasting">Broadcasting</h3>
<p>Broadcasting is a powerful mechanism that allows NumPy to perform operations on arrays of different shapes under certain conditions. When operating on arrays with different shapes, NumPy attempts to “stretch” or “expand” the smaller array to match the shape of the larger array before performing the operation. This avoids explicit looping and enhances performance. The rules for broadcasting are detailed in the NumPy documentation.</p>
<h3 id="linear-algebra">Linear Algebra</h3>
<p>NumPy’s <code>linalg</code> module provides functions for linear algebra operations:</p>
<ul>
<li><code>np.linalg.solve(A, b)</code>: Solves the linear equation Ax = b.</li>
<li><code>np.linalg.inv(A)</code>: Computes the inverse of a matrix.</li>
<li><code>np.linalg.det(A)</code>: Computes the determinant of a matrix.</li>
<li><code>np.linalg.eig(A)</code>: Computes eigenvalues and eigenvectors.</li>
<li><code>np.dot(a, b)</code>: Performs matrix multiplication (dot product). <code>@</code> operator also provides matrix multiplication.</li>
</ul>
<h3 id="statistical-functions">Statistical Functions</h3>
<p>NumPy offers a range of statistical functions:</p>
<ul>
<li><code>np.mean(a)</code>: Computes the average.</li>
<li><code>np.median(a)</code>: Computes the median.</li>
<li><code>np.std(a)</code>: Computes the standard deviation.</li>
<li><code>np.var(a)</code>: Computes the variance.</li>
<li><code>np.min(a)</code>, <code>np.max(a)</code>: Computes the minimum and maximum values.</li>
<li><code>np.sum(a)</code>: Computes the sum of elements.</li>
<li><code>np.percentile(a, p)</code>: Computes percentiles.</li>
</ul>
<p>These functions can operate along specific axes of multi-dimensional arrays.</p>
<h3 id="mathematical-functions">Mathematical Functions</h3>
<p>NumPy provides a large number of mathematical functions, including:</p>
<ul>
<li>Trigonometric functions (<code>np.sin</code>, <code>np.cos</code>, <code>np.tan</code>, etc.)</li>
<li>Exponential and logarithmic functions (<code>np.exp</code>, <code>np.log</code>, <code>np.log10</code>, etc.)</li>
<li>Rounding functions (<code>np.round</code>, <code>np.floor</code>, <code>np.ceil</code>, etc.)</li>
<li>Other mathematical functions (<code>np.abs</code>, <code>np.sqrt</code>, etc.)</li>
</ul>
<p>These functions operate element-wise on arrays. Many have variants that handle complex numbers appropriately.</p>
<h2 id="advanced-array-manipulation">Advanced Array Manipulation</h2>
<h3 id="fancy-indexing">Fancy Indexing</h3>
<p>Fancy indexing allows you to select array elements using integer arrays as indices. This enables selecting arbitrary subsets of array elements, not just contiguous slices.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">40</span>, <span class="dv">50</span>])</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>indices <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">0</span>]) <span class="co">#Select elements at indices 1,3, and 0.</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>selected_elements <span class="op">=</span> a[indices] <span class="co">#Output: array([20, 40, 10])</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co">#With multi-dimensional array:</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">4</span>], [<span class="dv">5</span>, <span class="dv">6</span>]])</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>row_indices <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">2</span>])</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>col_indices <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">0</span>])</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>selected_elements <span class="op">=</span> b[row_indices, col_indices] <span class="co">#Output: array([2, 5])</span></span></code></pre></div>
<p>Note that fancy indexing always creates a copy of the selected data, not a view.</p>
<h3 id="boolean-indexing">Boolean Indexing</h3>
<p>Boolean indexing selects elements based on a boolean array. The boolean array must have the same shape as the array being indexed.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>])</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>bool_index <span class="op">=</span> np.array([<span class="va">True</span>, <span class="va">False</span>, <span class="va">True</span>, <span class="va">False</span>, <span class="va">True</span>])</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>selected_elements <span class="op">=</span> a[bool_index] <span class="co">#Output: array([1, 3, 5])</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">#Combining with comparison operators:</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.array([<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">40</span>, <span class="dv">50</span>])</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>selected_elements <span class="op">=</span> b[b <span class="op">&gt;</span> <span class="dv">25</span>] <span class="co">#Output: array([30, 40, 50])</span></span></code></pre></div>
<h3 id="structured-arrays">Structured Arrays</h3>
<p>Structured arrays allow you to store different data types within a single array. Each element of the array is a record containing multiple fields, each with its own data type. They are defined using a compound <code>dtype</code>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>person_dtype <span class="op">=</span> np.dtype([(<span class="st">'name'</span>, <span class="st">'U10'</span>), (<span class="st">'age'</span>, <span class="st">'i4'</span>), (<span class="st">'height'</span>, <span class="st">'f4'</span>)])</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>people <span class="op">=</span> np.array([(<span class="st">'Alice'</span>, <span class="dv">30</span>, <span class="fl">5.8</span>), (<span class="st">'Bob'</span>, <span class="dv">25</span>, <span class="fl">6.0</span>)], dtype<span class="op">=</span>person_dtype)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(people[<span class="st">'name'</span>]) <span class="co"># Accesses the 'name' field</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(people[<span class="dv">0</span>][<span class="st">'age'</span>]) <span class="co"># Accesses the 'age' field of the first record</span></span></code></pre></div>
<h3 id="record-arrays">Record Arrays</h3>
<p>Record arrays are a special case of structured arrays where accessing fields is more Pythonic; they behave somewhat like Python objects, allowing attribute-style access to fields. You can create a record array by using the <code>np.rec.array()</code> constructor. However, it’s generally recommended to use structured arrays directly for better performance and consistency.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>person_dtype <span class="op">=</span> np.dtype([(<span class="st">'name'</span>, <span class="st">'U10'</span>), (<span class="st">'age'</span>, <span class="st">'i4'</span>), (<span class="st">'height'</span>, <span class="st">'f4'</span>)])</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>people_rec <span class="op">=</span> np.rec.array([(<span class="st">'Alice'</span>, <span class="dv">30</span>, <span class="fl">5.8</span>), (<span class="st">'Bob'</span>, <span class="dv">25</span>, <span class="fl">6.0</span>)], dtype<span class="op">=</span>person_dtype)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(people_rec.name) <span class="co"># Access the 'name' field using attribute style</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(people_rec[<span class="dv">0</span>].age) <span class="co"># Access the 'age' field of first record</span></span></code></pre></div>
<p>While offering convenient attribute access, record arrays might have a slight performance overhead compared to structured arrays. For most use cases, the flexibility and performance of structured arrays make them preferable.</p>
<h2 id="input-and-output">Input and Output</h2>
<h3 id="saving-and-loading-arrays">Saving and Loading Arrays</h3>
<p>NumPy provides efficient ways to save and load arrays to disk, minimizing I/O overhead. The primary functions are <code>np.save()</code> and <code>np.load()</code>:</p>
<ul>
<li><p><strong><code>np.save(file, arr)</code>:</strong> Saves a single array to a <code>.npy</code> file in a binary format. This format is optimized for NumPy arrays and allows for fast loading.</p></li>
<li><p><strong><code>np.savez(file, *arrays, **kwargs)</code>:</strong> Saves multiple arrays to a single <code>.npz</code> file. This is useful when you need to store related arrays together. You can optionally specify names for each array using keyword arguments.</p></li>
<li><p><strong><code>np.load(file)</code>:</strong> Loads an array from a <code>.npy</code> or <code>.npz</code> file.</p></li>
</ul>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">4</span>]])</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">'my_array.npy'</span>, arr) <span class="co">#Save the array to a .npy file.</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>loaded_arr <span class="op">=</span> np.load(<span class="st">'my_array.npy'</span>) <span class="co">#Load the array from the file.</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>np.savez(<span class="st">'multiple_arrays.npz'</span>, array1<span class="op">=</span>arr, array2<span class="op">=</span>np.arange(<span class="dv">5</span>)) <span class="co">#Save multiple arrays to a .npz file</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>loaded_arrays <span class="op">=</span> np.load(<span class="st">'multiple_arrays.npz'</span>) <span class="co">#Load multiple arrays.</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(loaded_arrays[<span class="st">'array1'</span>]) <span class="co">#Access individual arrays using keys</span></span></code></pre></div>
<h3 id="working-with-text-files">Working with Text Files</h3>
<p>NumPy provides functions for reading and writing arrays from/to text files. These are generally less efficient than binary formats for large arrays but are convenient for smaller datasets or when human readability is important.</p>
<ul>
<li><p><strong><code>np.savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\n', header='', footer='', comments='# ')</code>:</strong> Saves an array to a text file. <code>fmt</code> specifies the format string for each element. <code>delimiter</code> specifies the character used to separate elements.</p></li>
<li><p><strong><code>np.loadtxt(fname, dtype=float, delimiter=' ', converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding='bytes')</code>:</strong> Loads an array from a text file. <code>dtype</code> specifies the data type of the elements. <code>delimiter</code> specifies the element separator. <code>skiprows</code> skips initial rows. <code>usecols</code> selects specific columns.</p></li>
</ul>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> np.array([[<span class="fl">1.1</span>, <span class="fl">2.2</span>], [<span class="fl">3.3</span>, <span class="fl">4.4</span>]])</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>np.savetxt(<span class="st">'my_array.txt'</span>, arr, fmt<span class="op">=</span><span class="st">'</span><span class="sc">%.2f</span><span class="st">'</span>, delimiter<span class="op">=</span><span class="st">','</span>) <span class="co">#Save to text file</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>loaded_arr <span class="op">=</span> np.loadtxt(<span class="st">'my_array.txt'</span>, delimiter<span class="op">=</span><span class="st">','</span>) <span class="co">#Load from text file</span></span></code></pre></div>
<h3 id="working-with-binary-files">Working with Binary Files</h3>
<p>For very large arrays or when maximum efficiency is crucial, binary files offer significant advantages over text files. NumPy’s <code>tofile()</code> and <code>fromfile()</code> methods provide a direct way to interact with binary files. However, these methods require more manual handling of data types and file formats, compared to the <code>.npy</code> and <code>.npz</code> formats discussed above.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>], dtype<span class="op">=</span>np.int32)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>arr.tofile(<span class="st">'my_array.bin'</span>) <span class="co">#Write to a binary file.</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>new_arr <span class="op">=</span> np.fromfile(<span class="st">'my_array.bin'</span>, dtype<span class="op">=</span>np.int32) <span class="co">#Read from binary file.</span></span></code></pre></div>
<p>Remember to specify the correct <code>dtype</code> when loading from binary files to ensure correct interpretation of the data. Structured arrays might require more intricate handling of binary file I/O. Using <code>np.save</code> and <code>np.load</code> is generally recommended for better portability and ease of use, unless specific reasons necessitate direct binary file operations.</p>
<h2 id="linear-algebra-with-numpy">Linear Algebra with NumPy</h2>
<p>NumPy’s <code>linalg</code> module provides a comprehensive suite of functions for linear algebra operations. These functions are highly optimized and leverage LAPACK and other efficient linear algebra libraries for performance. Note that all matrix operations in this section assume that the input arrays are two-dimensional.</p>
<h3 id="matrix-operations">Matrix Operations</h3>
<p>NumPy offers several fundamental matrix operations:</p>
<ul>
<li><strong>Matrix multiplication:</strong> The <code>@</code> operator (or <code>np.matmul()</code>) performs matrix multiplication. It handles broadcasting rules for compatible dimensions.</li>
</ul>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">4</span>]])</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> np.array([[<span class="dv">5</span>, <span class="dv">6</span>], [<span class="dv">7</span>, <span class="dv">8</span>]])</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> A <span class="op">@</span> B  <span class="co"># Matrix multiplication</span></span></code></pre></div>
<ul>
<li><strong>Matrix transpose:</strong> The <code>.T</code> attribute or <code>np.transpose()</code> returns the transpose of a matrix.</li>
</ul>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>A_transpose <span class="op">=</span> A.T</span></code></pre></div>
<ul>
<li><strong>Matrix inverse:</strong> <code>np.linalg.inv(A)</code> computes the inverse of a square matrix. The matrix must be square and non-singular (determinant non-zero).</li>
</ul>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>A_inverse <span class="op">=</span> np.linalg.inv(A)</span></code></pre></div>
<ul>
<li><strong>Determinant:</strong> <code>np.linalg.det(A)</code> calculates the determinant of a square matrix.</li>
</ul>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>determinant <span class="op">=</span> np.linalg.det(A)</span></code></pre></div>
<h3 id="eigenvalues-and-eigenvectors">Eigenvalues and Eigenvectors</h3>
<p>Eigenvalues and eigenvectors are fundamental concepts in linear algebra. NumPy provides functions to compute them:</p>
<ul>
<li><strong><code>np.linalg.eig(A)</code>:</strong> Computes the eigenvalues and right eigenvectors of a square matrix. It returns two arrays: one containing the eigenvalues and the other containing the corresponding eigenvectors.</li>
</ul>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>eigenvalues, eigenvectors <span class="op">=</span> np.linalg.eig(A)</span></code></pre></div>
<p>The eigenvectors are normalized (unit length).</p>
<h3 id="singular-value-decomposition-svd">Singular Value Decomposition (SVD)</h3>
<p>Singular Value Decomposition is a factorization of a matrix into three matrices: U, Σ, and V*. It’s useful for dimensionality reduction, solving least squares problems, and more.</p>
<ul>
<li><strong><code>np.linalg.svd(A)</code>:</strong> Computes the SVD of a matrix A. It returns three arrays: U, S (singular values), and Vh (conjugate transpose of V).</li>
</ul>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>U, S, Vh <span class="op">=</span> np.linalg.svd(A)</span></code></pre></div>
<h3 id="solving-linear-equations">Solving Linear Equations</h3>
<p>NumPy efficiently solves systems of linear equations:</p>
<ul>
<li><strong><code>np.linalg.solve(A, b)</code>:</strong> Solves the linear equation Ax = b, where A is a square matrix and b is a vector. It returns the solution vector x. A must be invertible.</li>
</ul>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([[<span class="dv">2</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>]])</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.array([<span class="dv">8</span>, <span class="dv">1</span>])</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linalg.solve(A, b)  <span class="co">#Solves for x in Ax = b</span></span></code></pre></div>
<p>For overdetermined or underdetermined systems (more equations than unknowns, or vice versa), consider using least-squares methods (<code>np.linalg.lstsq()</code>). <code>np.linalg.lstsq()</code> finds the solution that minimizes the sum of the squares of the differences between Ax and b. It’s particularly valuable when dealing with noisy or inconsistent data.</p>
<h2 id="random-number-generation">Random Number Generation</h2>
<p>NumPy’s <code>random</code> module (now a submodule of <code>numpy.random</code>) provides functions for generating pseudo-random numbers from various distributions. It’s crucial to understand that these are <em>pseudo-random</em> numbers; they are generated deterministically based on an initial state (seed). While they appear random for most purposes, they are not truly random.</p>
<h3 id="generating-random-numbers">Generating Random Numbers</h3>
<p>The most basic function is <code>numpy.random.rand()</code>, which generates random numbers from a uniform distribution between 0 and 1:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co">#Generate a single random number</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>random_number <span class="op">=</span> np.random.rand()</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co">#Generate an array of random numbers</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>random_array <span class="op">=</span> np.random.rand(<span class="dv">3</span>, <span class="dv">2</span>) <span class="co"># 3x2 array of random numbers between 0 and 1.</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="co">#Generate random integers</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>random_integers <span class="op">=</span> np.random.randint(low<span class="op">=</span><span class="dv">1</span>, high<span class="op">=</span><span class="dv">10</span>, size<span class="op">=</span><span class="dv">5</span>) <span class="co"># 5 random integers between 1 and 9 (inclusive).</span></span></code></pre></div>
<p><code>numpy.random.random()</code> is an alias for <code>numpy.random.rand()</code>. For random numbers from a standard normal distribution (mean=0, standard deviation=1), use <code>numpy.random.randn()</code>.</p>
<h3 id="distributions">Distributions</h3>
<p>Beyond uniform and normal distributions, NumPy provides functions for generating random numbers from various other probability distributions:</p>
<ul>
<li><strong><code>numpy.random.uniform(low=0.0, high=1.0, size=None)</code>:</strong> Uniform distribution.</li>
<li><strong><code>numpy.random.normal(loc=0.0, scale=1.0, size=None)</code>:</strong> Normal (Gaussian) distribution.</li>
<li><strong><code>numpy.random.binomial(n, p, size=None)</code>:</strong> Binomial distribution.</li>
<li><strong><code>numpy.random.poisson(lam=1.0, size=None)</code>:</strong> Poisson distribution.</li>
<li><strong><code>numpy.random.exponential(scale=1.0, size=None)</code>:</strong> Exponential distribution.</li>
<li><strong>And many others:</strong> The <code>numpy.random</code> module offers a wide selection of probability distributions. Refer to the NumPy documentation for a complete list.</li>
</ul>
<p>Example of generating random numbers from a normal distribution:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>random_normal <span class="op">=</span> np.random.normal(loc<span class="op">=</span><span class="dv">5</span>, scale<span class="op">=</span><span class="dv">2</span>, size<span class="op">=</span><span class="dv">10</span>) <span class="co">#10 random numbers from a normal distribution with mean 5 and standard deviation 2.</span></span></code></pre></div>
<h3 id="seeding">Seeding</h3>
<p>The <code>numpy.random.seed()</code> function sets the seed for the random number generator. This ensures that the sequence of random numbers is reproducible. If you call <code>numpy.random.seed()</code> with the same value multiple times, you will get the same sequence of random numbers.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>) <span class="co">#Sets the seed to 42.</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>random_numbers <span class="op">=</span> np.random.rand(<span class="dv">5</span>) <span class="co">#Will generate same random numbers every time you run this block.</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>) <span class="co">#Resetting to the same seed</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>same_random_numbers <span class="op">=</span> np.random.rand(<span class="dv">5</span>) <span class="co">#This will be identical to the previous random_numbers array.</span></span></code></pre></div>
<p>Using a seed is essential for debugging, testing, and replicating results. Without a seed, the sequence changes every time you run your code.</p>
<h3 id="random-walks">Random Walks</h3>
<p>Random walks are often simulated using NumPy’s random number generation capabilities. A simple 1D random walk can be generated as follows:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>steps <span class="op">=</span> np.random.randint(<span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1000</span>) <span class="co">#Random steps -1, 0, or 1</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>walk <span class="op">=</span> np.cumsum(steps) <span class="co">#Cumulative sum of steps</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>plt.plot(walk)</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Step"</span>)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Position"</span>)</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"1D Random Walk"</span>)</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
<p>This code generates a sequence of random steps (-1, 0, or 1) and then calculates the cumulative sum to represent the position over time. Similar techniques can be applied to simulate higher-dimensional random walks. The <code>matplotlib</code> library is used here for visualization; remember to install it if you haven’t already (<code>pip install matplotlib</code>).</p>
<h2 id="fourier-transforms">Fourier Transforms</h2>
<p>NumPy’s <code>fft</code> module provides functions for computing Discrete Fourier Transforms (DFTs) and their inverse. The core functionality leverages highly optimized FFT algorithms for efficiency.</p>
<h3 id="discrete-fourier-transforms-dft">Discrete Fourier Transforms (DFT)</h3>
<p>The Discrete Fourier Transform decomposes a sequence of equally-spaced samples of a function into its constituent frequencies. While a direct DFT computation is possible, it’s computationally expensive (O(N²), where N is the sequence length). For large sequences, the Fast Fourier Transform (FFT) is significantly more efficient.</p>
<p>NumPy’s <code>numpy.fft.fft()</code> computes the DFT of a sequence:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample signal (a simple sine wave)</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">100</span>, endpoint<span class="op">=</span><span class="va">False</span>)  <span class="co"># 100 points between 0 and 1</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>signal <span class="op">=</span> np.sin(<span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">*</span> <span class="dv">5</span> <span class="op">*</span> t)  <span class="co"># Sine wave with frequency 5 Hz</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute DFT</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>frequencies <span class="op">=</span> np.fft.fftfreq(<span class="bu">len</span>(signal))  <span class="co"># Frequencies corresponding to DFT output</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>dft_result <span class="op">=</span> np.fft.fft(signal)</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the magnitude spectrum</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>plt.plot(np.<span class="bu">abs</span>(dft_result))</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Frequency (index)'</span>)</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Magnitude'</span>)</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Magnitude Spectrum'</span>)</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
<p>Note that the frequencies are in terms of index. To obtain true frequencies, one would need to scale according to the sampling rate. The <code>numpy.fft.fftfreq()</code> function helps obtain the corresponding frequencies.</p>
<h3 id="fast-fourier-transforms-fft">Fast Fourier Transforms (FFT)</h3>
<p>The Fast Fourier Transform (FFT) is a highly optimized algorithm for computing the DFT. It reduces the computational complexity from O(N²) to O(N log N), making it significantly faster for large datasets. NumPy’s <code>numpy.fft.fft()</code> uses an efficient FFT implementation under the hood. Therefore, directly using <code>numpy.fft.fft()</code> is generally the preferred method; you rarely need to explicitly call a separate FFT function.</p>
<h3 id="applications-of-fft">Applications of FFT</h3>
<p>The FFT has widespread applications in various fields:</p>
<ul>
<li><p><strong>Signal processing:</strong> Analyzing and filtering signals, identifying frequencies in audio, images, and other time-series data.</p></li>
<li><p><strong>Image processing:</strong> Image compression (JPEG), edge detection, image enhancement.</p></li>
<li><p><strong>Spectroscopy:</strong> Analyzing spectral data to identify chemical compounds or materials.</p></li>
<li><p><strong>Scientific computing:</strong> Solving partial differential equations, analyzing time-series data from simulations.</p></li>
<li><p><strong>Data analysis:</strong> Detecting periodic patterns or trends in data.</p></li>
</ul>
<p>The FFT’s speed and efficiency make it an essential tool for processing and analyzing large datasets in many scientific and engineering domains. Many algorithms leverage the FFT for efficient computation, even if the core problem isn’t directly about frequency analysis. For instance, convolution and correlation operations are often implemented much faster using the FFT’s properties.</p>
<h2 id="polynomials">Polynomials</h2>
<p>NumPy provides tools for working with polynomials, offering efficient ways to represent, manipulate, and analyze them. The core functionality resides within <code>numpy.polynomial</code> (although some polynomial-related functions exist elsewhere in NumPy). This section focuses on the <code>numpy.polynomial.polynomial</code> module, which works with polynomials in the standard power basis (i.e., a₀ + a₁x + a₂x² + …).</p>
<h3 id="polynomial-representation">Polynomial Representation</h3>
<p>Polynomials in NumPy are typically represented as one-dimensional arrays of coefficients. The coefficients are ordered from lowest to highest power. For example, the polynomial 2x² + 3x - 1 is represented by the array <code>[ -1, 3, 2]</code>.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.polynomial.polynomial <span class="im">as</span> poly</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co">#Represent the polynomial 2x^2 + 3x - 1</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>coefficients <span class="op">=</span> np.array([<span class="op">-</span><span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>])</span></code></pre></div>
<p>The <code>poly</code> module (imported above as a convenient alias) provides functions to work directly with this coefficient representation.</p>
<h3 id="polynomial-operations">Polynomial Operations</h3>
<p>The <code>poly</code> module supports various operations on polynomials:</p>
<ul>
<li><strong>Evaluation:</strong> <code>poly.polyval(x, c)</code> evaluates a polynomial with coefficients <code>c</code> at point(s) <code>x</code>. <code>x</code> can be a scalar, a list, or an array.</li>
</ul>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>x_values <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> poly.polyval(x_values, coefficients) <span class="co">#Evaluate the polynomial at x=1,2,3</span></span></code></pre></div>
<ul>
<li><strong>Addition/Subtraction:</strong> Polynomials can be added or subtracted by adding or subtracting their corresponding coefficients.</li>
</ul>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>coefficients1 <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>coefficients2 <span class="op">=</span> np.array([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>])</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>sum_coeffs <span class="op">=</span> coefficients1 <span class="op">+</span> coefficients2 <span class="co">#Element-wise addition of coefficients</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>diff_coeffs <span class="op">=</span> coefficients1 <span class="op">-</span> coefficients2 <span class="co">#Element-wise subtraction of coefficients</span></span></code></pre></div>
<ul>
<li><strong>Multiplication:</strong> <code>poly.polymul(c1, c2)</code> performs polynomial multiplication.</li>
</ul>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>product_coeffs <span class="op">=</span> poly.polymul(coefficients1, coefficients2) <span class="co">#Polynomial multiplication</span></span></code></pre></div>
<ul>
<li><p><strong>Division:</strong> <code>poly.polydiv(c1, c2)</code> performs polynomial division, returning the quotient and remainder.</p></li>
<li><p><strong>Derivative:</strong> <code>poly.polyder(c)</code> computes the derivative of a polynomial.</p></li>
<li><p><strong>Integration:</strong> <code>poly.polyint(c)</code> computes the indefinite integral of a polynomial (requires specifying a constant of integration).</p></li>
<li><p><strong>Roots:</strong> Finding the roots is covered in the next section.</p></li>
</ul>
<h3 id="roots-of-polynomials">Roots of Polynomials</h3>
<p><code>poly.polyroots(c)</code> calculates the roots (zeros) of a polynomial with coefficients <code>c</code>. It returns an array containing the roots.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>coefficients <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>]) <span class="co"># Represents x^2 -3x + 2</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>roots <span class="op">=</span> poly.polyroots(coefficients) <span class="co"># Roots are 1 and 2</span></span></code></pre></div>
<p>The number of roots is equal to the polynomial’s degree (one less than the length of the coefficient array). Complex roots are also returned if the polynomial has them. The <code>poly</code> module offers additional functionalities, including fitting polynomials to data and working with polynomial interpolations, as documented in the NumPy reference.</p>
<h2 id="numpy-and-other-libraries">NumPy and Other Libraries</h2>
<p>NumPy’s versatility and efficiency make it a cornerstone of the Python scientific computing ecosystem. Its close integration with other libraries significantly enhances their capabilities.</p>
<h3 id="numpy-with-scipy">NumPy with SciPy</h3>
<p>SciPy (Scientific Python) builds upon NumPy, providing a vast collection of algorithms and functions for scientific and technical computing. SciPy heavily relies on NumPy arrays for its data structures, making the combination incredibly powerful. Many SciPy functions directly accept NumPy arrays as input, enabling seamless data transfer and processing.</p>
<p>Example: SciPy’s <code>optimize</code> module for numerical optimization often uses NumPy arrays to represent the objective function and its parameters:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> minimize</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="co">#Define objective function (using NumPy arrays)</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> objective_function(x):</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">sum</span>(x<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="co">#Initial guess</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="co">#Optimization using minimize from scipy.optimize</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> minimize(objective_function, x0)</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result.x) <span class="co">#Optimal solution (a NumPy array)</span></span></code></pre></div>
<h3 id="numpy-with-pandas">NumPy with Pandas</h3>
<p>Pandas is a powerful library for data manipulation and analysis. Pandas’ core data structure, the DataFrame, is built on top of NumPy arrays. This tight integration allows for efficient data handling and manipulation. Pandas Series (one-dimensional labeled arrays) are essentially specialized NumPy arrays. Many Pandas operations internally leverage NumPy’s array operations for performance.</p>
<p>Example: Performing calculations on a Pandas DataFrame column often involves using NumPy functions directly:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> {<span class="st">'A'</span>: [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>], <span class="st">'B'</span>: [<span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>]}</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(data)</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'C'</span>] <span class="op">=</span> np.sqrt(df[<span class="st">'A'</span>]) <span class="co">#Applies NumPy's sqrt function to column 'A'</span></span></code></pre></div>
<h3 id="numpy-with-matplotlib">NumPy with Matplotlib</h3>
<p>Matplotlib is a widely-used plotting library. It seamlessly integrates with NumPy arrays for efficient data visualization. Matplotlib plotting functions readily accept NumPy arrays as input for plotting lines, scatter plots, histograms, images, and other types of visualizations.</p>
<p>Example: Creating a line plot using Matplotlib and NumPy:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">100</span>) <span class="co"># NumPy array for x-coordinates</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.sin(x) <span class="co"># NumPy array for y-coordinates</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y)</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"x"</span>)</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"sin(x)"</span>)</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Sine Wave Plot"</span>)</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
<p>In summary, NumPy forms a strong foundation for many scientific and data-centric Python libraries. Understanding its integration with SciPy, Pandas, Matplotlib, and other libraries is essential for leveraging their full capabilities and optimizing performance in data science and scientific computing applications.</p>
<h2 id="advanced-topics">Advanced Topics</h2>
<p>This section delves into more advanced aspects of NumPy, crucial for developers aiming for optimal performance and extending NumPy’s functionality.</p>
<h3 id="memory-management">Memory Management</h3>
<p>NumPy’s memory management is crucial for its performance. Understanding these mechanisms is key to writing efficient code:</p>
<ul>
<li><p><strong>Contiguous memory:</strong> NumPy arrays strive to store data in contiguous blocks of memory for faster access. This is especially important for multi-dimensional arrays. Attributes like <code>flags['C_CONTIGUOUS']</code> and <code>flags['F_CONTIGUOUS']</code> indicate whether the data is stored in C-style (row-major) or Fortran-style (column-major) order.</p></li>
<li><p><strong>Data views:</strong> Operations like slicing often create views of the original array rather than copies. Modifying a view modifies the original array. The <code>copy()</code> method creates a true copy. Understanding this behavior is essential to avoid unintended side effects.</p></li>
<li><p><strong>Memory order:</strong> Specifying the <code>order</code> parameter when creating arrays (<code>np.array(data, order='C')</code> or <code>order='F'</code>) can influence memory layout and affect performance in certain operations.</p></li>
<li><p><strong>Buffer protocol:</strong> NumPy’s buffer protocol allows efficient data exchange with other Python objects that support the buffer interface. This facilitates interoperability with libraries written in other languages (like C or C++).</p></li>
</ul>
<p>Carefully managing memory usage (avoiding unnecessary copies) is crucial for performance, especially when dealing with large datasets.</p>
<h3 id="performance-optimization">Performance Optimization</h3>
<p>Optimizing NumPy code often involves leveraging its vectorized operations and avoiding explicit Python loops wherever possible.</p>
<ul>
<li><p><strong>Vectorization:</strong> Perform operations on entire arrays instead of iterating through individual elements. NumPy’s highly optimized functions handle vectorized operations efficiently.</p></li>
<li><p><strong>Broadcasting:</strong> Understand and utilize NumPy’s broadcasting rules to perform operations between arrays of different shapes without explicit reshaping.</p></li>
<li><p><strong>Avoid unnecessary copies:</strong> As mentioned earlier, creating unnecessary copies of arrays can significantly impact performance. Favor views wherever appropriate.</p></li>
<li><p><strong>Use appropriate data types:</strong> Choosing the right data type (<code>dtype</code>) for your arrays (e.g., <code>int32</code> instead of <code>int64</code> if possible) can reduce memory usage and improve speed.</p></li>
<li><p><strong>Profiling:</strong> Use Python profilers (like <code>cProfile</code>) to identify performance bottlenecks in your code.</p></li>
<li><p><strong>Numba/Cython:</strong> For computationally intensive operations within loops, consider using tools like Numba (just-in-time compilation) or Cython (combining Python with C) to accelerate critical sections of code.</p></li>
</ul>
<h3 id="extension-types">Extension Types</h3>
<p>NumPy allows extending its array functionality by creating custom array types (extension types). This enables creating arrays with specialized behavior or data storage. Extension types require a good understanding of NumPy’s internal C API. They are useful for specialized applications requiring highly tailored array structures or operations. This is an advanced topic requiring familiarity with C or C++.</p>
<h3 id="universal-functions-ufuncs">Universal Functions (ufuncs)</h3>
<p>Universal functions (ufuncs) are vectorized functions that operate element-wise on NumPy arrays. They are a fundamental part of NumPy’s performance. Many built-in NumPy functions are ufuncs (e.g., <code>np.sin</code>, <code>np.add</code>, <code>np.exp</code>). You can create custom ufuncs using the <code>np.frompyfunc()</code> function, although this usually requires knowledge of NumPy’s internal workings and might not yield the same performance as highly optimized built-in ufuncs. Custom ufuncs can extend NumPy’s functionality to handle specialized operations.</p>
<p>Understanding ufuncs is crucial for writing efficient numerical code that takes advantage of NumPy’s optimized vectorized execution.</p>


<footer>Copyright 2025 - Muthukrishnan</footer>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561" crossorigin="anonymous"></script>




</body></html>