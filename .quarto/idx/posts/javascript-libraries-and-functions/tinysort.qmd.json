{"title":"TinySort - A Developer's Handbook","markdown":{"yaml":{"title":"TinySort - A Developer's Handbook","categories":["JavaScript Libraries and Functions"]},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n### What is TinySort?\n\nTinySort is a lightweight JavaScript library designed for sorting HTML elements based on their text content or custom data attributes.  It offers a simple and flexible API for sorting lists and other collections of elements, handling various data types and sorting orders with ease. Unlike more comprehensive JavaScript libraries, TinySort focuses solely on sorting, making it incredibly fast and efficient, especially for large datasets.\n\n### Why use TinySort?\n\nTinySort is ideal when you need a quick and efficient way to sort HTML elements without the overhead of a larger, more feature-rich library. Its key advantages include:\n\n* **Lightweight:** TinySort has a small file size, minimizing loading times and improving page performance.\n* **Fast:** It's optimized for speed, making it suitable for sorting even extensive lists of elements.\n* **Flexible:**  Supports various sorting options, including ascending/descending order, case-insensitive sorting, and sorting by custom data attributes.\n* **Easy to use:**  The API is simple and intuitive, requiring minimal code to integrate into your projects.\n* **No dependencies:** TinySort doesn't require any other libraries, making it easy to include in your projects.\n\n\n### Installation\n\nTinySort can be easily installed via several methods:\n\n\n* **Download:** Download the `tinysort.js` file from the project's website and include it in your HTML file using a `<script>` tag:\n\n```html\n<script src=\"tinysort.js\"></script>\n```\n\n* **CDN:** Use a CDN like jsDelivr:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/tinysort@3.0.0/tinysort.min.js\"></script>\n```  (Note: Always check the latest version number on jsDelivr or another CDN)\n\n* **npm:** If you're using npm, install it with:\n\n```bash\nnpm install tinysort\n```\nThen require it in your code.\n\n\n### Basic Usage\n\nThe core function of TinySort is simply `tinysort()`.  To sort a list of elements,  select them using a CSS selector and pass it as the argument:\n\n```javascript\ntinysort('ul li'); // Sorts list items in an unordered list.\n```\n\nThis will sort the list items alphabetically in ascending order based on their text content.  For descending order, add the `order` option:\n\n\n```javascript\ntinysort('ul li', {order:'desc'}); //Sorts in descending order\n```\n\nTo sort by a data attribute, use the `data` option:\n\n\n```javascript\ntinysort('div.item', {data:'sortvalue'}); //Sorts divs with class 'item' by the 'sortvalue' attribute.\n```\n\nTinySort offers several other options for more fine-grained control over the sorting process. These options are detailed in the [Options] section (this section would appear later in a full manual).  Refer to the full documentation for a complete list of available options and examples.\n\n\n## Core Functionality\n\n### Sorting Arrays\n\nWhile TinySort primarily targets DOM elements, it can also sort JavaScript arrays.  The `tinysort` function accepts arrays as input, provided you specify the `selector` option to `null`.  The array elements should be strings or numbers suitable for comparison.\n\n```javascript\nlet myArray = ['banana', 'apple', 'cherry'];\ntinysort(myArray, { selector: null });\nconsole.log(myArray); // Output: ['apple', 'banana', 'cherry']\n```\n\nNote that sorting an array directly modifies the original array.\n\n\n### Sorting Objects\n\nTinySort can sort arrays of objects.  In this case, you must specify the property of each object to use for sorting via the `data` option.\n\n\n```javascript\nlet myObjects = [\n  { name: 'banana', value: 3 },\n  { name: 'apple', value: 1 },\n  { name: 'cherry', value: 2 }\n];\n\ntinysort(myObjects, { selector: null, data: 'value' });\nconsole.log(myObjects); // Output: [{ name: 'apple', value: 1 }, { name: 'cherry', value: 2 }, { name: 'banana', value: 3 }]\n\n\ntinysort(myObjects, { selector: null, data: 'name' });\nconsole.log(myObjects); // Output: [{ name: 'apple', value: 1 }, { name: 'banana', value: 3 }, { name: 'cherry', value: 2 }]\n```\n\nAgain, the original array is modified.\n\n### Sorting by Multiple Attributes\n\nTinySort allows for sorting by multiple attributes. Specify these attributes as an array in the `data` option.  TinySort will prioritize the first attribute; if elements are equal based on the first attribute, it will then use the second, and so on.\n\n```javascript\nlet myObjects = [\n    { category: 'Fruit', name: 'Banana', value: 3 },\n    { category: 'Fruit', name: 'Apple', value: 1 },\n    { category: 'Vegetable', name: 'Carrot', value: 2 },\n    { category: 'Fruit', name: 'Apple', value: 5 },\n];\n\ntinysort(myObjects, { selector: null, data: ['category', 'name', 'value'] });\nconsole.log(myObjects);\n// Output will be sorted first by category, then by name, then by value within each category.\n```\n\n\n### Data Types\n\nTinySort handles a variety of data types. While it primarily sorts strings, it can also handle numbers effectively when sorting by data attributes containing numeric values or when sorting arrays of numbers.  For other data types, ensure they can be converted to strings for comparison purposes. Note that for consistent sorting, it is recommended to use consistent data types within a single sort operation.\n\n\n### Case Sensitivity\n\nBy default, TinySort performs case-sensitive sorting. To perform a case-insensitive sort, use the `ignoreCase` option:\n\n```javascript\ntinysort('ul li', { ignoreCase: true }); // Case-insensitive sort\n```\n\nThis applies to both text content and data attribute values.  For number-based sorts, case sensitivity is irrelevant.\n\n\n## Advanced Options\n\n### Custom Sort Functions\n\nFor more complex sorting logic beyond simple alphabetical or numerical order, TinySort allows you to provide a custom comparison function using the `cmp` option.  The `cmp` option should be a function that accepts two arguments (a and b), representing the values being compared, and returns:\n\n*   `-1`: if `a` should come before `b`\n*   `0`: if `a` and `b` are equal\n*   `1`: if `a` should come after `b`\n\n\n```javascript\ntinysort('ul li', {\n    cmp: function(a, b) {\n        //Custom comparison logic here. Example: Reverse alphabetical order.\n        a = a.textContent.toLowerCase();\n        b = b.textContent.toLowerCase();\n        if (a < b) return 1;\n        if (a > b) return -1;\n        return 0;\n    }\n});\n```\n\nThis example reverses the default alphabetical order.  Remember that `a` and `b` will be the values extracted from your elements (textContent by default, or the data attribute specified with the `data` option).\n\n\n### Order Specification\n\nThe `order` option controls the sorting direction.  Its value can be:\n\n*   `\"asc\"` (ascending, the default): Sorts from A to Z or smallest to largest.\n*   `\"desc\"` (descending): Sorts from Z to A or largest to smallest.\n\n\nYou can specify this directly in the `tinysort()` call:\n\n```javascript\ntinysort('ul li', {order: 'desc'});\n```\n\n\n### Handling Null and Undefined Values\n\nTinySort handles `null` and `undefined` values gracefully. By default, these values are treated as less than any other value.  This means `null` and `undefined` elements will typically appear at the beginning of an ascending sort and the end of a descending sort.  You can customize this behavior with a custom `cmp` function if needed.\n\n\n### Nested Objects\n\nWhen sorting arrays of nested objects, you can access nested properties using dot notation within the `data` option.\n\n```javascript\nlet myObjects = [\n  { person: { name: 'Alice', age: 30 } },\n  { person: { name: 'Bob', age: 25 } },\n  { person: { name: 'Charlie', age: 35 } }\n];\n\ntinysort(myObjects, { selector: null, data: 'person.age' });\nconsole.log(myObjects); // Sorted by age\n```\n\nThis will sort the objects based on the `age` property within the nested `person` object.\n\n\n### Mixed Data Types\n\nWhile TinySort strives to handle mixed data types reasonably, itâ€™s best to maintain consistent data types within a single sorting operation for predictable results.  Inconsistencies (e.g., mixing numbers and strings) might lead to unexpected sorting orders.  If you have mixed data types, consider preprocessing your data or using a custom `cmp` function to handle comparisons appropriately.\n\n\n### Performance Considerations\n\nFor very large datasets, consider the following for optimal performance:\n\n*   **Minimize DOM manipulation:** If possible, sort data in a JavaScript array before updating the DOM.  Directly manipulating the DOM for large numbers of elements is generally slower.\n*   **Use efficient selectors:**  Use highly specific CSS selectors to minimize the number of elements TinySort needs to process.\n*   **Optimize custom `cmp` functions:** Keep custom comparison functions as concise and efficient as possible to avoid performance bottlenecks.\n*   **Consider plugins:**  For extremely large datasets or particularly complex sorting requirements, you might want to explore other optimized libraries specialized in large-scale data sorting.\n\n\n\n\n## Selectors and Filters\n\n### Using CSS Selectors\n\nTinySort uses standard CSS selectors to target the elements to be sorted.  You can select elements by their tag name, class, ID, or any valid CSS selector combination.\n\n```javascript\ntinysort('ul li');          // Sorts all list items within unordered lists.\ntinysort('.my-class');      // Sorts all elements with the class 'my-class'.\ntinysort('#my-id');         // Sorts the element with the ID 'my-id' (though this is usually not what you want to sort).\ntinysort('div.item p');    // Sorts all paragraph elements within divs with class 'item'.\n```\n\nEnsure your selector accurately targets the elements you intend to sort.  If the selector doesn't match any elements, TinySort won't throw an error but simply won't perform any sorting.\n\n\n### Filtering Elements\n\nTinySort allows filtering of elements before sorting using the `filter` option.  The `filter` option accepts a function that takes an element as input and returns `true` if the element should be included in the sort, and `false` otherwise.\n\n```javascript\ntinysort('li', {\n    filter: function(element) {\n        return element.textContent.length > 5; //Filter elements with text longer than 5 characters.\n    }\n});\n```\n\nThis example will only sort list items with text content longer than five characters.  The filtering happens *before* the sorting process, so only the filtered elements will be included in the sorted output.\n\n\n### Chaining Selectors and Filters\n\nYou can combine CSS selectors and filters to precisely target and sort specific sets of elements.\n\n```javascript\ntinysort('ul.my-list li.item', {\n    filter: function(element) {\n        return parseInt(element.dataset.value, 10) > 10; //Filter items with data-value > 10\n    }\n});\n```\n\nThis sorts list items with the class `item` within unordered lists with the class `my-list`, but only includes items where the `data-value` attribute is greater than 10.  The selector narrows down the initial set of elements, and the filter further refines the set *before* sorting.\n\n\n### Examples of Complex Filtering\n\nMore complex filtering scenarios can be achieved by combining multiple conditions within the filter function.\n\n```javascript\ntinysort('div.product', {\n    filter: function(element) {\n        const price = parseFloat(element.dataset.price);\n        const category = element.dataset.category;\n        return price > 50 && category === 'Electronics'; //Filter products with price > 50 AND category 'Electronics'\n    }\n});\n```\n\nThis example filters product divs to include only those with a price greater than 50 and belonging to the \"Electronics\" category before sorting them. You can extend this to include any number of conditions using logical AND (`&&`) and OR (`||`) operators within the filter function.  Remember to handle potential errors such as `NaN` (Not a Number) from parsing if your data might contain non-numeric values.\n\n\n## Common Use Cases\n\n### Sorting Lists\n\nOne of the most common uses for TinySort is sorting unordered lists (`<ul>`) or ordered lists (`<ol>`).  This is straightforward:\n\n```javascript\ntinysort('ul li'); // Sorts list items alphabetically in ascending order.\ntinysort('ol li', { order: 'desc' }); // Sorts ordered list items in descending order.\n```\n\nYou can easily extend this to sort lists based on data attributes within list items, for example, sorting by price or date.\n\n\n### Sorting Tables\n\nWhile TinySort doesn't directly sort table rows, you can achieve this by targeting the table rows (`<tr>`) and specifying the column to sort by using the `data` option.  If the sorting data is within a specific cell type within a row, then specify that cell type within the data selector.  For example, to sort a table by the second column (index 1):\n\n```javascript\ntinysort('table tr', { data: 'td:nth-child(2)' }); // Sorts table rows by the second column's text content.\n```\n\nThis assumes the sorting data is in the second `<td>` element within each row.  For more complex table structures or data attributes, adjust the selector appropriately. Remember that this sorts based on text content; for numerical sorting, ensure your data is numeric.\n\n```javascript\ntinysort('table tr', { data: 'td:nth-child(2)', dataTypes: 'number' }); //Sorts table rows by the second column numerically.\n```\n\n\n### Sorting Data in a Web Application\n\nTinySort is valuable when dynamically updating content in a web application. For example, if you fetch data from an API and display it in a list, you can use TinySort to keep the list sorted as new data arrives or existing data changes.\n\n```javascript\n// ... fetch data from API and update the list ...\ntinysort('#my-list li', { data: 'data-value' }); //Sort list based on a data attribute after updating.\n```\n\nThis snippet sorts a list with the id `my-list` after the data has been dynamically updated, ensuring it remains sorted according to the `data-value` attribute.\n\n\n### Real-World Examples\n\n*   **E-commerce product listings:** Sort products by price, rating, or popularity.\n*   **Blog post listings:** Sort posts by date, title, or author.\n*   **User profiles:** Sort users by name, registration date, or activity level.\n*   **Task management applications:** Sort tasks by priority, due date, or completion status.\n*   **Dynamically updated dashboards:** Keep data visualizations sorted as new data is added.\n\n\nIn all these examples, TinySort's simplicity and efficiency make it a practical choice for managing dynamically updating sorted lists and tables within web applications. Remember to always select the elements you wish to sort and provide a suitable `data` attribute or rely on the default `textContent` comparison if you are not using the `data` option.\n\n\n## Troubleshooting\n\n### Common Errors and Solutions\n\n* **`tinysort is not defined`:** This error means TinySort hasn't been included in your HTML file correctly. Double-check that the `<script>` tag linking to `tinysort.js` is present and has the correct path.  Also, ensure it's placed after the elements you're trying to sort.\n\n* **No elements are sorted:** Verify your CSS selector accurately targets the elements you intend to sort. Use your browser's developer tools to inspect the elements and ensure they match your selector.  If you are using a filter, make sure the filter function is correctly allowing elements to pass through to be sorted.\n\n* **Elements are sorted incorrectly:**  If the sort order is unexpected, double-check your `data` option (if used).  Ensure the data attribute values you're sorting by are consistent in type (all numbers or all strings). If using a custom `cmp` function, carefully review its logic to ensure it's returning the correct comparison values (-1, 0, 1).  For numerical sorting, explicitly set `dataTypes: 'number'` to prevent lexicographical (string-based) sorting.\n\n\n* **Unexpected behavior with mixed data types:** Mixing data types (e.g., numbers and strings) within a single sort operation can lead to inconsistent results.  Ensure your data is consistently typed or use a custom `cmp` function for proper type handling.\n\n* **Performance issues with large datasets:** For very large datasets, consider the performance considerations mentioned in the Advanced Options section.  Optimize your selectors, minimize DOM manipulations, and consider alternative approaches for extremely large datasets.\n\n\n### Debugging Tips\n\n* **Use your browser's developer tools:** Inspect the elements you're trying to sort to verify your selector is working as expected and to examine the data attributes (if used).  Use the console to log values and debug your filter and `cmp` functions.\n\n* **Simplify your code:**  If you're encountering unexpected behavior, start with a minimal example to isolate the problem.  Gradually add complexity back in to identify the source of the issue.\n\n* **Test with smaller datasets:** Testing with a smaller, manageable set of data can help you identify problems more quickly before scaling to a larger dataset.\n\n\n* **Check the TinySort source code:** If you suspect a bug in TinySort itself, examine the source code to understand its internal workings. However, this should be a last resort, as most problems arise from selector or configuration issues.\n\n\n### FAQ\n\n* **Q: Can TinySort handle nested lists?** A: Yes, TinySort works recursively.  It will sort elements within nested lists based on your provided selector and options.\n\n* **Q:  Can I sort by multiple attributes simultaneously?** A: Yes, use an array in the `data` option to specify multiple attributes in the desired order of priority.\n\n* **Q: What happens if the selector doesn't match any elements?** A: No error is thrown; TinySort simply does nothing.\n\n* **Q:  Does TinySort modify the original DOM structure or create copies?** A:  TinySort reorders existing DOM elements; it does not create copies.\n\n* **Q: How can I get support or report bugs?** A: Refer to the TinySort project's repository or website for information on reporting issues and getting support.  (This should link to the actual project resources)\n\n* **Q: Is TinySort suitable for extremely large datasets?** A:  For very large datasets, consider the performance recommendations in the manual and potentially explore alternative, more highly optimized solutions.  TinySort is optimized for speed but has limitations like any other library.\n\n\n## API Reference\n\n### TinySort Function Parameters\n\nThe core `tinysort()` function accepts two parameters:\n\n1.  **`selector` (string or array):** This is the primary parameter. It specifies the elements to be sorted.  It can be:\n\n    *   A CSS selector string (e.g., `'ul li'`, `'.my-class'`, `'#my-id'`) targeting elements in the DOM.\n    *   A JavaScript array of strings or objects to be sorted directly (in which case you *must* set `selector: null`).\n\n2.  **`options` (object, optional):** This parameter is an object containing various options to customize the sorting behavior.  The available options are detailed below.  If omitted, TinySort uses default settings (ascending order, sorting by text content, case-sensitive).  Many options are described in the earlier sections of this manual.  The key options include:\n\n    *   `order`: `\"asc\"` (ascending, default) or `\"desc\"` (descending).\n    *   `data`:  Specifies the attribute or property to sort by (e.g., `'data-sort'`, `'name'`).  Can be a string for a single attribute or an array of strings for multiple attributes.\n    *   `ignoreCase`: `true` for case-insensitive sorting (default: `false`).\n    *   `place`: Controls where unsortable items (those failing filters or comparisons) should be placed within the sorted result. See the documentation for further details.\n    *   `useFlexbox`: `true` to use flexbox for reordering (use with caution).\n    *   `cmp`: A custom comparison function (see \"Custom Sort Functions\").\n    *   `selector`:  `null` when using arrays as input (required for array sorting)\n    *   `filter`: A function to filter elements before sorting.\n    *   `returns`:  How to treat the return value. See the documentation for further details.\n    *   `dataTypes`: Specify data types (e.g., `'number'`, `'date'`, `'string'`, an array of these, or a function). See the documentation for further details.\n\n\n\n### Return Values\n\nThe `tinysort()` function returns different values depending on the `returns` option:\n\n*   **Default (or `returns: 'array'`):** Returns an array of the sorted elements (DOM nodes or array elements). This default can be useful for further post-processing after sorting.\n\n*   **`returns: 'this'` (or omitted):** Returns the original `tinysort()` function itself, allowing for method chaining.   Note that this does *not* return the sorted elements directly.  It returns the function for chaining. This is mainly for convenience when using in conjunction with other libraries.\n\n*   **`returns: null`:** Returns null.  This option is useful when you only care about the side effect of sorting (the DOM elements being reordered), and don't need a return value.\n\n\n### Error Handling\n\nTinySort is designed to be robust and handle errors gracefully.  It doesn't throw JavaScript errors in most cases.  If there's a problem, such as an invalid selector or option, the function will either silently fail (no sorting occurs) or possibly produce unexpected results.  \n\nIt is crucial to use your browser's developer tools (console) to inspect the elements, check the values of your data attributes, and debug your custom functions to understand any unexpected behavior.  The lack of explicit error throwing is a design choice emphasizing the library's lightweight and non-intrusive nature. However, this also means careful debugging is essential to diagnose problems.\n\n","srcMarkdownNoYaml":"\n## Introduction\n\n### What is TinySort?\n\nTinySort is a lightweight JavaScript library designed for sorting HTML elements based on their text content or custom data attributes.  It offers a simple and flexible API for sorting lists and other collections of elements, handling various data types and sorting orders with ease. Unlike more comprehensive JavaScript libraries, TinySort focuses solely on sorting, making it incredibly fast and efficient, especially for large datasets.\n\n### Why use TinySort?\n\nTinySort is ideal when you need a quick and efficient way to sort HTML elements without the overhead of a larger, more feature-rich library. Its key advantages include:\n\n* **Lightweight:** TinySort has a small file size, minimizing loading times and improving page performance.\n* **Fast:** It's optimized for speed, making it suitable for sorting even extensive lists of elements.\n* **Flexible:**  Supports various sorting options, including ascending/descending order, case-insensitive sorting, and sorting by custom data attributes.\n* **Easy to use:**  The API is simple and intuitive, requiring minimal code to integrate into your projects.\n* **No dependencies:** TinySort doesn't require any other libraries, making it easy to include in your projects.\n\n\n### Installation\n\nTinySort can be easily installed via several methods:\n\n\n* **Download:** Download the `tinysort.js` file from the project's website and include it in your HTML file using a `<script>` tag:\n\n```html\n<script src=\"tinysort.js\"></script>\n```\n\n* **CDN:** Use a CDN like jsDelivr:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/tinysort@3.0.0/tinysort.min.js\"></script>\n```  (Note: Always check the latest version number on jsDelivr or another CDN)\n\n* **npm:** If you're using npm, install it with:\n\n```bash\nnpm install tinysort\n```\nThen require it in your code.\n\n\n### Basic Usage\n\nThe core function of TinySort is simply `tinysort()`.  To sort a list of elements,  select them using a CSS selector and pass it as the argument:\n\n```javascript\ntinysort('ul li'); // Sorts list items in an unordered list.\n```\n\nThis will sort the list items alphabetically in ascending order based on their text content.  For descending order, add the `order` option:\n\n\n```javascript\ntinysort('ul li', {order:'desc'}); //Sorts in descending order\n```\n\nTo sort by a data attribute, use the `data` option:\n\n\n```javascript\ntinysort('div.item', {data:'sortvalue'}); //Sorts divs with class 'item' by the 'sortvalue' attribute.\n```\n\nTinySort offers several other options for more fine-grained control over the sorting process. These options are detailed in the [Options] section (this section would appear later in a full manual).  Refer to the full documentation for a complete list of available options and examples.\n\n\n## Core Functionality\n\n### Sorting Arrays\n\nWhile TinySort primarily targets DOM elements, it can also sort JavaScript arrays.  The `tinysort` function accepts arrays as input, provided you specify the `selector` option to `null`.  The array elements should be strings or numbers suitable for comparison.\n\n```javascript\nlet myArray = ['banana', 'apple', 'cherry'];\ntinysort(myArray, { selector: null });\nconsole.log(myArray); // Output: ['apple', 'banana', 'cherry']\n```\n\nNote that sorting an array directly modifies the original array.\n\n\n### Sorting Objects\n\nTinySort can sort arrays of objects.  In this case, you must specify the property of each object to use for sorting via the `data` option.\n\n\n```javascript\nlet myObjects = [\n  { name: 'banana', value: 3 },\n  { name: 'apple', value: 1 },\n  { name: 'cherry', value: 2 }\n];\n\ntinysort(myObjects, { selector: null, data: 'value' });\nconsole.log(myObjects); // Output: [{ name: 'apple', value: 1 }, { name: 'cherry', value: 2 }, { name: 'banana', value: 3 }]\n\n\ntinysort(myObjects, { selector: null, data: 'name' });\nconsole.log(myObjects); // Output: [{ name: 'apple', value: 1 }, { name: 'banana', value: 3 }, { name: 'cherry', value: 2 }]\n```\n\nAgain, the original array is modified.\n\n### Sorting by Multiple Attributes\n\nTinySort allows for sorting by multiple attributes. Specify these attributes as an array in the `data` option.  TinySort will prioritize the first attribute; if elements are equal based on the first attribute, it will then use the second, and so on.\n\n```javascript\nlet myObjects = [\n    { category: 'Fruit', name: 'Banana', value: 3 },\n    { category: 'Fruit', name: 'Apple', value: 1 },\n    { category: 'Vegetable', name: 'Carrot', value: 2 },\n    { category: 'Fruit', name: 'Apple', value: 5 },\n];\n\ntinysort(myObjects, { selector: null, data: ['category', 'name', 'value'] });\nconsole.log(myObjects);\n// Output will be sorted first by category, then by name, then by value within each category.\n```\n\n\n### Data Types\n\nTinySort handles a variety of data types. While it primarily sorts strings, it can also handle numbers effectively when sorting by data attributes containing numeric values or when sorting arrays of numbers.  For other data types, ensure they can be converted to strings for comparison purposes. Note that for consistent sorting, it is recommended to use consistent data types within a single sort operation.\n\n\n### Case Sensitivity\n\nBy default, TinySort performs case-sensitive sorting. To perform a case-insensitive sort, use the `ignoreCase` option:\n\n```javascript\ntinysort('ul li', { ignoreCase: true }); // Case-insensitive sort\n```\n\nThis applies to both text content and data attribute values.  For number-based sorts, case sensitivity is irrelevant.\n\n\n## Advanced Options\n\n### Custom Sort Functions\n\nFor more complex sorting logic beyond simple alphabetical or numerical order, TinySort allows you to provide a custom comparison function using the `cmp` option.  The `cmp` option should be a function that accepts two arguments (a and b), representing the values being compared, and returns:\n\n*   `-1`: if `a` should come before `b`\n*   `0`: if `a` and `b` are equal\n*   `1`: if `a` should come after `b`\n\n\n```javascript\ntinysort('ul li', {\n    cmp: function(a, b) {\n        //Custom comparison logic here. Example: Reverse alphabetical order.\n        a = a.textContent.toLowerCase();\n        b = b.textContent.toLowerCase();\n        if (a < b) return 1;\n        if (a > b) return -1;\n        return 0;\n    }\n});\n```\n\nThis example reverses the default alphabetical order.  Remember that `a` and `b` will be the values extracted from your elements (textContent by default, or the data attribute specified with the `data` option).\n\n\n### Order Specification\n\nThe `order` option controls the sorting direction.  Its value can be:\n\n*   `\"asc\"` (ascending, the default): Sorts from A to Z or smallest to largest.\n*   `\"desc\"` (descending): Sorts from Z to A or largest to smallest.\n\n\nYou can specify this directly in the `tinysort()` call:\n\n```javascript\ntinysort('ul li', {order: 'desc'});\n```\n\n\n### Handling Null and Undefined Values\n\nTinySort handles `null` and `undefined` values gracefully. By default, these values are treated as less than any other value.  This means `null` and `undefined` elements will typically appear at the beginning of an ascending sort and the end of a descending sort.  You can customize this behavior with a custom `cmp` function if needed.\n\n\n### Nested Objects\n\nWhen sorting arrays of nested objects, you can access nested properties using dot notation within the `data` option.\n\n```javascript\nlet myObjects = [\n  { person: { name: 'Alice', age: 30 } },\n  { person: { name: 'Bob', age: 25 } },\n  { person: { name: 'Charlie', age: 35 } }\n];\n\ntinysort(myObjects, { selector: null, data: 'person.age' });\nconsole.log(myObjects); // Sorted by age\n```\n\nThis will sort the objects based on the `age` property within the nested `person` object.\n\n\n### Mixed Data Types\n\nWhile TinySort strives to handle mixed data types reasonably, itâ€™s best to maintain consistent data types within a single sorting operation for predictable results.  Inconsistencies (e.g., mixing numbers and strings) might lead to unexpected sorting orders.  If you have mixed data types, consider preprocessing your data or using a custom `cmp` function to handle comparisons appropriately.\n\n\n### Performance Considerations\n\nFor very large datasets, consider the following for optimal performance:\n\n*   **Minimize DOM manipulation:** If possible, sort data in a JavaScript array before updating the DOM.  Directly manipulating the DOM for large numbers of elements is generally slower.\n*   **Use efficient selectors:**  Use highly specific CSS selectors to minimize the number of elements TinySort needs to process.\n*   **Optimize custom `cmp` functions:** Keep custom comparison functions as concise and efficient as possible to avoid performance bottlenecks.\n*   **Consider plugins:**  For extremely large datasets or particularly complex sorting requirements, you might want to explore other optimized libraries specialized in large-scale data sorting.\n\n\n\n\n## Selectors and Filters\n\n### Using CSS Selectors\n\nTinySort uses standard CSS selectors to target the elements to be sorted.  You can select elements by their tag name, class, ID, or any valid CSS selector combination.\n\n```javascript\ntinysort('ul li');          // Sorts all list items within unordered lists.\ntinysort('.my-class');      // Sorts all elements with the class 'my-class'.\ntinysort('#my-id');         // Sorts the element with the ID 'my-id' (though this is usually not what you want to sort).\ntinysort('div.item p');    // Sorts all paragraph elements within divs with class 'item'.\n```\n\nEnsure your selector accurately targets the elements you intend to sort.  If the selector doesn't match any elements, TinySort won't throw an error but simply won't perform any sorting.\n\n\n### Filtering Elements\n\nTinySort allows filtering of elements before sorting using the `filter` option.  The `filter` option accepts a function that takes an element as input and returns `true` if the element should be included in the sort, and `false` otherwise.\n\n```javascript\ntinysort('li', {\n    filter: function(element) {\n        return element.textContent.length > 5; //Filter elements with text longer than 5 characters.\n    }\n});\n```\n\nThis example will only sort list items with text content longer than five characters.  The filtering happens *before* the sorting process, so only the filtered elements will be included in the sorted output.\n\n\n### Chaining Selectors and Filters\n\nYou can combine CSS selectors and filters to precisely target and sort specific sets of elements.\n\n```javascript\ntinysort('ul.my-list li.item', {\n    filter: function(element) {\n        return parseInt(element.dataset.value, 10) > 10; //Filter items with data-value > 10\n    }\n});\n```\n\nThis sorts list items with the class `item` within unordered lists with the class `my-list`, but only includes items where the `data-value` attribute is greater than 10.  The selector narrows down the initial set of elements, and the filter further refines the set *before* sorting.\n\n\n### Examples of Complex Filtering\n\nMore complex filtering scenarios can be achieved by combining multiple conditions within the filter function.\n\n```javascript\ntinysort('div.product', {\n    filter: function(element) {\n        const price = parseFloat(element.dataset.price);\n        const category = element.dataset.category;\n        return price > 50 && category === 'Electronics'; //Filter products with price > 50 AND category 'Electronics'\n    }\n});\n```\n\nThis example filters product divs to include only those with a price greater than 50 and belonging to the \"Electronics\" category before sorting them. You can extend this to include any number of conditions using logical AND (`&&`) and OR (`||`) operators within the filter function.  Remember to handle potential errors such as `NaN` (Not a Number) from parsing if your data might contain non-numeric values.\n\n\n## Common Use Cases\n\n### Sorting Lists\n\nOne of the most common uses for TinySort is sorting unordered lists (`<ul>`) or ordered lists (`<ol>`).  This is straightforward:\n\n```javascript\ntinysort('ul li'); // Sorts list items alphabetically in ascending order.\ntinysort('ol li', { order: 'desc' }); // Sorts ordered list items in descending order.\n```\n\nYou can easily extend this to sort lists based on data attributes within list items, for example, sorting by price or date.\n\n\n### Sorting Tables\n\nWhile TinySort doesn't directly sort table rows, you can achieve this by targeting the table rows (`<tr>`) and specifying the column to sort by using the `data` option.  If the sorting data is within a specific cell type within a row, then specify that cell type within the data selector.  For example, to sort a table by the second column (index 1):\n\n```javascript\ntinysort('table tr', { data: 'td:nth-child(2)' }); // Sorts table rows by the second column's text content.\n```\n\nThis assumes the sorting data is in the second `<td>` element within each row.  For more complex table structures or data attributes, adjust the selector appropriately. Remember that this sorts based on text content; for numerical sorting, ensure your data is numeric.\n\n```javascript\ntinysort('table tr', { data: 'td:nth-child(2)', dataTypes: 'number' }); //Sorts table rows by the second column numerically.\n```\n\n\n### Sorting Data in a Web Application\n\nTinySort is valuable when dynamically updating content in a web application. For example, if you fetch data from an API and display it in a list, you can use TinySort to keep the list sorted as new data arrives or existing data changes.\n\n```javascript\n// ... fetch data from API and update the list ...\ntinysort('#my-list li', { data: 'data-value' }); //Sort list based on a data attribute after updating.\n```\n\nThis snippet sorts a list with the id `my-list` after the data has been dynamically updated, ensuring it remains sorted according to the `data-value` attribute.\n\n\n### Real-World Examples\n\n*   **E-commerce product listings:** Sort products by price, rating, or popularity.\n*   **Blog post listings:** Sort posts by date, title, or author.\n*   **User profiles:** Sort users by name, registration date, or activity level.\n*   **Task management applications:** Sort tasks by priority, due date, or completion status.\n*   **Dynamically updated dashboards:** Keep data visualizations sorted as new data is added.\n\n\nIn all these examples, TinySort's simplicity and efficiency make it a practical choice for managing dynamically updating sorted lists and tables within web applications. Remember to always select the elements you wish to sort and provide a suitable `data` attribute or rely on the default `textContent` comparison if you are not using the `data` option.\n\n\n## Troubleshooting\n\n### Common Errors and Solutions\n\n* **`tinysort is not defined`:** This error means TinySort hasn't been included in your HTML file correctly. Double-check that the `<script>` tag linking to `tinysort.js` is present and has the correct path.  Also, ensure it's placed after the elements you're trying to sort.\n\n* **No elements are sorted:** Verify your CSS selector accurately targets the elements you intend to sort. Use your browser's developer tools to inspect the elements and ensure they match your selector.  If you are using a filter, make sure the filter function is correctly allowing elements to pass through to be sorted.\n\n* **Elements are sorted incorrectly:**  If the sort order is unexpected, double-check your `data` option (if used).  Ensure the data attribute values you're sorting by are consistent in type (all numbers or all strings). If using a custom `cmp` function, carefully review its logic to ensure it's returning the correct comparison values (-1, 0, 1).  For numerical sorting, explicitly set `dataTypes: 'number'` to prevent lexicographical (string-based) sorting.\n\n\n* **Unexpected behavior with mixed data types:** Mixing data types (e.g., numbers and strings) within a single sort operation can lead to inconsistent results.  Ensure your data is consistently typed or use a custom `cmp` function for proper type handling.\n\n* **Performance issues with large datasets:** For very large datasets, consider the performance considerations mentioned in the Advanced Options section.  Optimize your selectors, minimize DOM manipulations, and consider alternative approaches for extremely large datasets.\n\n\n### Debugging Tips\n\n* **Use your browser's developer tools:** Inspect the elements you're trying to sort to verify your selector is working as expected and to examine the data attributes (if used).  Use the console to log values and debug your filter and `cmp` functions.\n\n* **Simplify your code:**  If you're encountering unexpected behavior, start with a minimal example to isolate the problem.  Gradually add complexity back in to identify the source of the issue.\n\n* **Test with smaller datasets:** Testing with a smaller, manageable set of data can help you identify problems more quickly before scaling to a larger dataset.\n\n\n* **Check the TinySort source code:** If you suspect a bug in TinySort itself, examine the source code to understand its internal workings. However, this should be a last resort, as most problems arise from selector or configuration issues.\n\n\n### FAQ\n\n* **Q: Can TinySort handle nested lists?** A: Yes, TinySort works recursively.  It will sort elements within nested lists based on your provided selector and options.\n\n* **Q:  Can I sort by multiple attributes simultaneously?** A: Yes, use an array in the `data` option to specify multiple attributes in the desired order of priority.\n\n* **Q: What happens if the selector doesn't match any elements?** A: No error is thrown; TinySort simply does nothing.\n\n* **Q:  Does TinySort modify the original DOM structure or create copies?** A:  TinySort reorders existing DOM elements; it does not create copies.\n\n* **Q: How can I get support or report bugs?** A: Refer to the TinySort project's repository or website for information on reporting issues and getting support.  (This should link to the actual project resources)\n\n* **Q: Is TinySort suitable for extremely large datasets?** A:  For very large datasets, consider the performance recommendations in the manual and potentially explore alternative, more highly optimized solutions.  TinySort is optimized for speed but has limitations like any other library.\n\n\n## API Reference\n\n### TinySort Function Parameters\n\nThe core `tinysort()` function accepts two parameters:\n\n1.  **`selector` (string or array):** This is the primary parameter. It specifies the elements to be sorted.  It can be:\n\n    *   A CSS selector string (e.g., `'ul li'`, `'.my-class'`, `'#my-id'`) targeting elements in the DOM.\n    *   A JavaScript array of strings or objects to be sorted directly (in which case you *must* set `selector: null`).\n\n2.  **`options` (object, optional):** This parameter is an object containing various options to customize the sorting behavior.  The available options are detailed below.  If omitted, TinySort uses default settings (ascending order, sorting by text content, case-sensitive).  Many options are described in the earlier sections of this manual.  The key options include:\n\n    *   `order`: `\"asc\"` (ascending, default) or `\"desc\"` (descending).\n    *   `data`:  Specifies the attribute or property to sort by (e.g., `'data-sort'`, `'name'`).  Can be a string for a single attribute or an array of strings for multiple attributes.\n    *   `ignoreCase`: `true` for case-insensitive sorting (default: `false`).\n    *   `place`: Controls where unsortable items (those failing filters or comparisons) should be placed within the sorted result. See the documentation for further details.\n    *   `useFlexbox`: `true` to use flexbox for reordering (use with caution).\n    *   `cmp`: A custom comparison function (see \"Custom Sort Functions\").\n    *   `selector`:  `null` when using arrays as input (required for array sorting)\n    *   `filter`: A function to filter elements before sorting.\n    *   `returns`:  How to treat the return value. See the documentation for further details.\n    *   `dataTypes`: Specify data types (e.g., `'number'`, `'date'`, `'string'`, an array of these, or a function). See the documentation for further details.\n\n\n\n### Return Values\n\nThe `tinysort()` function returns different values depending on the `returns` option:\n\n*   **Default (or `returns: 'array'`):** Returns an array of the sorted elements (DOM nodes or array elements). This default can be useful for further post-processing after sorting.\n\n*   **`returns: 'this'` (or omitted):** Returns the original `tinysort()` function itself, allowing for method chaining.   Note that this does *not* return the sorted elements directly.  It returns the function for chaining. This is mainly for convenience when using in conjunction with other libraries.\n\n*   **`returns: null`:** Returns null.  This option is useful when you only care about the side effect of sorting (the DOM elements being reordered), and don't need a return value.\n\n\n### Error Handling\n\nTinySort is designed to be robust and handle errors gracefully.  It doesn't throw JavaScript errors in most cases.  If there's a problem, such as an invalid selector or option, the function will either silently fail (no sorting occurs) or possibly produce unexpected results.  \n\nIt is crucial to use your browser's developer tools (console) to inspect the elements, check the values of your data attributes, and debug your custom functions to understand any unexpected behavior.  The lack of explicit error throwing is a design choice emphasizing the library's lightweight and non-intrusive nature. However, this also means careful debugging is essential to diagnose problems.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"}],"output-file":"tinysort.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"title":"TinySort - A Developer's Handbook","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}