<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Muthukrishnan">

<title>Bluebird - Documentation – Technical Manuals</title>
<style>
html {
  color: #1a1a1a;
  background-color: #fdfdfd;
}
body {
  margin: 0 auto;
  max-width: 36em;
  padding-left: 50px;
  padding-right: 50px;
  padding-top: 50px;
  padding-bottom: 50px;
  hyphens: auto;
  overflow-wrap: break-word;
  text-rendering: optimizeLegibility;
  font-kerning: normal;
}
@media (max-width: 600px) {
  body {
    font-size: 0.9em;
    padding: 12px;
  }
  h1 {
    font-size: 1.8em;
  }
}
@media print {
  html {
    background-color: white;
  }
  body {
    background-color: transparent;
    color: black;
    font-size: 12pt;
  }
  p, h2, h3 {
    orphans: 3;
    widows: 3;
  }
  h2, h3, h4 {
    page-break-after: avoid;
  }
}
p {
  margin: 1em 0;
}
a {
  color: #1a1a1a;
}
a:visited {
  color: #1a1a1a;
}
img {
  max-width: 100%;
}
svg {
  height; auto;
  max-width: 100%;
}
h1, h2, h3, h4, h5, h6 {
  margin-top: 1.4em;
}
h5, h6 {
  font-size: 1em;
  font-style: italic;
}
h6 {
  font-weight: normal;
}
ol, ul {
  padding-left: 1.7em;
  margin-top: 1em;
}
li > ol, li > ul {
  margin-top: 0;
}
ul > li:not(:has(> p)) > ul,
ol > li:not(:has(> p)) > ul,
ul > li:not(:has(> p)) > ol,
ol > li:not(:has(> p)) > ol {
  margin-bottom: 0;
}
ul > li:not(:has(> p)) > ul > li:has(> p),
ol > li:not(:has(> p)) > ul > li:has(> p),
ul > li:not(:has(> p)) > ol > li:has(> p),
ol > li:not(:has(> p)) > ol > li:has(> p) {
  margin-top: 1rem;
}
blockquote {
  margin: 1em 0 1em 1.7em;
  padding-left: 1em;
  border-left: 2px solid #e6e6e6;
  color: #606060;
}
code {
  font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
  font-size: 85%;
  margin: 0;
  hyphens: manual;
}
pre {
  margin: 1em 0;
  overflow: auto;
}
pre code {
  padding: 0;
  overflow: visible;
  overflow-wrap: normal;
}
.sourceCode {
 background-color: transparent;
 overflow: visible;
}
hr {
  background-color: #1a1a1a;
  border: none;
  height: 1px;
  margin: 1em 0;
}
table {
  margin: 1em 0;
  border-collapse: collapse;
  width: 100%;
  overflow-x: auto;
  display: block;
  font-variant-numeric: lining-nums tabular-nums;
}
table caption {
  margin-bottom: 0.75em;
}
tbody {
  margin-top: 0.5em;
  border-top: 1px solid #1a1a1a;
  border-bottom: 1px solid #1a1a1a;
}
th {
  border-top: 1px solid #1a1a1a;
  padding: 0.25em 0.5em 0.25em 0.5em;
}
td {
  padding: 0.125em 0.5em 0.25em 0.5em;
}
header {
  margin-bottom: 4em;
  text-align: center;
}
#TOC li {
  list-style: none;
}
#TOC ul {
  padding-left: 1.3em;
}
#TOC > ul {
  padding-left: 0;
}
#TOC a:not(:hover) {
  text-decoration: none;
}
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<link href="../../favicon.ico" rel="icon">
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-MXDPF6L5TL"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-MXDPF6L5TL', { 'anonymize_ip': true});
</script>
<link rel="icon" type="image/x-icon" href="favicon.ico">
<meta property="og:title" content="Bluebird - Documentation – Technical Manuals">
<meta property="og:site_name" content="Technical Manuals">
</head><body><div class="navigation-header">
    <nav>
        <div>
            <div class="logo">
                <a href="../../" aria-label="Home">
                    <span>Technical Manuals - Home</span>
                </a>
            </div>
            <div class="nav-menu">
                <ul>
                    <li>
                        <a href="../../about.html">
                            <span class="menu-text">About</span>
                        </a>
                    </li>
                    <li> 
                        <a href="https://github.com/muthuspark" target="_blank">
                            <span class="menu-text">Github</span>
                        </a>
                    </li>
                    <li>
                        <a href="https://linkedin.com/in/krimuthu" target="_blank">
                            <span class="menu-text">Linkedin</span>
                        </a>
                    </li>
                    <li>
                        <button onclick="window.print()" class="print-button">
                            <svg width="20" height="20" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <path d="M6 9V2h12v7"></path>
                              <path d="M6 18H4a2 2 0 01-2-2v-5a2 2 0 012-2h16a2 2 0 012 2v5a2 2 0 01-2 2h-2"></path>
                              <path d="M6 14h12v8H6z"></path>
                            </svg>
                            Print Page
                        </button>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
</div>


<link rel="stylesheet" href="../../styles.css">





<header id="title-block-header">
<h1 class="title">Bluebird - Documentation</h1>

</header>

<nav id="TOC" role="doc-toc">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#what-is-bluebird" id="toc-what-is-bluebird">What is Bluebird?</a></li>
  <li><a href="#why-use-bluebird" id="toc-why-use-bluebird">Why use Bluebird?</a></li>
  <li><a href="#bluebird-vs.-native-promises" id="toc-bluebird-vs.-native-promises">Bluebird vs.&nbsp;Native Promises</a></li>
  <li><a href="#installation-and-setup" id="toc-installation-and-setup">Installation and Setup</a></li>
  <li><a href="#core-concepts" id="toc-core-concepts">Core Concepts</a>
  <ul>
  <li><a href="#creating-promises" id="toc-creating-promises">Creating Promises</a></li>
  <li><a href="#chaining-promises" id="toc-chaining-promises">Chaining Promises</a></li>
  <li><a href="#handling-promise-resolution-and-rejection" id="toc-handling-promise-resolution-and-rejection">Handling Promise Resolution and Rejection</a></li>
  <li><a href="#error-handling" id="toc-error-handling">Error Handling</a></li>
  <li><a href="#cancellation" id="toc-cancellation">Cancellation</a></li>
  </ul></li>
  <li><a href="#advanced-usage" id="toc-advanced-usage">Advanced Usage</a>
  <ul>
  <li><a href="#using-promise.map-and-promise.reduce" id="toc-using-promise.map-and-promise.reduce">Using <code>Promise.map</code> and <code>Promise.reduce</code></a></li>
  <li><a href="#working-with-arrays-of-promises" id="toc-working-with-arrays-of-promises">Working with Arrays of Promises</a></li>
  <li><a href="#using-promise.all-and-promise.any" id="toc-using-promise.all-and-promise.any">Using <code>Promise.all</code> and <code>Promise.any</code></a></li>
  <li><a href="#creating-custom-promise-methods" id="toc-creating-custom-promise-methods">Creating Custom Promise Methods</a></li>
  <li><a href="#using-promise.try" id="toc-using-promise.try">Using <code>Promise.try</code></a></li>
  </ul></li>
  <li><a href="#utilities" id="toc-utilities">Utilities</a>
  <ul>
  <li><a href="#understanding-promise.resolve-and-promise.reject" id="toc-understanding-promise.resolve-and-promise.reject">Understanding <code>Promise.resolve</code> and <code>Promise.reject</code></a></li>
  <li><a href="#using-promise.each" id="toc-using-promise.each">Using <code>Promise.each</code></a></li>
  <li><a href="#working-with-promise.join" id="toc-working-with-promise.join">Working with <code>Promise.join</code></a></li>
  <li><a href="#using-promise.props" id="toc-using-promise.props">Using <code>Promise.props</code></a></li>
  <li><a href="#using-promise.coroutine" id="toc-using-promise.coroutine">Using <code>Promise.coroutine</code></a></li>
  </ul></li>
  <li><a href="#long-stack-traces" id="toc-long-stack-traces">Long Stack Traces</a>
  <ul>
  <li><a href="#enabling-long-stack-traces" id="toc-enabling-long-stack-traces">Enabling Long Stack Traces</a></li>
  <li><a href="#debugging-with-long-stack-traces" id="toc-debugging-with-long-stack-traces">Debugging with Long Stack Traces</a></li>
  <li><a href="#performance-considerations" id="toc-performance-considerations">Performance Considerations</a></li>
  </ul></li>
  <li><a href="#debugging-and-troubleshooting" id="toc-debugging-and-troubleshooting">Debugging and Troubleshooting</a>
  <ul>
  <li><a href="#common-errors-and-solutions" id="toc-common-errors-and-solutions">Common Errors and Solutions</a></li>
  <li><a href="#debugging-tips-and-techniques" id="toc-debugging-tips-and-techniques">Debugging Tips and Techniques</a></li>
  <li><a href="#using-logging-for-debugging" id="toc-using-logging-for-debugging">Using Logging for Debugging</a></li>
  </ul></li>
  <li><a href="#best-practices" id="toc-best-practices">Best Practices</a>
  <ul>
  <li><a href="#writing-clean-and-maintainable-promise-code" id="toc-writing-clean-and-maintainable-promise-code">Writing Clean and Maintainable Promise Code</a></li>
  <li><a href="#error-handling-best-practices" id="toc-error-handling-best-practices">Error Handling Best Practices</a></li>
  <li><a href="#performance-optimization-strategies" id="toc-performance-optimization-strategies">Performance Optimization Strategies</a></li>
  <li><a href="#testing-your-promise-code" id="toc-testing-your-promise-code">Testing Your Promise Code</a></li>
  </ul></li>
  <li><a href="#migration-from-other-promise-libraries" id="toc-migration-from-other-promise-libraries">Migration from Other Promise Libraries</a>
  <ul>
  <li><a href="#migrating-from-q" id="toc-migrating-from-q">Migrating from Q</a></li>
  <li><a href="#migrating-from-jquery-deferreds" id="toc-migrating-from-jquery-deferreds">Migrating from jQuery Deferreds</a></li>
  <li><a href="#migrating-from-native-promises" id="toc-migrating-from-native-promises">Migrating from Native Promises</a></li>
  </ul></li>
  <li><a href="#appendix" id="toc-appendix">Appendix</a>
  <ul>
  <li><a href="#glossary-of-terms" id="toc-glossary-of-terms">Glossary of Terms</a></li>
  <li><a href="#further-reading-and-resources" id="toc-further-reading-and-resources">Further Reading and Resources</a></li>
  </ul></li>
  </ul>
</nav>
<h3 id="what-is-bluebird">What is Bluebird?</h3>
<p>Bluebird is a fully featured promise library with unmatched performance. It implements the Promises/A+ specification and provides numerous additional features to simplify asynchronous programming in JavaScript. It’s designed to be faster and more robust than native Promises, particularly in high-throughput scenarios. Bluebird offers a rich API with methods for chaining promises, handling errors, and managing concurrency, leading to cleaner and more maintainable asynchronous code.</p>
<h3 id="why-use-bluebird">Why use Bluebird?</h3>
<p>While native Promises are widely supported, Bluebird offers several key advantages:</p>
<ul>
<li><strong>Performance:</strong> Bluebird is significantly faster than many native Promise implementations, especially in environments with less optimized JavaScript engines or under heavy load. Its performance is a key differentiator.</li>
<li><strong>Enhanced Features:</strong> Bluebird provides extensions and features not found in native Promises, such as <code>Promise.coroutine</code>, <code>Promise.map</code>, <code>Promise.try</code>, and more sophisticated error handling capabilities, improving developer productivity and code clarity.</li>
<li><strong>Backward Compatibility:</strong> Bluebird is designed to be compatible with older JavaScript environments and browsers that may lack robust native Promise support.</li>
<li><strong>Debugging:</strong> Bluebird offers superior debugging capabilities through detailed stack traces and helpful error messages, making it easier to identify and resolve issues in asynchronous code.</li>
<li><strong>Mature and Well-Tested:</strong> Bluebird has a long history, is extensively tested, and benefits from a large and active community, ensuring stability and reliability.</li>
</ul>
<h3 id="bluebird-vs.-native-promises">Bluebird vs.&nbsp;Native Promises</h3>
<table class="caption-top">
<colgroup>
<col style="width: 17%">
<col style="width: 40%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>Feature</th>
<th>Bluebird</th>
<th>Native Promises</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Performance</td>
<td>Generally faster, especially under load</td>
<td>Can be slower, especially in older engines</td>
</tr>
<tr class="even">
<td>Feature Set</td>
<td>Richer, with many additional methods</td>
<td>More basic, less functionality</td>
</tr>
<tr class="odd">
<td>Error Handling</td>
<td>More robust and informative error handling</td>
<td>Can be less informative</td>
</tr>
<tr class="even">
<td>Debugging</td>
<td>Superior stack traces and debugging tools</td>
<td>Can provide less detailed information</td>
</tr>
<tr class="odd">
<td>Compatibility</td>
<td>Wide browser and environment support</td>
<td>Native support varies across browsers</td>
</tr>
</tbody>
</table>
<h3 id="installation-and-setup">Installation and Setup</h3>
<p>Bluebird is easily installed using npm or yarn:</p>
<p><strong>Using npm:</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">npm</span> install bluebird</span></code></pre></div>
<p><strong>Using yarn:</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">yarn</span> add bluebird</span></code></pre></div>
<p>After installation, you can include Bluebird in your project:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="bu">Promise</span> <span class="op">=</span> <span class="pp">require</span>(<span class="st">'bluebird'</span>)<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Now you can use the Promise object provided by Bluebird</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">1</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(value <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(value))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">catch</span>(error <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(error))<span class="op">;</span></span></code></pre></div>
<p>Remember to replace <code>require('bluebird')</code> with the appropriate import statement if you are using a module bundler like Webpack or Parcel. For example, in ES6 modules you might use <code>import Promise from 'bluebird';</code>. Ensure your project’s build process handles the Bluebird library correctly.</p>
<h2 id="core-concepts">Core Concepts</h2>
<h3 id="creating-promises">Creating Promises</h3>
<p>Bluebird offers several ways to create promises. The most common are:</p>
<ul>
<li><strong><code>Promise.resolve(value)</code>:</strong> Creates a resolved promise with the given <code>value</code>. If <code>value</code> is already a promise, it’s returned as is.</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> resolvedPromise <span class="op">=</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">42</span>)<span class="op">;</span> <span class="co">// Resolved with 42</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> alreadyPromise <span class="op">=</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">42</span>))<span class="op">;</span> <span class="co">// Returns the inner promise</span></span></code></pre></div>
<ul>
<li><strong><code>Promise.reject(reason)</code>:</strong> Creates a rejected promise with the given <code>reason</code> (typically an error object).</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> rejectedPromise <span class="op">=</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">reject</span>(<span class="kw">new</span> <span class="bu">Error</span>(<span class="st">'Something went wrong'</span>))<span class="op">;</span></span></code></pre></div>
<ul>
<li><strong><code>new Promise(executor)</code>:</strong> Creates a new promise by providing an <code>executor</code> function. The executor receives two functions: <code>resolve</code> and <code>reject</code>. Calling <code>resolve(value)</code> fulfills the promise, while <code>reject(reason)</code> rejects it.</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> myPromise <span class="op">=</span> <span class="kw">new</span> <span class="bu">Promise</span>((resolve<span class="op">,</span> reject) <span class="kw">=&gt;</span> {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="pp">setTimeout</span>(() <span class="kw">=&gt;</span> {</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Simulate asynchronous operation</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> success <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">random</span>() <span class="op">&lt;</span> <span class="fl">0.8</span><span class="op">;</span> <span class="co">// 80% chance of success</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (success) {</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>      <span class="fu">resolve</span>(<span class="st">'Operation successful!'</span>)<span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>      <span class="fu">reject</span>(<span class="kw">new</span> <span class="bu">Error</span>(<span class="st">'Operation failed!'</span>))<span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  }<span class="op">,</span> <span class="dv">1000</span>)<span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<ul>
<li><strong><code>Promise.try(func, ...args)</code>:</strong> This is a convenient method to wrap a function call in a promise, allowing you to handle potential synchronous exceptions within the promise framework. If <code>func</code> throws, the promise will reject.</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> result <span class="op">=</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">try</span>(() <span class="kw">=&gt;</span> {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">10</span> <span class="op">/</span> x<span class="op">;</span> <span class="co">// This will throw an error</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>})<span class="op">.</span><span class="fu">catch</span>(error <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(error))<span class="op">;</span></span></code></pre></div>
<h3 id="chaining-promises">Chaining Promises</h3>
<p>Bluebird’s strength lies in its ability to chain promises using <code>.then()</code> and <code>.catch()</code>. <code>.then()</code> takes two optional arguments: a function to handle resolution and a function to handle rejection (which is equivalent to a <code>.catch()</code> block further down the chain).</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">1</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(value <span class="kw">=&gt;</span> value <span class="op">*</span> <span class="dv">2</span>)    <span class="co">// Returns a promise resolving to 2</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(value <span class="kw">=&gt;</span> value <span class="op">+</span> <span class="dv">3</span>)   <span class="co">// Returns a promise resolving to 5</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(value <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(value)) <span class="co">// Logs 5</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">catch</span>(error <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(error))<span class="op">;</span> <span class="co">// Handles any errors in the chain</span></span></code></pre></div>
<h3 id="handling-promise-resolution-and-rejection">Handling Promise Resolution and Rejection</h3>
<p>The <code>.then()</code> method handles promise resolution. It takes a function as an argument that receives the resolved value. This function can return a value or a promise, thus continuing the chain.</p>
<p>The <code>.catch()</code> method handles promise rejection. It takes a function as an argument that receives the rejection reason. This is often used to gracefully handle errors.</p>
<h3 id="error-handling">Error Handling</h3>
<p>Bluebird provides robust error handling mechanisms. <code>catch()</code> blocks handle errors that occur anywhere in the promise chain. Unhandled promise rejections will trigger a warning in the console (in most environments).</p>
<p>You can use multiple <code>.catch()</code> blocks to handle specific error types:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>()</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(() <span class="kw">=&gt;</span> { <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="st">"General Error"</span>) })</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">catch</span>(err <span class="kw">=&gt;</span> {</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (err <span class="kw">instanceof</span> <span class="bu">TypeError</span>) {</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>      <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(<span class="st">"Type Error caught"</span>)<span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>      <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(<span class="st">"General Error caught"</span>)<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span></code></pre></div>
<h3 id="cancellation">Cancellation</h3>
<p>Bluebird doesn’t offer built-in promise cancellation in the same way as some other libraries. Promises, by their nature, are not easily cancelled once started. However, you can implement cancellation patterns using techniques like cancellation tokens or signals that your asynchronous operations can check periodically. This requires careful design within your asynchronous functions and is not a direct feature of Bluebird’s core promise API.</p>
<h2 id="advanced-usage">Advanced Usage</h2>
<h3 id="using-promise.map-and-promise.reduce">Using <code>Promise.map</code> and <code>Promise.reduce</code></h3>
<p>Bluebird provides powerful methods for working with arrays of values or promises.</p>
<ul>
<li><strong><code>Promise.map(array, mapper, [concurrency])</code>:</strong> Applies the <code>mapper</code> function to each element in the <code>array</code>. The <code>mapper</code> function should return a promise. <code>Promise.map</code> runs the mapper concurrently up to the specified <code>concurrency</code> level (defaults to <code>Infinity</code>). It returns a promise that resolves to an array of the results.</li>
</ul>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> promises <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">.</span><span class="fu">map</span>(num <span class="kw">=&gt;</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(num <span class="op">*</span> <span class="dv">2</span>))<span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="bu">Promise</span><span class="op">.</span><span class="fu">map</span>(promises<span class="op">,</span> (promise) <span class="kw">=&gt;</span> promise<span class="op">,</span> {<span class="dt">concurrency</span><span class="op">:</span> <span class="dv">2</span>})</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(results <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(results))<span class="op">;</span> <span class="co">// Output: [2, 4, 6, 8, 10]</span></span></code></pre></div>
<ul>
<li><strong><code>Promise.reduce(array, reducer, initialValue)</code>:</strong> Applies the <code>reducer</code> function cumulatively to the items of <code>array</code>, from left to right, so as to reduce it to a single value. The <code>reducer</code> function receives the accumulated value and the current element as arguments and should return a promise which resolves to the next accumulated value.</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> numbers <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="bu">Promise</span><span class="op">.</span><span class="fu">reduce</span>(numbers<span class="op">,</span> (sum<span class="op">,</span> num) <span class="kw">=&gt;</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(sum <span class="op">+</span> num)<span class="op">,</span> <span class="dv">0</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(total <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(total))<span class="op">;</span> <span class="co">// Output: 15</span></span></code></pre></div>
<h3 id="working-with-arrays-of-promises">Working with Arrays of Promises</h3>
<p>You can use <code>Promise.all</code> and <code>Promise.any</code> to manage arrays of promises efficiently. Additionally, you can map over an array of promises to transform the results.</p>
<h3 id="using-promise.all-and-promise.any">Using <code>Promise.all</code> and <code>Promise.any</code></h3>
<ul>
<li><strong><code>Promise.all(promises)</code>:</strong> Takes an array of promises and returns a single promise that resolves when all promises in the array resolve. The resolved value is an array containing the resolved values of the input promises. If any promise in the array rejects, <code>Promise.all</code> rejects immediately with the reason of the first rejected promise.</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> promises <span class="op">=</span> [<span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">1</span>)<span class="op">,</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">2</span>)<span class="op">,</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">3</span>)]<span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="bu">Promise</span><span class="op">.</span><span class="fu">all</span>(promises)<span class="op">.</span><span class="fu">then</span>(results <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(results))<span class="op">;</span> <span class="co">// Output: [1, 2, 3]</span></span></code></pre></div>
<ul>
<li><strong><code>Promise.any(promises)</code>:</strong> Takes an array of promises and returns a single promise that resolves when the <em>first</em> promise in the array resolves. It rejects only if <em>all</em> promises in the array reject.</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> promises <span class="op">=</span> [<span class="bu">Promise</span><span class="op">.</span><span class="fu">reject</span>(<span class="kw">new</span> <span class="bu">Error</span>(<span class="st">'Failed'</span>))<span class="op">,</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">2</span>)<span class="op">,</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">3</span>)]<span class="op">;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="bu">Promise</span><span class="op">.</span><span class="fu">any</span>(promises)<span class="op">.</span><span class="fu">then</span>(result <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(result))<span class="op">;</span> <span class="co">//Output: 2</span></span></code></pre></div>
<h3 id="creating-custom-promise-methods">Creating Custom Promise Methods</h3>
<p>You can extend Bluebird’s functionality by creating your own methods using <code>Promise.method</code> or by directly extending the <code>Promise</code> prototype (generally discouraged for maintaining compatibility). <code>Promise.method</code> is preferred as it ensures correct handling of <code>this</code> context and error propagation.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> myAsyncMethod <span class="op">=</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">method</span>(<span class="kw">function</span>(arg1<span class="op">,</span> arg2) {</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">new</span> <span class="bu">Promise</span>((resolve<span class="op">,</span> reject) <span class="kw">=&gt;</span> {</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Your asynchronous operation here...</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">setTimeout</span>(() <span class="kw">=&gt;</span> {</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>      <span class="fu">resolve</span>(arg1 <span class="op">+</span> arg2)<span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    }<span class="op">,</span> <span class="dv">1000</span>)<span class="op">;</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="fu">myAsyncMethod</span>(<span class="dv">5</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">.</span><span class="fu">then</span>(result <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(result))<span class="op">;</span> <span class="co">// Output: 8 after 1 second</span></span></code></pre></div>
<h3 id="using-promise.try">Using <code>Promise.try</code></h3>
<p><code>Promise.try(function, ...args)</code> is a utility method that wraps the execution of a function within a promise. This is beneficial for handling potential synchronous exceptions that might occur within the function. If the function throws an error, <code>Promise.try</code> will reject the resulting promise.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> result <span class="op">=</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">try</span>(() <span class="kw">=&gt;</span> {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// some synchronous operation that might throw an error</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="kw">true</span>) {</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>     <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="st">"Sync error"</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>})<span class="op">.</span><span class="fu">catch</span>(error <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(<span class="st">"Error caught:"</span><span class="op">,</span> error))<span class="op">;</span></span></code></pre></div>
<h2 id="utilities">Utilities</h2>
<h3 id="understanding-promise.resolve-and-promise.reject">Understanding <code>Promise.resolve</code> and <code>Promise.reject</code></h3>
<p><code>Promise.resolve(value)</code> and <code>Promise.reject(reason)</code> are fundamental utility methods for creating promises.</p>
<ul>
<li><strong><code>Promise.resolve(value)</code>:</strong> Creates a resolved promise with the given <code>value</code>. If <code>value</code> is already a promise, it’s returned unchanged. This is useful for ensuring a value is always treated as a promise, simplifying the code’s logic.</li>
</ul>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> resolvedPromise <span class="op">=</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">42</span>)<span class="op">;</span> <span class="co">// A resolved promise</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> alreadyPromise <span class="op">=</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">42</span>))<span class="op">;</span> <span class="co">// Returns the existing promise.</span></span></code></pre></div>
<ul>
<li><strong><code>Promise.reject(reason)</code>:</strong> Creates a rejected promise with the given <code>reason</code>. The <code>reason</code> is usually an error object, but can be any value. This is used to explicitly reject a promise.</li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> rejectedPromise <span class="op">=</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">reject</span>(<span class="kw">new</span> <span class="bu">Error</span>(<span class="st">"Something went wrong"</span>))<span class="op">;</span></span></code></pre></div>
<p>These functions are essential for creating promises from various sources (e.g., callback functions, asynchronous operations) and for consistent promise handling throughout your application.</p>
<h3 id="using-promise.each">Using <code>Promise.each</code></h3>
<p><code>Promise.each(array, iterator)</code> iterates over an array and applies the <code>iterator</code> function to each element. The <code>iterator</code> function should accept the element as an argument and should return a promise. <code>Promise.each</code> waits for each promise returned by the <code>iterator</code> to resolve before moving to the next element.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> data <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> promises <span class="op">=</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">each</span>(data<span class="op">,</span> (item) <span class="kw">=&gt;</span> {</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">new</span> <span class="bu">Promise</span>((resolve<span class="op">,</span> reject) <span class="kw">=&gt;</span> {</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">setTimeout</span>(() <span class="kw">=&gt;</span> {</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>       <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="vs">`Processing </span><span class="sc">${</span>item<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>       <span class="fu">resolve</span>(item <span class="op">*</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    }<span class="op">,</span> <span class="dv">1000</span>)<span class="op">;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>})<span class="op">.</span><span class="fu">then</span>(results <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">"Results:"</span><span class="op">,</span> results))<span class="op">;</span> <span class="co">// Results: [2,4,6,8,10] (after delays)</span></span></code></pre></div>
<p>It’s crucial to understand that <code>Promise.each</code> is sequential; it doesn’t process elements concurrently. For parallel processing, use <code>Promise.map</code> instead.</p>
<h3 id="working-with-promise.join">Working with <code>Promise.join</code></h3>
<p><code>Promise.join(promise1, promise2, ..., fn)</code> takes multiple promises as arguments and a function <code>fn</code>. It waits for all input promises to resolve, then calls <code>fn</code> with the resolved values of those promises as arguments. The result of <code>fn</code> will be the resolved value of the resulting promise.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> promise1 <span class="op">=</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> promise2 <span class="op">=</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">20</span>)<span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="bu">Promise</span><span class="op">.</span><span class="fu">join</span>(promise1<span class="op">,</span> promise2<span class="op">,</span> (val1<span class="op">,</span> val2) <span class="kw">=&gt;</span> val1 <span class="op">+</span> val2)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(result <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(result))<span class="op">;</span> <span class="co">// Output: 30</span></span></code></pre></div>
<p><code>Promise.join</code> provides a clean way to combine the results of multiple asynchronous operations.</p>
<h3 id="using-promise.props">Using <code>Promise.props</code></h3>
<p><code>Promise.props(object)</code> takes an object where values are promises and returns a single promise. This promise resolves to a new object with the same keys, but the values will be the resolved values of the corresponding promises. Rejections of any of the input promises will cause the resulting promise to reject.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> promiseObject <span class="op">=</span> {</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">a</span><span class="op">:</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">1</span>)<span class="op">,</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">b</span><span class="op">:</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">2</span>)<span class="op">,</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">c</span><span class="op">:</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">3</span>)<span class="op">,</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="bu">Promise</span><span class="op">.</span><span class="fu">props</span>(promiseObject)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(results <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(results))<span class="op">;</span> <span class="co">// Output: { a: 1, b: 2, c: 3 }</span></span></code></pre></div>
<p>This is useful for fetching multiple related data points asynchronously and keeping the data structure consistent.</p>
<h3 id="using-promise.coroutine">Using <code>Promise.coroutine</code></h3>
<p><code>Promise.coroutine(generatorFunction)</code> is a powerful utility for writing asynchronous code that looks and feels like synchronous code using generators. The generator function yields promises, and <code>Promise.coroutine</code> handles the execution and chaining of those promises.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span><span class="op">*</span> <span class="fu">myGenerator</span>() {</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> value1 <span class="op">=</span> <span class="kw">yield</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> value2 <span class="op">=</span> <span class="kw">yield</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">20</span>)<span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> value1 <span class="op">+</span> value2<span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> result <span class="op">=</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">coroutine</span>(myGenerator)()<span class="op">;</span> <span class="co">// Call the coroutine</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>result<span class="op">.</span><span class="fu">then</span>(sum <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(sum))<span class="op">;</span> <span class="co">// Output: 30</span></span></code></pre></div>
<p>This makes asynchronous code more readable and maintainable, especially when dealing with complex asynchronous flows. Note that <code>Promise.coroutine</code> is deprecated in newer Bluebird versions, and it’s suggested to use async/await instead.</p>
<h2 id="long-stack-traces">Long Stack Traces</h2>
<h3 id="enabling-long-stack-traces">Enabling Long Stack Traces</h3>
<p>Bluebird’s long stack traces are a crucial debugging feature, providing much more detailed information than standard JavaScript stack traces, especially helpful in asynchronous code. To enable them, you need to set the <code>longStackTraces</code> option <em>before</em> any promises are created. This is typically done early in your application’s startup.</p>
<p>There are two ways to enable long stack traces:</p>
<p><strong>1. Environment Variable:</strong> Set the environment variable <code>BLUEBIRD_LONG_STACK_TRACES</code> to <code>1</code>. This is usually the preferred method for production deployments as it doesn’t require modification to the source code.</p>
<p><strong>2. Direct Setting:</strong> Before any Bluebird promise is used, set the <code>Promise.config</code> option:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="bu">Promise</span><span class="op">.</span><span class="fu">config</span>({</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">longStackTraces</span><span class="op">:</span> <span class="kw">true</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<p>This should be done as early as possible in your application’s initialization, ideally before any other code that uses promises. Enabling long stack traces after promises have been created will not affect those promises.</p>
<h3 id="debugging-with-long-stack-traces">Debugging with Long Stack Traces</h3>
<p>With long stack traces enabled, when a promise rejects, the resulting error will contain a significantly more detailed stack trace. This stack trace will show the complete call chain leading to the error, including asynchronous calls and callbacks. This greatly simplifies debugging asynchronous code because you can easily trace the flow of execution that led to the failure, even across multiple functions and asynchronous operations. The stack trace will typically include lines of code that are the source of the problem.</p>
<p>The increased detail in long stack traces helps identify the root cause of errors more quickly. Standard stack traces often truncate information, especially in asynchronous operations, making debugging much more difficult.</p>
<h3 id="performance-considerations">Performance Considerations</h3>
<p>While long stack traces are invaluable for debugging, they do come at a performance cost. The extra information requires more memory and processing time to generate and store. Therefore, it’s crucial to only enable long stack traces during development and testing. For production environments, it’s strongly recommended to <em>disable</em> long stack traces (<code>longStackTraces: false</code>) to improve performance and reduce memory consumption. The memory overhead becomes significant as the complexity of your application grows. Leaving them enabled in production could lead to performance degradation and potential memory issues.</p>
<h2 id="debugging-and-troubleshooting">Debugging and Troubleshooting</h2>
<h3 id="common-errors-and-solutions">Common Errors and Solutions</h3>
<p>Several common errors arise when working with asynchronous code and promises. Here are some frequent issues and their solutions:</p>
<ul>
<li><p><strong>Unhandled promise rejections:</strong> If a promise rejects and there’s no <code>.catch()</code> block to handle it, Bluebird (and most JavaScript environments) will issue a warning to the console. This indicates an error in your asynchronous code. Always ensure every promise has appropriate error handling with a <code>.catch()</code> block.</p></li>
<li><p><strong>Incorrect <code>.then()</code> chaining:</strong> Errors can occur if <code>.then()</code> methods aren’t correctly chained or if the functions passed to <code>.then()</code> are not returning promises where expected. Double-check the return values of the functions used in your <code>.then()</code> chain to ensure proper propagation of promises.</p></li>
<li><p><strong>Race conditions:</strong> In concurrent asynchronous operations, race conditions can lead to unpredictable results. Carefully manage concurrency using tools like <code>Promise.map</code> with controlled concurrency or other synchronization mechanisms to prevent race conditions.</p></li>
<li><p><strong>Forgotten <code>return</code> statements:</strong> If a function within a <code>.then()</code> block doesn’t explicitly return a promise, the promise chain might be broken, leading to unexpected behavior. Always explicitly return a promise (or a value that will implicitly create a resolved promise) from the functions in your <code>.then()</code> chain.</p></li>
<li><p><strong>Mixing synchronous and asynchronous operations:</strong> Incorrectly mixing synchronous and asynchronous operations can cause unexpected timing issues and errors. Structure your code clearly to separate synchronous and asynchronous parts to avoid confusion and maintain predictable behavior.</p></li>
<li><p><strong>Incorrect error handling within promises:</strong> A <code>.catch()</code> block may not catch all errors if they are not properly propagated through the promise chain. Ensure your error handling is comprehensive and robust.</p></li>
</ul>
<h3 id="debugging-tips-and-techniques">Debugging Tips and Techniques</h3>
<ul>
<li><p><strong>Enable long stack traces:</strong> As discussed previously, enabling long stack traces significantly improves debugging by providing more comprehensive information about the call stack, making it easier to identify the source of errors.</p></li>
<li><p><strong>Use a debugger:</strong> Integrate Bluebird into your debugging environment (like Chrome DevTools or VS Code debugger). Set breakpoints within your promise chains to step through the code execution and inspect variables at different stages.</p></li>
<li><p><strong>Console logging:</strong> Strategically use <code>console.log</code> statements within your promise chains to track the values and states of your promises at various points in the asynchronous flow.</p></li>
<li><p><strong>Simplify your code:</strong> Break down complex asynchronous operations into smaller, more manageable parts. This simplifies debugging and improves readability.</p></li>
<li><p><strong>Test thoroughly:</strong> Write comprehensive unit and integration tests for your asynchronous code, particularly focusing on error handling paths, to detect potential issues early in the development process.</p></li>
</ul>
<h3 id="using-logging-for-debugging">Using Logging for Debugging</h3>
<p>Logging is an invaluable tool when debugging asynchronous operations. Use a structured logging library (like Winston, Bunyan, or console logging) to record key events, promise states (resolved/rejected), and values throughout the promise chains. This creates a timeline of events that helps you understand the flow of execution and pinpoint problematic areas. Timestamp your log entries to accurately track the sequence of operations. In complex situations, log the entire promise chain to track the flow effectively.</p>
<p>Example of using console logging:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>(<span class="dv">1</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(value <span class="kw">=&gt;</span> {</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="vs">`Step 1: Value is </span><span class="sc">${</span>value<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> value <span class="op">*</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(value <span class="kw">=&gt;</span> {</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="vs">`Step 2: Value is </span><span class="sc">${</span>value<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">Promise</span><span class="op">.</span><span class="fu">reject</span>(<span class="kw">new</span> <span class="bu">Error</span>(<span class="st">'Something went wrong!'</span>))<span class="op">;</span> <span class="co">//Intentional Error</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">catch</span>(error <span class="kw">=&gt;</span> {</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(<span class="vs">`Error caught: </span><span class="sc">${</span>error<span class="op">.</span><span class="at">message</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span></code></pre></div>
<p>Structured logging libraries offer more powerful features such as log levels (debug, info, warn, error), custom log formats, and integration with various logging destinations (files, databases, remote services). Use logging effectively to build a comprehensive audit trail of your application’s asynchronous behavior during development and debugging.</p>
<h2 id="best-practices">Best Practices</h2>
<h3 id="writing-clean-and-maintainable-promise-code">Writing Clean and Maintainable Promise Code</h3>
<ul>
<li><p><strong>Keep Promises short and focused:</strong> Avoid overly long or complex promise chains. Break down large tasks into smaller, more manageable functions, each returning a promise. This improves readability and maintainability.</p></li>
<li><p><strong>Use descriptive variable names:</strong> Choose meaningful names for your promises and variables to clarify their purpose.</p></li>
<li><p><strong>Consistent error handling:</strong> Always include <code>.catch()</code> blocks to handle potential errors. Centralize error handling where possible to avoid repetitive code.</p></li>
<li><p><strong>Avoid nesting:</strong> Excessive nesting of <code>.then()</code> blocks reduces readability. Use techniques like <code>Promise.all</code> or <code>Promise.join</code> to handle multiple promises concurrently and avoid nested structures.</p></li>
<li><p><strong>Use async/await (when available):</strong> If your environment supports async/await, utilize this feature to write asynchronous code that looks and behaves like synchronous code, improving readability significantly. This often makes error handling and flow control much clearer than traditional promise chaining.</p></li>
<li><p><strong>Document your promises:</strong> Add comments to explain the purpose and behavior of your promises, particularly those involving complex logic or asynchronous interactions.</p></li>
<li><p><strong>Follow a consistent style:</strong> Adhere to a consistent coding style for promise usage throughout your project to maintain uniformity and readability.</p></li>
</ul>
<h3 id="error-handling-best-practices">Error Handling Best Practices</h3>
<ul>
<li><p><strong>Always handle rejections:</strong> Never let a promise reject without being caught. Unhandled rejections can lead to unexpected application behavior and crashes.</p></li>
<li><p><strong>Specific error handling:</strong> Handle specific error types when possible to provide more targeted responses and improve debugging.</p></li>
<li><p><strong>Centralized error logging:</strong> Log errors in a centralized location to simplify debugging and monitoring. Use structured logging to provide context and details of errors.</p></li>
<li><p><strong>Graceful degradation:</strong> Design your error handling to gracefully handle failures and provide informative feedback to users, preventing abrupt application termination.</p></li>
<li><p><strong>Retry mechanisms:</strong> For transient errors, consider implementing retry logic to automatically retry failed operations after a delay.</p></li>
<li><p><strong>Circuit breakers:</strong> In situations with frequently failing services, use circuit breaker patterns to prevent repeated failures and allow the system to recover gracefully.</p></li>
</ul>
<h3 id="performance-optimization-strategies">Performance Optimization Strategies</h3>
<ul>
<li><p><strong>Minimize synchronous operations within promises:</strong> Keep synchronous operations within promises to a minimum to avoid blocking the event loop.</p></li>
<li><p><strong>Use appropriate concurrency levels:</strong> When using <code>Promise.map</code>, choose an appropriate concurrency level to optimize performance based on your system resources and task characteristics. Too low a value serializes processing; too high a value might overwhelm the system.</p></li>
<li><p><strong>Batch operations:</strong> When feasible, batch multiple asynchronous operations into a single call to reduce the overhead of multiple individual requests.</p></li>
<li><p><strong>Optimize network requests:</strong> Minimize network calls by fetching data efficiently and caching appropriately.</p></li>
<li><p><strong>Efficient data handling:</strong> Avoid unnecessary data copying or manipulation within promises. Process data efficiently to minimize performance impact.</p></li>
<li><p><strong>Profiling:</strong> Utilize JavaScript profiling tools to identify performance bottlenecks in your asynchronous code.</p></li>
</ul>
<h3 id="testing-your-promise-code">Testing Your Promise Code</h3>
<ul>
<li><p><strong>Unit testing:</strong> Write unit tests for individual promise-based functions to ensure they behave correctly in isolation.</p></li>
<li><p><strong>Integration testing:</strong> Test the interactions between multiple promises and asynchronous components to verify they work together correctly.</p></li>
<li><p><strong>End-to-end testing:</strong> Test the complete flow of asynchronous operations from start to finish to confirm the overall functionality.</p></li>
<li><p><strong>Mocking:</strong> Mock external dependencies (like network requests or database calls) during testing to ensure consistent and predictable results.</p></li>
<li><p><strong>Test error handling:</strong> Thoroughly test error handling paths to verify they work as expected and gracefully handle failures.</p></li>
<li><p><strong>Use a testing framework:</strong> Employ a JavaScript testing framework (like Jest, Mocha, or Jasmine) to structure and run your tests effectively. These frameworks provide tools for assertions, mocking, and test runners to streamline the testing process.</p></li>
</ul>
<h2 id="migration-from-other-promise-libraries">Migration from Other Promise Libraries</h2>
<h3 id="migrating-from-q">Migrating from Q</h3>
<p>Q is another popular promise library. Migrating from Q to Bluebird is generally straightforward because both libraries adhere to the Promises/A+ specification. However, there are some key differences in API and functionality to consider:</p>
<ul>
<li><p><strong>API Differences:</strong> While both libraries offer similar core functionality, the names of some methods might differ slightly. For example, Q’s <code>Q.all</code> is equivalent to Bluebird’s <code>Promise.all</code>. Refer to the Bluebird API documentation to find the corresponding Bluebird equivalent for each Q method.</p></li>
<li><p><strong>Error Handling:</strong> Both libraries handle errors, but the error handling mechanisms might have subtle differences. Ensure you thoroughly review how exceptions are caught and handled in your Q code and translate them to Bluebird’s <code>.catch()</code> mechanism correctly.</p></li>
<li><p><strong><code>Q.defer</code> vs.&nbsp;<code>new Promise</code>:</strong> Q uses <code>Q.defer</code> to create deferred objects, whereas Bluebird uses <code>new Promise(executor)</code>. You’ll need to rewrite code creating deferreds to use the <code>new Promise</code> constructor.</p></li>
<li><p><strong><code>Q.async</code> vs.&nbsp;<code>Promise.coroutine</code> (deprecated):</strong> Q’s <code>Q.async</code> is similar to Bluebird’s <code>Promise.coroutine</code>, but <code>Promise.coroutine</code> is deprecated in favor of async/await. You’ll want to refactor to use the modern async/await approach.</p></li>
</ul>
<p><strong>Example of converting Q code to Bluebird:</strong></p>
<p><strong>Q:</strong></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> Q <span class="op">=</span> <span class="pp">require</span>(<span class="st">'q'</span>)<span class="op">;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> deferred <span class="op">=</span> Q<span class="op">.</span><span class="fu">defer</span>()<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="fu">someAsyncOperation</span>(<span class="kw">function</span>(result){</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (result) {</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    deferred<span class="op">.</span><span class="fu">resolve</span>(result)<span class="op">;</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    deferred<span class="op">.</span><span class="fu">reject</span>(<span class="kw">new</span> <span class="bu">Error</span>(<span class="st">'Operation failed'</span>))<span class="op">;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>deferred<span class="op">.</span><span class="at">promise</span><span class="op">.</span><span class="fu">then</span>(result <span class="kw">=&gt;</span> {</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(result)<span class="op">;</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>})<span class="op">.</span><span class="fu">catch</span>(err <span class="kw">=&gt;</span> {</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(err)<span class="op">;</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<p><strong>Bluebird:</strong></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="bu">Promise</span> <span class="op">=</span> <span class="pp">require</span>(<span class="st">'bluebird'</span>)<span class="op">;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> myPromise <span class="op">=</span> <span class="kw">new</span> <span class="bu">Promise</span>((resolve<span class="op">,</span> reject) <span class="kw">=&gt;</span> {</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">someAsyncOperation</span>((result) <span class="kw">=&gt;</span> {</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (result) {</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>      <span class="fu">resolve</span>(result)<span class="op">;</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>      <span class="fu">reject</span>(<span class="kw">new</span> <span class="bu">Error</span>(<span class="st">'Operation failed'</span>))<span class="op">;</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>myPromise<span class="op">.</span><span class="fu">then</span>(result <span class="kw">=&gt;</span> {</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(result)<span class="op">;</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>})<span class="op">.</span><span class="fu">catch</span>(err <span class="kw">=&gt;</span> {</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(err)<span class="op">;</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<h3 id="migrating-from-jquery-deferreds">Migrating from jQuery Deferreds</h3>
<p>jQuery’s Deferred objects provide a mechanism for managing asynchronous operations. While similar to promises, they have a slightly different API. Bluebird provides a cleaner and more standardized promise implementation.</p>
<p>The core difference lies in the API. jQuery Deferreds use methods like <code>resolve</code>, <code>reject</code>, <code>done</code>, <code>fail</code>, <code>always</code>, while Bluebird uses <code>.then</code>, <code>.catch</code>, and <code>.finally</code>. You need to rewrite your code using Bluebird’s promise methods.</p>
<p><strong>Example:</strong></p>
<p><strong>jQuery Deferred:</strong></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>$<span class="op">.</span><span class="fu">ajax</span>(<span class="st">'someUrl'</span>)<span class="op">.</span><span class="fu">done</span>(<span class="kw">function</span>(data){</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(data)<span class="op">;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>})<span class="op">.</span><span class="fu">fail</span>(<span class="kw">function</span>(error){</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(error)<span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<p><strong>Bluebird:</strong></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="bu">Promise</span> <span class="op">=</span> <span class="pp">require</span>(<span class="st">'bluebird'</span>)<span class="op">;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="bu">Promise</span><span class="op">.</span><span class="fu">resolve</span>($<span class="op">.</span><span class="fu">ajax</span>(<span class="st">'someUrl'</span>)) <span class="co">//wrap the ajax promise</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(data <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(data))</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">catch</span>(error <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(error))<span class="op">;</span></span></code></pre></div>
<h3 id="migrating-from-native-promises">Migrating from Native Promises</h3>
<p>Migrating from native Promises to Bluebird is often about leveraging Bluebird’s enhanced features. Native Promises are compliant with the Promises/A+ specification, so the core promise functionality will work identically. The benefit of moving to Bluebird is often performance improvements, access to additional utility functions, and enhanced debugging capabilities, especially in complex asynchronous scenarios.</p>
<p>The migration itself is mostly syntactic. You replace references to the global <code>Promise</code> object with Bluebird’s <code>Promise</code> object. No significant code rewrites are usually necessary besides adding <code>require('bluebird')</code> or the appropriate ES6 module import. However, take advantage of Bluebird’s additional functions (<code>Promise.map</code>, <code>Promise.all</code>, etc.) to potentially simplify and optimize your code.</p>
<h2 id="appendix">Appendix</h2>
<h3 id="glossary-of-terms">Glossary of Terms</h3>
<ul>
<li><p><strong>Promise:</strong> An object representing the eventual result of an asynchronous operation. It can be in one of three states: pending (the operation is still in progress), fulfilled (the operation completed successfully), or rejected (the operation failed).</p></li>
<li><p><strong>Fulfilled/Resolved:</strong> A promise that has completed successfully. Its associated <code>.then()</code> callbacks will be executed.</p></li>
<li><p><strong>Rejected:</strong> A promise that has encountered an error during execution. Its associated <code>.catch()</code> callbacks will be executed.</p></li>
<li><p><strong>Pending:</strong> A promise that is neither fulfilled nor rejected; the asynchronous operation is still in progress.</p></li>
<li><p><strong>Executor:</strong> A function passed to the <code>new Promise()</code> constructor. It contains the asynchronous operation and calls the <code>resolve</code> or <code>reject</code> functions to determine the promise’s outcome.</p></li>
<li><p><strong>Thenable:</strong> Any object that has a <code>then</code> method that conforms to the Promises/A+ specification. These objects can be used interchangeably with promises.</p></li>
<li><p><strong>Concurrency:</strong> The number of asynchronous operations that run simultaneously. Bluebird’s <code>Promise.map</code> allows controlling the level of concurrency.</p></li>
<li><p><strong>Race condition:</strong> A situation where the outcome of an operation depends on the unpredictable order in which multiple asynchronous operations complete.</p></li>
<li><p><strong>Callback:</strong> A function passed to another function to be executed when an asynchronous operation completes.</p></li>
<li><p><strong>Long Stack Traces:</strong> A Bluebird feature that provides greatly enhanced and detailed stack traces in case of errors or rejections, improving the debugging experience for asynchronous code.</p></li>
</ul>
<h3 id="further-reading-and-resources">Further Reading and Resources</h3>
<ul>
<li><p><strong>Bluebird GitHub Repository:</strong> <a href="https://github.com/petkaantonov/bluebird">https://github.com/petkaantonov/bluebird</a> – The official source code repository, containing detailed documentation and issue tracking.</p></li>
<li><p><strong>Promises/A+ Specification:</strong> <a href="https://promisesaplus.com/">https://promisesaplus.com/</a> – The specification that Bluebird adheres to. Understanding this specification helps in grasping the core principles of promises.</p></li>
<li><p><strong>MDN Web Docs on Promises:</strong> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</a> – A good resource for understanding the fundamental concepts of JavaScript promises.</p></li>
<li><p><strong>Articles and Tutorials on Asynchronous JavaScript:</strong> Search online for tutorials and articles focusing on asynchronous programming in JavaScript. Many resources delve deeper into managing asynchronous operations, handling errors, and optimizing performance. Look for materials discussing concepts such as async/await, generators, and concurrency control.</p></li>
</ul>
<p>This appendix serves as a starting point for further exploration. The JavaScript ecosystem continually evolves, so staying current with best practices and exploring new tools is crucial for efficient asynchronous programming.</p>


<footer>Copyright 2025 - Muthukrishnan</footer>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561" crossorigin="anonymous"></script>




</body></html>