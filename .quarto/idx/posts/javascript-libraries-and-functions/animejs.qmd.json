{"title":"anime.js - Documentation","markdown":{"yaml":{"title":"anime.js - Documentation","categories":["JavaScript Libraries and Functions"]},"headingText":"What is anime.js?","containsRefs":false,"markdown":"\n\n\n\nanime.js is a lightweight and versatile JavaScript animation library.  It allows you to create compelling animations for your web projects with a simple, yet powerful API.  Unlike some animation libraries that focus on specific animation types, anime.js offers a flexible approach, letting you animate almost any CSS property, SVG attribute, or JavaScript object property. This makes it ideal for a wide range of animation needs, from simple transitions to complex, multi-element sequences.  Its intuitive syntax and well-documented API make it easy to learn and use, even for developers with limited animation experience.  Anime.js prioritizes performance and smooth animations, even on less powerful devices.\n\n\n### Setting up anime.js\n\nThere are several ways to include anime.js in your project:\n\n* **CDN:** The easiest method is using a CDN link directly in your HTML `<head>`:\n\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js\"></script>\n```\nRemember to replace `3.2.1` with the latest version number if needed.  Check the official anime.js website for the most up-to-date version.\n\n* **npm:** For projects using npm (Node Package Manager), install anime.js using:\n\n```bash\nnpm install animejs\n```\n\nThen, you can import it into your JavaScript file:\n\n```javascript\nimport anime from 'animejs';\n```\n\n* **Yarn:** If you're using Yarn, the installation is similar:\n\n```bash\nyarn add animejs\n```\n\nFollowed by the import:\n\n```javascript\nimport anime from 'animejs';\n```\n\nAfter including anime.js using your preferred method, you're ready to start creating animations.\n\n\n### Basic animation concepts\n\nUnderstanding a few key concepts will make using anime.js much easier.  Anime.js animations are defined using *targets*, *properties*, *values*, *duration*, and *easing*.\n\n* **Targets:** This specifies the HTML element(s) or JavaScript object(s) you want to animate.  This can be a CSS selector (e.g., `'.element'`), a DOM element, or an array of elements.\n\n* **Properties:** These are the CSS properties, SVG attributes, or JavaScript object properties you want to change over time.  Examples include `'left'`, `'opacity'`, `'transform'`, `'fill'`, etc.\n\n* **Values:** These determine the start and end values for your animation.  They can be single values, arrays of values for keyframes, or even functions for more complex animations.\n\n* **Duration:** This specifies the animation's length in milliseconds.\n\n* **Easing:** This controls the animation's speed and smoothness over time. Anime.js offers a variety of built-in easing functions, and you can also define custom easing functions.\n\nA simple animation might look like this:\n\n```javascript\nanime({\n  targets: '.element',\n  opacity: [0, 1], //Start at 0 opacity, end at 1\n  duration: 1000, //1 second\n  easing: 'easeInOutQuad'\n});\n```\n\nThis code animates the opacity of an element with the class \"element\" from 0 to 1 over one second, using a smooth easeInOutQuad easing function.  More complex animations can be created by adding more properties, keyframes, and animation parameters.\n\n\n## Core Concepts and API\n\n### The `anime()` function\n\nThe heart of anime.js is the `anime()` function.  This function takes a single object as an argument, which defines all aspects of the animation.  This object can contain various properties, each controlling a specific aspect of the animation's behavior.  The most fundamental properties are `targets`, `properties`, `duration`, and `easing`, as introduced previously.  However, `anime()` supports a rich set of options for fine-grained control over your animations.  A basic example illustrates its structure:\n\n\n```javascript\nanime({\n  targets: '.element',\n  translateX: 250,\n  duration: 1000,\n  easing: 'linear'\n});\n```\n\nThis animates the `.element`'s horizontal position by 250 pixels over one second using linear easing.  The `anime()` function returns an `anime.Anime` instance, which allows you to control the animation after it's started (discussed in \"Controlling animation playback\").\n\n\n### Targets and properties\n\n`targets` specifies what to animate.  It accepts a variety of values:\n\n* **CSS Selectors:**  Strings like `'.my-class'`, `'#my-id'`, or `'div p'` select elements in the DOM.\n* **DOM Elements:**  An array or a single DOM element.\n* **Arrays of Elements:**  Multiple elements can be animated simultaneously.\n* **JavaScript Objects:** Animate properties of plain JavaScript objects.\n\n`properties` dictates which properties to animate. These can be CSS properties (e.g., `'left'`, `'opacity'`, `'transform'`), SVG attributes (e.g., `'cx'`, `'fill'`, `'d'`), or custom JavaScript object properties.  You can animate multiple properties simultaneously by passing an object:\n\n```javascript\nanime({\n  targets: '.element',\n  properties: {\n    translateX: 250,\n    opacity: [1, 0] // Array for start and end values\n  },\n  duration: 1000\n});\n```\n\n\n### Animation timelines\n\nAnime.js doesn't have a dedicated timeline object in the same way some other animation libraries do. Instead,  the sequencing and synchronization of animations are typically achieved using `delay`, `begin`, `complete`, and `update` callbacks within the `anime()` function, and through chaining animations (explained below).  You can precisely control when animations start and end relative to each other using these methods.\n\n\n### Easing functions\n\nEasing functions control the animation's speed and smoothness over time. Anime.js provides a wide variety of pre-defined easing functions (e.g., `'linear'`, `'easeInQuad'`, `'easeOutCubic'`, `'easeInOutElastic'`), which can be specified via the `easing` property in the `anime()` options object.  For custom easing, you can provide a function that takes a normalized time value (0 to 1) and returns the corresponding eased value.  Refer to the documentation for the full list of built-in easing functions.\n\n\n### Animation loops and iterations\n\nTo create looping animations, use the `loop` property within the `anime()` options.  Setting `loop: true` will repeat the animation indefinitely.  You can control the number of repetitions with `loop: n` where `n` is the number of times to loop.\n\n\n### Staggering animations\n\nAnime.js allows staggering the animations of multiple elements.  The `delay` property can be an array to provide unique delays for each element, or you can use the `stagger` property to create a uniform delay between consecutive elements:\n\n```javascript\nanime({\n  targets: '.element',\n  translateX: 250,\n  duration: 1000,\n  delay: anime.stagger(200) // 200ms delay between each element\n});\n```\n\n\n### Chaining animations\n\nAnime.js makes chaining animations straightforward.  You can queue animations one after another. The `complete` callback of one animation can trigger the next.  More sophisticated sequencing can be achieved by using promises.\n\n```javascript\nanime({\n    targets: '.element',\n    translateX: 250,\n    duration: 1000,\n    complete: function() {\n        anime({\n            targets: '.element',\n            translateY: 250,\n            duration: 1000\n        });\n    }\n});\n\n```\n\n\n### Controlling animation playback\n\nThe `anime()` function returns an `anime.Anime` instance. This instance provides methods to control the animation's playback:\n\n* **`animeInstance.play()`:** Resumes a paused animation.\n* **`animeInstance.pause()`:** Pauses an animation.\n* **`animeInstance.reverse()`:** Reverses the animation's direction.\n* **`animeInstance.restart()`:** Restarts the animation from the beginning.\n* **`animeInstance.seek(time)`:** Jumps to a specific time in the animation (in milliseconds).\n* **`animeInstance.finished`:** A promise that resolves when the animation completes.\n* **`animeInstance.stop()`:** Stops the animation immediately.\n\n\nThese methods offer comprehensive control over animation playback, enabling dynamic and interactive animation sequences.\n\n\n## Animation Properties\n\n### Transformations (`translateX`, `translateY`, `scale`, `rotate`, etc.)\n\nAnime.js provides comprehensive support for CSS transform properties.  You can animate `translateX`, `translateY`, `translateZ`, `scale`, `scaleX`, `scaleY`, `scaleZ`, `rotate`, `rotateX`, `rotateY`, `rotateZ`, `skew`, `skewX`, `skewY`, and `matrix` directly.  These properties accept numerical values (representing pixels for translations, ratios for scale, and degrees for rotations).  You can also use array values to specify start and end values or create keyframes:\n\n\n```javascript\nanime({\n  targets: '.element',\n  translateX: 250, //Move 250px to the right\n  rotate: 360, //Rotate 360 degrees\n  scale: 2, //Scale to double size\n  duration: 1000\n});\n\n\nanime({\n  targets: '.element',\n  scale: [1, 2, 1], //Scale from 1 to 2 and back to 1\n  duration: 2000\n});\n```\n\nNote that for transforms involving multiple properties, it's generally more efficient to use a single `transform` property with a string value (e.g., `\"translate(10px, 20px) rotate(45deg)\"`).  However, Anime.js's individual transform property support offers more granular control and easier readability.\n\n### Opacity\n\nThe `opacity` property controls the transparency of an element. Values range from 0 (fully transparent) to 1 (fully opaque).  Animations can smoothly transition between different opacity levels:\n\n```javascript\nanime({\n  targets: '.element',\n  opacity: [0, 1], //Fade in\n  duration: 1000,\n  easing: 'easeInOutSine'\n});\n\nanime({\n  targets: '.element',\n  opacity: {\n    value: 0,\n    duration: 1000\n  }\n});\n```\n\n### Color attributes\n\nAnime.js handles color animations effectively. You can animate CSS properties like `color`, `background-color`, `border-color`, `fill` (for SVG elements), and `stroke` (for SVG elements).  These properties accept various color formats, including hexadecimal (`#FF0000`), RGB (`rgb(255, 0, 0)`), RGBA (`rgba(255, 0, 0, 0.5)`), HSL (`hsl(0, 100%, 50%)`), and named colors (`red`).   Anime.js will interpolate between colors automatically:\n\n```javascript\nanime({\n  targets: '.element',\n  backgroundColor: ['#FF0000', '#0000FF'], //Animate from red to blue\n  duration: 1500\n});\n\nanime({\n  targets: '.element',\n  color: ['red', 'green', 'blue'], //Animate through multiple colors\n  duration: 3000\n});\n\n```\n\n### Other CSS properties\n\nAnime.js can animate a wide range of other CSS properties, including:\n\n* **Dimensions:** `width`, `height`, `maxWidth`, `maxHeight`, `minWidth`, `minHeight`, `left`, `top`, `right`, `bottom`, `margin`, `padding`, `border`, etc.\n* **Box-shadow:**  The `boxShadow` property allows you to animate the position, blur radius, and color of the box-shadow.\n* **Text properties:** `fontSize`, `fontWeight`, `fontFamily`, `lineHeight`, etc.\n* **Filter effects:** `blur`, `grayscale`, `sepia`, `hue-rotate`, etc.  (Note: browser compatibility for filter animations may vary.)\n\n\nRemember to consult the official documentation for the most up-to-date list of supported CSS properties.  For properties that are not directly supported, you might need to use JavaScript to indirectly manipulate the property values.  For example, if you want to animate the `scroll-top` property, you would need to use JavaScript to get and set the scroll position, as it is not directly animatable using CSS.\n\n\n## Advanced Techniques\n\n### Creating complex animations\n\nAnime.js excels at creating intricate animations involving multiple elements, properties, and timelines.  To achieve complexity, leverage several key features:\n\n* **Keyframes:**  Use arrays within property values to define keyframes for smooth, non-linear animations:\n\n```javascript\nanime({\n  targets: '.element',\n  translateX: [\n    {value: 200, easing: 'easeInOutSine'},\n    {value: -100, easing: 'easeOutExpo'}\n  ],\n  duration: 2000\n});\n```\n\n* **Staggering and Delays:** Fine-tune the timing of animations within a sequence using `stagger` and `delay` properties to create visually engaging effects, such as wave-like animations or cascading effects.\n\n* **Chaining Animations:** Sequence animations using callbacks (`complete`, `begin`) or Promises to create intricate flows of animation events.  Asynchronous operations can be integrated seamlessly.\n\n* **Complex Easing:** Employ custom easing functions or explore the numerous built-in easing functions to achieve precise control over animation curves.\n\n\n### Using animation events\n\nAnime.js provides several events that trigger callbacks at specific points within the animation lifecycle:\n\n* **`begin`:** Executes a function when the animation starts.\n* **`update`:** Executes a function on every animation frame, providing access to the current animation values.  This is useful for real-time updates or dynamic behavior.\n* **`complete`:** Executes a function when the animation finishes.\n* **`loopComplete`:** For looping animations, this event fires at the end of each loop.\n* **`pause`:** Executes a function when the animation is paused.\n* **`resume`:** Executes a function when the animation resumes after being paused.\n\nUse these events to trigger other actions, create interactive elements, or synchronize animations with other parts of your application.\n\n\n### Working with SVG\n\nAnime.js seamlessly animates SVG attributes.  Animate `cx`, `cy`, `r`, `x`, `y`, `width`, `height`, `fill`, `stroke`, `stroke-width`, and path data (`d` attribute) to create dynamic SVG animations.\n\n```javascript\nanime({\n  targets: 'circle', //select SVG circle\n  r: 100,\n  fill: '#f00',\n  duration: 1000\n});\n\nanime({\n  targets: 'path', //select SVG path\n  d: [ //array of path data strings as keyframes\n    'M10 10 H 90 V 90 H 10 Z',\n    'M10 10 H 90 V 90 H 10 L 50 150 Z'\n  ],\n  duration: 2000\n});\n```\n\n\n### Integrating with other libraries\n\nAnime.js is designed to be compatible with other JavaScript libraries.  You can seamlessly integrate it into your existing projects using frameworks like React, Vue, or Angular.  Remember to manage dependencies carefully and consider the order in which libraries are loaded.\n\n### Performance optimization\n\nFor optimal performance, consider these strategies:\n\n* **Minimize the number of elements animated:**  Animate only the elements that require animation.\n* **Use hardware acceleration where possible:**  Utilize CSS transforms whenever feasible, as they are often hardware-accelerated.\n* **Optimize easing functions:** Complex or computationally expensive easing functions can impact performance.  Choose efficient easing functions, or create custom functions with performance in mind.\n* **Avoid unnecessary updates:** If you're using the `update` event, only perform the necessary calculations within the callback.\n* **Avoid blocking the main thread:** Use `requestAnimationFrame` or other techniques to prevent the animation from blocking other parts of your application.  Anime.js itself is generally well-optimized, so this is less crucial unless you have extremely complex animations.\n\n\nBy following these guidelines, you can create complex, visually stunning animations with anime.js while maintaining smooth performance.\n\n\n## Examples and Use Cases\n\n### Simple animation examples\n\nHere are a few simple examples to get you started:\n\n**1.  Fade-in effect:**\n\n```javascript\nanime({\n  targets: '.element',\n  opacity: [0, 1],\n  duration: 1000\n});\n```\n\nThis code fades in an element with the class \"element\" over one second.\n\n**2.  Moving an element:**\n\n```javascript\nanime({\n  targets: '.element',\n  translateX: 200,\n  duration: 1500,\n  easing: 'easeInOutQuad'\n});\n```\n\nThis moves the element 200 pixels to the right using a smooth easing function.\n\n**3.  Scaling an element:**\n\n```javascript\nanime({\n  targets: '.element',\n  scale: 1.5,\n  duration: 800\n});\n```\n\nThis scales the element to 150% of its original size.\n\n\n### Complex animation examples\n\nMore complex animations can combine multiple properties, keyframes, and event handlers. Here's an example of animating multiple elements with different delays:\n\n\n```javascript\nanime({\n  targets: '.box',\n  translateX: 250,\n  duration: 1000,\n  delay: anime.stagger(200),\n  easing: 'easeInOutElastic'\n});\n```\n\nThis code animates multiple elements with the class \"box,\" each with a 200ms delay between them, moving them to the right with a bouncy easing effect.\n\n\nAnother example demonstrates a more involved keyframe animation:\n\n```javascript\nanime({\n  targets: '.circle',\n  keyframes: [\n    {scale: 1, opacity: 1},\n    {scale: 2, opacity: 0.5},\n    {scale: 1, opacity: 1}\n  ],\n  duration: 2000,\n  loop: true\n});\n```\n\nThis creates a pulsing circle animation.\n\n\n\n### Real-world use cases\n\nAnime.js is applicable to a wide range of scenarios:\n\n* **Loading indicators:** Create smooth and visually appealing loading animations.\n* **Interactive elements:** Animate elements on hover, click, or other user interactions.\n* **Micro-interactions:** Add subtle animations to enhance user experience.\n* **Data visualizations:** Animate charts and graphs to improve readability and engagement.\n* **Game development:** Although not specifically designed for game development, anime.js can be used for simpler animation requirements within games.\n* **Web page transitions:** Craft more engaging transitions between pages or sections of a website.\n* **UI Animations:**  Enhance the user interface of web applications with smooth transitions, feedback animations, and other visual effects.\n\n\n### Creating custom animations\n\nAnime.js's flexibility makes building custom animations relatively easy. You combine different properties, easing functions, and event handlers to create your unique animations. For instance, you could animate the stroke-dasharray property of an SVG path to create a drawing effect, or use the update event to dynamically change animation parameters based on user input or other real-time data.  The library provides the building blocks; your creativity determines the final animation.  Experimentation is encouraged!\n\n\n## Troubleshooting and Debugging\n\n### Common issues and solutions\n\nHere are some common issues encountered when using anime.js and their solutions:\n\n* **Animation doesn't play:**\n    * **Problem:**  Check if anime.js is correctly included in your project.  Ensure there are no typos in the script tag or import statement. Verify that the target elements exist in the DOM when the animation is initiated.  Confirm that there are no JavaScript errors preventing the animation from running.\n    * **Solution:** Double-check the inclusion of the library, inspect the console for errors, and use browser developer tools to ensure the target elements are available.\n\n* **Animation is jerky or not smooth:**\n    * **Problem:** This might be due to performance bottlenecks, particularly with many elements or complex animations.  Overly complex easing functions can also contribute.\n    * **Solution:** Optimize the animation (fewer elements, simpler easing), ensure hardware acceleration where possible (using transforms), and check for performance bottlenecks in your browser's developer tools.\n\n* **Incorrect animation behavior:**\n    * **Problem:** This often results from errors in the `anime()` function's parameters, such as incorrect property names, invalid values, or misuse of keyframes.\n    * **Solution:** Carefully review the animation parameters. Use the browser's developer console to inspect the values of the properties being animated to identify discrepancies.\n\n* **Animation doesn't stop or pause correctly:**\n    * **Problem:** This can occur if the `stop()` or `pause()` method isn't called correctly on the returned `anime.Anime` instance.\n    * **Solution:** Make sure you are using the correct method (`animeInstance.stop()`, `animeInstance.pause()`) on the instance returned by `anime()`.\n\n\n* **Unexpected behavior with SVG animations:**\n    * **Problem:** SVG animation can be more complex.  Incorrect path data, missing attributes, or browser compatibility issues might cause problems.\n    * **Solution:** Carefully check your SVG markup and ensure the attributes you are animating exist. Test in different browsers to check for compatibility. Use your browser's developer tools to inspect the SVG elements.\n\n* **Conflicting libraries:**\n    * **Problem:**  Anime.js might conflict with other JavaScript libraries that manipulate the DOM or handle animations.\n    * **Solution:** Try loading anime.js after other libraries or resolving any potential conflicts by adjusting the order of execution.\n\n\n### Debugging tools and techniques\n\nSeveral tools and techniques can aid in debugging anime.js animations:\n\n* **Browser Developer Tools:**  Use your browser's developer tools (usually accessed by pressing F12) to inspect the elements, network requests, console errors, and animation performance.  The console allows you to log values and trace the execution flow.\n\n* **Console Logging:** Use `console.log()` statements within your JavaScript code to track variable values, the timing of events, and the status of the animations.  This will help to pinpoint problems.\n\n* **Step-through Debugging:**  Set breakpoints in your code using your browser's debugger and step through the execution line by line.  This allows you to observe variable changes and track the progress of the animation.\n\n* **Simplify your code:**  When facing complex issues, try to isolate the problem by creating a minimal, reproducible example. This will help to identify the root cause more easily.\n\n* **Check the anime.js documentation:** The official documentation provides detailed explanations of the API, common issues, and best practices.\n\nBy using these tools and techniques, you'll be able to efficiently identify and resolve any problems you encounter when working with anime.js.  Remember to check the console for errors—this is often the first place to find clues about why an animation isn't working as expected.\n\n\n## Appendix\n\n### Glossary of terms\n\n* **Targets:** The HTML elements, SVG elements, or JavaScript objects that will be animated.\n* **Properties:** The CSS properties, SVG attributes, or JavaScript object properties being animated.\n* **Values:** The starting and ending values (or keyframes) for the animated properties.\n* **Duration:** The length of the animation in milliseconds.\n* **Easing:**  A function that determines the speed and smoothness of the animation over time.\n* **Keyframes:**  Intermediate points in an animation, defining the state at specific times.\n* **Stagger:**  A delay applied between animations of multiple targets, creating sequential or staggered effects.\n* **Callback:**  A function executed at specific points in the animation lifecycle (e.g., `begin`, `complete`, `update`).\n* **Timeline:**  While anime.js doesn't have a formal \"Timeline\" object, it refers to the sequencing and synchronization of animations using delays, callbacks, and chaining.\n\n\n### List of easing functions\n\nAnime.js provides a wide range of easing functions.  A complete list is available in the official documentation.  However, here are some examples of the common easing function types and their general behavior:\n\n* **Linear:** Constant speed throughout the animation.\n* **Quadratic (easeInQuad, easeOutQuad, easeInOutQuad):**  Acceleration or deceleration at the beginning or end.\n* **Cubic (easeInCubic, easeOutCubic, easeInOutCubic):** Similar to quadratic, but with a more pronounced acceleration/deceleration effect.\n* **Quartic (easeInQuart, easeOutQuart, easeInOutQuart):**  Even more pronounced acceleration/deceleration than cubic.\n* **Quintic (easeInQuint, easeOutQuint, easeInOutQuint):**  Similar to quartic, but even smoother.\n* **Sine (easeInSine, easeOutSine, easeInOutSine):**  Smooth, sinusoidal easing.\n* **Exponential (easeInExpo, easeOutExpo, easeInOutExpo):**  Fast start or end with slow middle.\n* **Circular (easeInCirc, easeOutCirc, easeInOutCirc):**  Smooth, circular easing.\n* **Elastic (easeInElastic, easeOutElastic, easeInOutElastic):**  Bouncy, spring-like effect.\n* **Back (easeInBack, easeOutBack, easeInOutBack):** Overshoots the target before settling.\n* **Bounce (easeInBounce, easeOutBounce, easeInOutBounce):**  Bounces before coming to a stop.\n\n\nThe exact behavior of each easing function can be found in the official anime.js documentation.  You can also define and use your own custom easing functions.\n\n\n### Browser compatibility\n\nAnime.js is designed to be compatible with modern web browsers.  While it strives for broad compatibility, some features might have limitations depending on the browser and its version.  Generally, modern browsers (Chrome, Firefox, Safari, Edge) should provide good support.  However, for older browsers or those with limited JavaScript engine capabilities, you might need to consider polyfills or alternative approaches for certain features.  Always test your animations across the target browsers to ensure consistent behavior.  Consult the official documentation or release notes for the most up-to-date information on browser compatibility.\n\n","srcMarkdownNoYaml":"\n\n\n### What is anime.js?\n\nanime.js is a lightweight and versatile JavaScript animation library.  It allows you to create compelling animations for your web projects with a simple, yet powerful API.  Unlike some animation libraries that focus on specific animation types, anime.js offers a flexible approach, letting you animate almost any CSS property, SVG attribute, or JavaScript object property. This makes it ideal for a wide range of animation needs, from simple transitions to complex, multi-element sequences.  Its intuitive syntax and well-documented API make it easy to learn and use, even for developers with limited animation experience.  Anime.js prioritizes performance and smooth animations, even on less powerful devices.\n\n\n### Setting up anime.js\n\nThere are several ways to include anime.js in your project:\n\n* **CDN:** The easiest method is using a CDN link directly in your HTML `<head>`:\n\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js\"></script>\n```\nRemember to replace `3.2.1` with the latest version number if needed.  Check the official anime.js website for the most up-to-date version.\n\n* **npm:** For projects using npm (Node Package Manager), install anime.js using:\n\n```bash\nnpm install animejs\n```\n\nThen, you can import it into your JavaScript file:\n\n```javascript\nimport anime from 'animejs';\n```\n\n* **Yarn:** If you're using Yarn, the installation is similar:\n\n```bash\nyarn add animejs\n```\n\nFollowed by the import:\n\n```javascript\nimport anime from 'animejs';\n```\n\nAfter including anime.js using your preferred method, you're ready to start creating animations.\n\n\n### Basic animation concepts\n\nUnderstanding a few key concepts will make using anime.js much easier.  Anime.js animations are defined using *targets*, *properties*, *values*, *duration*, and *easing*.\n\n* **Targets:** This specifies the HTML element(s) or JavaScript object(s) you want to animate.  This can be a CSS selector (e.g., `'.element'`), a DOM element, or an array of elements.\n\n* **Properties:** These are the CSS properties, SVG attributes, or JavaScript object properties you want to change over time.  Examples include `'left'`, `'opacity'`, `'transform'`, `'fill'`, etc.\n\n* **Values:** These determine the start and end values for your animation.  They can be single values, arrays of values for keyframes, or even functions for more complex animations.\n\n* **Duration:** This specifies the animation's length in milliseconds.\n\n* **Easing:** This controls the animation's speed and smoothness over time. Anime.js offers a variety of built-in easing functions, and you can also define custom easing functions.\n\nA simple animation might look like this:\n\n```javascript\nanime({\n  targets: '.element',\n  opacity: [0, 1], //Start at 0 opacity, end at 1\n  duration: 1000, //1 second\n  easing: 'easeInOutQuad'\n});\n```\n\nThis code animates the opacity of an element with the class \"element\" from 0 to 1 over one second, using a smooth easeInOutQuad easing function.  More complex animations can be created by adding more properties, keyframes, and animation parameters.\n\n\n## Core Concepts and API\n\n### The `anime()` function\n\nThe heart of anime.js is the `anime()` function.  This function takes a single object as an argument, which defines all aspects of the animation.  This object can contain various properties, each controlling a specific aspect of the animation's behavior.  The most fundamental properties are `targets`, `properties`, `duration`, and `easing`, as introduced previously.  However, `anime()` supports a rich set of options for fine-grained control over your animations.  A basic example illustrates its structure:\n\n\n```javascript\nanime({\n  targets: '.element',\n  translateX: 250,\n  duration: 1000,\n  easing: 'linear'\n});\n```\n\nThis animates the `.element`'s horizontal position by 250 pixels over one second using linear easing.  The `anime()` function returns an `anime.Anime` instance, which allows you to control the animation after it's started (discussed in \"Controlling animation playback\").\n\n\n### Targets and properties\n\n`targets` specifies what to animate.  It accepts a variety of values:\n\n* **CSS Selectors:**  Strings like `'.my-class'`, `'#my-id'`, or `'div p'` select elements in the DOM.\n* **DOM Elements:**  An array or a single DOM element.\n* **Arrays of Elements:**  Multiple elements can be animated simultaneously.\n* **JavaScript Objects:** Animate properties of plain JavaScript objects.\n\n`properties` dictates which properties to animate. These can be CSS properties (e.g., `'left'`, `'opacity'`, `'transform'`), SVG attributes (e.g., `'cx'`, `'fill'`, `'d'`), or custom JavaScript object properties.  You can animate multiple properties simultaneously by passing an object:\n\n```javascript\nanime({\n  targets: '.element',\n  properties: {\n    translateX: 250,\n    opacity: [1, 0] // Array for start and end values\n  },\n  duration: 1000\n});\n```\n\n\n### Animation timelines\n\nAnime.js doesn't have a dedicated timeline object in the same way some other animation libraries do. Instead,  the sequencing and synchronization of animations are typically achieved using `delay`, `begin`, `complete`, and `update` callbacks within the `anime()` function, and through chaining animations (explained below).  You can precisely control when animations start and end relative to each other using these methods.\n\n\n### Easing functions\n\nEasing functions control the animation's speed and smoothness over time. Anime.js provides a wide variety of pre-defined easing functions (e.g., `'linear'`, `'easeInQuad'`, `'easeOutCubic'`, `'easeInOutElastic'`), which can be specified via the `easing` property in the `anime()` options object.  For custom easing, you can provide a function that takes a normalized time value (0 to 1) and returns the corresponding eased value.  Refer to the documentation for the full list of built-in easing functions.\n\n\n### Animation loops and iterations\n\nTo create looping animations, use the `loop` property within the `anime()` options.  Setting `loop: true` will repeat the animation indefinitely.  You can control the number of repetitions with `loop: n` where `n` is the number of times to loop.\n\n\n### Staggering animations\n\nAnime.js allows staggering the animations of multiple elements.  The `delay` property can be an array to provide unique delays for each element, or you can use the `stagger` property to create a uniform delay between consecutive elements:\n\n```javascript\nanime({\n  targets: '.element',\n  translateX: 250,\n  duration: 1000,\n  delay: anime.stagger(200) // 200ms delay between each element\n});\n```\n\n\n### Chaining animations\n\nAnime.js makes chaining animations straightforward.  You can queue animations one after another. The `complete` callback of one animation can trigger the next.  More sophisticated sequencing can be achieved by using promises.\n\n```javascript\nanime({\n    targets: '.element',\n    translateX: 250,\n    duration: 1000,\n    complete: function() {\n        anime({\n            targets: '.element',\n            translateY: 250,\n            duration: 1000\n        });\n    }\n});\n\n```\n\n\n### Controlling animation playback\n\nThe `anime()` function returns an `anime.Anime` instance. This instance provides methods to control the animation's playback:\n\n* **`animeInstance.play()`:** Resumes a paused animation.\n* **`animeInstance.pause()`:** Pauses an animation.\n* **`animeInstance.reverse()`:** Reverses the animation's direction.\n* **`animeInstance.restart()`:** Restarts the animation from the beginning.\n* **`animeInstance.seek(time)`:** Jumps to a specific time in the animation (in milliseconds).\n* **`animeInstance.finished`:** A promise that resolves when the animation completes.\n* **`animeInstance.stop()`:** Stops the animation immediately.\n\n\nThese methods offer comprehensive control over animation playback, enabling dynamic and interactive animation sequences.\n\n\n## Animation Properties\n\n### Transformations (`translateX`, `translateY`, `scale`, `rotate`, etc.)\n\nAnime.js provides comprehensive support for CSS transform properties.  You can animate `translateX`, `translateY`, `translateZ`, `scale`, `scaleX`, `scaleY`, `scaleZ`, `rotate`, `rotateX`, `rotateY`, `rotateZ`, `skew`, `skewX`, `skewY`, and `matrix` directly.  These properties accept numerical values (representing pixels for translations, ratios for scale, and degrees for rotations).  You can also use array values to specify start and end values or create keyframes:\n\n\n```javascript\nanime({\n  targets: '.element',\n  translateX: 250, //Move 250px to the right\n  rotate: 360, //Rotate 360 degrees\n  scale: 2, //Scale to double size\n  duration: 1000\n});\n\n\nanime({\n  targets: '.element',\n  scale: [1, 2, 1], //Scale from 1 to 2 and back to 1\n  duration: 2000\n});\n```\n\nNote that for transforms involving multiple properties, it's generally more efficient to use a single `transform` property with a string value (e.g., `\"translate(10px, 20px) rotate(45deg)\"`).  However, Anime.js's individual transform property support offers more granular control and easier readability.\n\n### Opacity\n\nThe `opacity` property controls the transparency of an element. Values range from 0 (fully transparent) to 1 (fully opaque).  Animations can smoothly transition between different opacity levels:\n\n```javascript\nanime({\n  targets: '.element',\n  opacity: [0, 1], //Fade in\n  duration: 1000,\n  easing: 'easeInOutSine'\n});\n\nanime({\n  targets: '.element',\n  opacity: {\n    value: 0,\n    duration: 1000\n  }\n});\n```\n\n### Color attributes\n\nAnime.js handles color animations effectively. You can animate CSS properties like `color`, `background-color`, `border-color`, `fill` (for SVG elements), and `stroke` (for SVG elements).  These properties accept various color formats, including hexadecimal (`#FF0000`), RGB (`rgb(255, 0, 0)`), RGBA (`rgba(255, 0, 0, 0.5)`), HSL (`hsl(0, 100%, 50%)`), and named colors (`red`).   Anime.js will interpolate between colors automatically:\n\n```javascript\nanime({\n  targets: '.element',\n  backgroundColor: ['#FF0000', '#0000FF'], //Animate from red to blue\n  duration: 1500\n});\n\nanime({\n  targets: '.element',\n  color: ['red', 'green', 'blue'], //Animate through multiple colors\n  duration: 3000\n});\n\n```\n\n### Other CSS properties\n\nAnime.js can animate a wide range of other CSS properties, including:\n\n* **Dimensions:** `width`, `height`, `maxWidth`, `maxHeight`, `minWidth`, `minHeight`, `left`, `top`, `right`, `bottom`, `margin`, `padding`, `border`, etc.\n* **Box-shadow:**  The `boxShadow` property allows you to animate the position, blur radius, and color of the box-shadow.\n* **Text properties:** `fontSize`, `fontWeight`, `fontFamily`, `lineHeight`, etc.\n* **Filter effects:** `blur`, `grayscale`, `sepia`, `hue-rotate`, etc.  (Note: browser compatibility for filter animations may vary.)\n\n\nRemember to consult the official documentation for the most up-to-date list of supported CSS properties.  For properties that are not directly supported, you might need to use JavaScript to indirectly manipulate the property values.  For example, if you want to animate the `scroll-top` property, you would need to use JavaScript to get and set the scroll position, as it is not directly animatable using CSS.\n\n\n## Advanced Techniques\n\n### Creating complex animations\n\nAnime.js excels at creating intricate animations involving multiple elements, properties, and timelines.  To achieve complexity, leverage several key features:\n\n* **Keyframes:**  Use arrays within property values to define keyframes for smooth, non-linear animations:\n\n```javascript\nanime({\n  targets: '.element',\n  translateX: [\n    {value: 200, easing: 'easeInOutSine'},\n    {value: -100, easing: 'easeOutExpo'}\n  ],\n  duration: 2000\n});\n```\n\n* **Staggering and Delays:** Fine-tune the timing of animations within a sequence using `stagger` and `delay` properties to create visually engaging effects, such as wave-like animations or cascading effects.\n\n* **Chaining Animations:** Sequence animations using callbacks (`complete`, `begin`) or Promises to create intricate flows of animation events.  Asynchronous operations can be integrated seamlessly.\n\n* **Complex Easing:** Employ custom easing functions or explore the numerous built-in easing functions to achieve precise control over animation curves.\n\n\n### Using animation events\n\nAnime.js provides several events that trigger callbacks at specific points within the animation lifecycle:\n\n* **`begin`:** Executes a function when the animation starts.\n* **`update`:** Executes a function on every animation frame, providing access to the current animation values.  This is useful for real-time updates or dynamic behavior.\n* **`complete`:** Executes a function when the animation finishes.\n* **`loopComplete`:** For looping animations, this event fires at the end of each loop.\n* **`pause`:** Executes a function when the animation is paused.\n* **`resume`:** Executes a function when the animation resumes after being paused.\n\nUse these events to trigger other actions, create interactive elements, or synchronize animations with other parts of your application.\n\n\n### Working with SVG\n\nAnime.js seamlessly animates SVG attributes.  Animate `cx`, `cy`, `r`, `x`, `y`, `width`, `height`, `fill`, `stroke`, `stroke-width`, and path data (`d` attribute) to create dynamic SVG animations.\n\n```javascript\nanime({\n  targets: 'circle', //select SVG circle\n  r: 100,\n  fill: '#f00',\n  duration: 1000\n});\n\nanime({\n  targets: 'path', //select SVG path\n  d: [ //array of path data strings as keyframes\n    'M10 10 H 90 V 90 H 10 Z',\n    'M10 10 H 90 V 90 H 10 L 50 150 Z'\n  ],\n  duration: 2000\n});\n```\n\n\n### Integrating with other libraries\n\nAnime.js is designed to be compatible with other JavaScript libraries.  You can seamlessly integrate it into your existing projects using frameworks like React, Vue, or Angular.  Remember to manage dependencies carefully and consider the order in which libraries are loaded.\n\n### Performance optimization\n\nFor optimal performance, consider these strategies:\n\n* **Minimize the number of elements animated:**  Animate only the elements that require animation.\n* **Use hardware acceleration where possible:**  Utilize CSS transforms whenever feasible, as they are often hardware-accelerated.\n* **Optimize easing functions:** Complex or computationally expensive easing functions can impact performance.  Choose efficient easing functions, or create custom functions with performance in mind.\n* **Avoid unnecessary updates:** If you're using the `update` event, only perform the necessary calculations within the callback.\n* **Avoid blocking the main thread:** Use `requestAnimationFrame` or other techniques to prevent the animation from blocking other parts of your application.  Anime.js itself is generally well-optimized, so this is less crucial unless you have extremely complex animations.\n\n\nBy following these guidelines, you can create complex, visually stunning animations with anime.js while maintaining smooth performance.\n\n\n## Examples and Use Cases\n\n### Simple animation examples\n\nHere are a few simple examples to get you started:\n\n**1.  Fade-in effect:**\n\n```javascript\nanime({\n  targets: '.element',\n  opacity: [0, 1],\n  duration: 1000\n});\n```\n\nThis code fades in an element with the class \"element\" over one second.\n\n**2.  Moving an element:**\n\n```javascript\nanime({\n  targets: '.element',\n  translateX: 200,\n  duration: 1500,\n  easing: 'easeInOutQuad'\n});\n```\n\nThis moves the element 200 pixels to the right using a smooth easing function.\n\n**3.  Scaling an element:**\n\n```javascript\nanime({\n  targets: '.element',\n  scale: 1.5,\n  duration: 800\n});\n```\n\nThis scales the element to 150% of its original size.\n\n\n### Complex animation examples\n\nMore complex animations can combine multiple properties, keyframes, and event handlers. Here's an example of animating multiple elements with different delays:\n\n\n```javascript\nanime({\n  targets: '.box',\n  translateX: 250,\n  duration: 1000,\n  delay: anime.stagger(200),\n  easing: 'easeInOutElastic'\n});\n```\n\nThis code animates multiple elements with the class \"box,\" each with a 200ms delay between them, moving them to the right with a bouncy easing effect.\n\n\nAnother example demonstrates a more involved keyframe animation:\n\n```javascript\nanime({\n  targets: '.circle',\n  keyframes: [\n    {scale: 1, opacity: 1},\n    {scale: 2, opacity: 0.5},\n    {scale: 1, opacity: 1}\n  ],\n  duration: 2000,\n  loop: true\n});\n```\n\nThis creates a pulsing circle animation.\n\n\n\n### Real-world use cases\n\nAnime.js is applicable to a wide range of scenarios:\n\n* **Loading indicators:** Create smooth and visually appealing loading animations.\n* **Interactive elements:** Animate elements on hover, click, or other user interactions.\n* **Micro-interactions:** Add subtle animations to enhance user experience.\n* **Data visualizations:** Animate charts and graphs to improve readability and engagement.\n* **Game development:** Although not specifically designed for game development, anime.js can be used for simpler animation requirements within games.\n* **Web page transitions:** Craft more engaging transitions between pages or sections of a website.\n* **UI Animations:**  Enhance the user interface of web applications with smooth transitions, feedback animations, and other visual effects.\n\n\n### Creating custom animations\n\nAnime.js's flexibility makes building custom animations relatively easy. You combine different properties, easing functions, and event handlers to create your unique animations. For instance, you could animate the stroke-dasharray property of an SVG path to create a drawing effect, or use the update event to dynamically change animation parameters based on user input or other real-time data.  The library provides the building blocks; your creativity determines the final animation.  Experimentation is encouraged!\n\n\n## Troubleshooting and Debugging\n\n### Common issues and solutions\n\nHere are some common issues encountered when using anime.js and their solutions:\n\n* **Animation doesn't play:**\n    * **Problem:**  Check if anime.js is correctly included in your project.  Ensure there are no typos in the script tag or import statement. Verify that the target elements exist in the DOM when the animation is initiated.  Confirm that there are no JavaScript errors preventing the animation from running.\n    * **Solution:** Double-check the inclusion of the library, inspect the console for errors, and use browser developer tools to ensure the target elements are available.\n\n* **Animation is jerky or not smooth:**\n    * **Problem:** This might be due to performance bottlenecks, particularly with many elements or complex animations.  Overly complex easing functions can also contribute.\n    * **Solution:** Optimize the animation (fewer elements, simpler easing), ensure hardware acceleration where possible (using transforms), and check for performance bottlenecks in your browser's developer tools.\n\n* **Incorrect animation behavior:**\n    * **Problem:** This often results from errors in the `anime()` function's parameters, such as incorrect property names, invalid values, or misuse of keyframes.\n    * **Solution:** Carefully review the animation parameters. Use the browser's developer console to inspect the values of the properties being animated to identify discrepancies.\n\n* **Animation doesn't stop or pause correctly:**\n    * **Problem:** This can occur if the `stop()` or `pause()` method isn't called correctly on the returned `anime.Anime` instance.\n    * **Solution:** Make sure you are using the correct method (`animeInstance.stop()`, `animeInstance.pause()`) on the instance returned by `anime()`.\n\n\n* **Unexpected behavior with SVG animations:**\n    * **Problem:** SVG animation can be more complex.  Incorrect path data, missing attributes, or browser compatibility issues might cause problems.\n    * **Solution:** Carefully check your SVG markup and ensure the attributes you are animating exist. Test in different browsers to check for compatibility. Use your browser's developer tools to inspect the SVG elements.\n\n* **Conflicting libraries:**\n    * **Problem:**  Anime.js might conflict with other JavaScript libraries that manipulate the DOM or handle animations.\n    * **Solution:** Try loading anime.js after other libraries or resolving any potential conflicts by adjusting the order of execution.\n\n\n### Debugging tools and techniques\n\nSeveral tools and techniques can aid in debugging anime.js animations:\n\n* **Browser Developer Tools:**  Use your browser's developer tools (usually accessed by pressing F12) to inspect the elements, network requests, console errors, and animation performance.  The console allows you to log values and trace the execution flow.\n\n* **Console Logging:** Use `console.log()` statements within your JavaScript code to track variable values, the timing of events, and the status of the animations.  This will help to pinpoint problems.\n\n* **Step-through Debugging:**  Set breakpoints in your code using your browser's debugger and step through the execution line by line.  This allows you to observe variable changes and track the progress of the animation.\n\n* **Simplify your code:**  When facing complex issues, try to isolate the problem by creating a minimal, reproducible example. This will help to identify the root cause more easily.\n\n* **Check the anime.js documentation:** The official documentation provides detailed explanations of the API, common issues, and best practices.\n\nBy using these tools and techniques, you'll be able to efficiently identify and resolve any problems you encounter when working with anime.js.  Remember to check the console for errors—this is often the first place to find clues about why an animation isn't working as expected.\n\n\n## Appendix\n\n### Glossary of terms\n\n* **Targets:** The HTML elements, SVG elements, or JavaScript objects that will be animated.\n* **Properties:** The CSS properties, SVG attributes, or JavaScript object properties being animated.\n* **Values:** The starting and ending values (or keyframes) for the animated properties.\n* **Duration:** The length of the animation in milliseconds.\n* **Easing:**  A function that determines the speed and smoothness of the animation over time.\n* **Keyframes:**  Intermediate points in an animation, defining the state at specific times.\n* **Stagger:**  A delay applied between animations of multiple targets, creating sequential or staggered effects.\n* **Callback:**  A function executed at specific points in the animation lifecycle (e.g., `begin`, `complete`, `update`).\n* **Timeline:**  While anime.js doesn't have a formal \"Timeline\" object, it refers to the sequencing and synchronization of animations using delays, callbacks, and chaining.\n\n\n### List of easing functions\n\nAnime.js provides a wide range of easing functions.  A complete list is available in the official documentation.  However, here are some examples of the common easing function types and their general behavior:\n\n* **Linear:** Constant speed throughout the animation.\n* **Quadratic (easeInQuad, easeOutQuad, easeInOutQuad):**  Acceleration or deceleration at the beginning or end.\n* **Cubic (easeInCubic, easeOutCubic, easeInOutCubic):** Similar to quadratic, but with a more pronounced acceleration/deceleration effect.\n* **Quartic (easeInQuart, easeOutQuart, easeInOutQuart):**  Even more pronounced acceleration/deceleration than cubic.\n* **Quintic (easeInQuint, easeOutQuint, easeInOutQuint):**  Similar to quartic, but even smoother.\n* **Sine (easeInSine, easeOutSine, easeInOutSine):**  Smooth, sinusoidal easing.\n* **Exponential (easeInExpo, easeOutExpo, easeInOutExpo):**  Fast start or end with slow middle.\n* **Circular (easeInCirc, easeOutCirc, easeInOutCirc):**  Smooth, circular easing.\n* **Elastic (easeInElastic, easeOutElastic, easeInOutElastic):**  Bouncy, spring-like effect.\n* **Back (easeInBack, easeOutBack, easeInOutBack):** Overshoots the target before settling.\n* **Bounce (easeInBounce, easeOutBounce, easeInOutBounce):**  Bounces before coming to a stop.\n\n\nThe exact behavior of each easing function can be found in the official anime.js documentation.  You can also define and use your own custom easing functions.\n\n\n### Browser compatibility\n\nAnime.js is designed to be compatible with modern web browsers.  While it strives for broad compatibility, some features might have limitations depending on the browser and its version.  Generally, modern browsers (Chrome, Firefox, Safari, Edge) should provide good support.  However, for older browsers or those with limited JavaScript engine capabilities, you might need to consider polyfills or alternative approaches for certain features.  Always test your animations across the target browsers to ensure consistent behavior.  Consult the official documentation or release notes for the most up-to-date information on browser compatibility.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["../../styles.css"],"html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"},"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"},"../../footer.html"],"output-file":"animejs.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"license":"MIT","author-meta":"Muthukrishnan","title":"anime.js - Documentation","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}