{"title":"Vivus - Documentation","markdown":{"yaml":{"title":"Vivus - Documentation","categories":["JavaScript Libraries and Functions"]},"headingText":"What is Vivus?","containsRefs":false,"markdown":"\n\n\n\nVivus is a lightweight JavaScript library that animates SVGs.  It allows you to bring your static SVG illustrations to life by animating their strokes or fills, creating engaging and visually appealing effects.  Whether you're drawing a simple icon or a complex illustration, Vivus provides a simple and intuitive way to add animation to your SVGs without requiring extensive animation knowledge. It supports various animation types and allows for significant customization.\n\n### Key Features and Benefits\n\n* **Simplicity:** Vivus offers a clean and easy-to-use API, making it accessible to developers of all skill levels.\n* **Lightweight:** The library is small and efficient, minimizing the impact on your website's performance.\n* **Multiple Animation Types:**  Choose from several animation types, including `oneByOne`, `simultaneously`, `random`, and `delayed`, to customize the animation style.\n* **Customizability:** Fine-tune the animation speed, delay, type, and other parameters to match your specific design requirements.\n* **SVG Support:** Works seamlessly with SVG files created using any vector graphics editor.\n* **Ease of Integration:**  Easily integrate Vivus into your existing web projects using a simple script inclusion.\n* **Cross-browser Compatibility:**  Vivus is designed to work across a wide range of modern web browsers.\n\n\n### Setting up Vivus: Installation and Dependencies\n\nVivus is available via npm and CDN.\n\n**Using npm:**\n\n1. Install Vivus using npm:\n   ```bash\n   npm install vivus\n   ```\n2. Import it into your JavaScript code:\n   ```javascript\n   import Vivus from 'vivus';\n   ```\n\n**Using a CDN:**\n\nInclude the Vivus JavaScript file in your HTML `<head>`:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/vivus@latest/dist/vivus.min.js\"></script>\n```\n\nVivus has no external dependencies beyond a standard JavaScript environment supporting the `Promise` object.  Older browsers might require a polyfill if `Promise` is not natively supported.\n\n### Basic Usage Example\n\nThis example animates an SVG using the `oneByOne` animation type:\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<title>Vivus Example</title>\n<script src=\"https://cdn.jsdelivr.net/npm/vivus@latest/dist/vivus.min.js\"></script>\n</head>\n<body>\n\n<svg id=\"my-svg\" width=\"200\" height=\"200\">\n  <path d=\"M100,100 L150,150 L100,150 Z\" fill=\"none\" stroke=\"black\" stroke-width=\"2\"/>\n</svg>\n\n<script>\n  new Vivus('my-svg', {type: 'oneByOne'});\n</script>\n\n</body>\n</html>\n```\n\nThis code will find the SVG with the ID `my-svg` and animate its path using the `oneByOne` animation type.  Replace the SVG content with your own, and experiment with different animation types and options outlined in the Vivus documentation for more advanced usage.\n\n\n## Core Concepts\n\n### Understanding SVG Animation\n\nVivus animates SVGs by manipulating the `stroke-dasharray` and `stroke-dashoffset` properties of SVG paths.  Initially, the `stroke-dasharray` property is set to a value that represents the total length of the path, effectively hiding the stroke. The `stroke-dashoffset` property is then animated, gradually reducing its value from the total path length to zero. This reveals the stroke, creating the animation effect.  Vivus handles this complex process automatically, allowing you to focus on the creative aspects of your animations.  For fill animations, a similar approach is used, manipulating the fill properties to create the animation effect.\n\n\n### Types of Animation: One-by-one, Sync, and Random\n\nVivus offers several animation types to control how the SVG is animated:\n\n* **`oneByOne`:**  Animates each path element sequentially. This creates a drawing effect, where each part of the SVG is drawn one after the other.  The order of animation follows the order of the elements in the SVG file.\n\n* **`simultaneously`:** Animates all path elements concurrently.  This creates a more uniform animation effect, with all parts of the SVG animating at the same time.\n\n* **`random`:**  Animates each path element in a random order. This provides a more dynamic and less predictable animation effect.\n\n* **`delayed`:** Animates elements sequentially, but each element has a delay before starting its animation. This creates a wave-like animation effect.\n\n\n### The Vivus Object and its Properties\n\nThe core of Vivus is the `Vivus` object.  Creating a new `Vivus` instance initiates the animation. The constructor accepts several options to customize the animation:\n\n\n* **`target` (String or HTMLElement):**  The ID of the SVG element to animate, or the element itself. This is a required parameter.\n\n* **`type` (String, default: 'oneByOne'):** The animation type (`oneByOne`, `simultaneously`, `random`, `delayed`).\n\n* **`duration` (Number, default: 120):** The duration of the animation in frames (1 frame = 1/60th of a second).\n\n* **`start` (String, default: 'auto'):** When the animation should start (`auto`, `manual`, a specific time in milliseconds).  Setting it to `manual` requires manually starting the animation using the `start()` method.\n\n* **`delay` (Number, default: 0):**  Delay before the animation starts (in milliseconds).\n\n* **`forceRender` (Boolean, default: false):** Force a redraw of the SVG.  Useful for troubleshooting rendering issues.\n\n* **`onReady` (Function):** A callback function to be executed once the animation is ready to be started.\n\n* **`pathTimingFunction` (String, default: 'linear'):**  Specifies the timing function for individual path animations.\n\n* **`morphing` (Boolean, default: false):** Use morphing animation instead of stroke dash array.\n\n\n  These are just some of the key properties. Refer to the full documentation for a comprehensive list of options.\n\n\n### Event Handling\n\nVivus provides events that you can listen for to track the progress of the animation:\n\n* **`ready`:** Fired when the Vivus instance is ready.\n\n* **`start`:** Fired when the animation starts.\n\n* **`frame`:** Fired for every frame of the animation, providing the current progress.\n\n* **`end`:** Fired when the animation completes.\n\nTo handle these events, you use the `on` method:\n\n\n```javascript\nconst vivus = new Vivus('my-svg', {\n  type: 'oneByOne',\n  onReady: function(v){ console.log(\"Ready\") },\n  onEnter: function(v){ console.log(\"Entered\") },\n  onFrame: function(v){ console.log(\"Frame\") },\n  onFinish: function(v){ console.log(\"Finished\") }\n});\n```\n\nThis code example shows how to use the `onReady`,`onEnter`,`onFrame`, and `onFinish` events.  Replace `\"my-svg\"` with the ID of your SVG element.  Consult the Vivus documentation for a complete list of events.\n\n\n## Animation Types and Options\n\n### One-by-one Animation\n\nThe `oneByOne` animation type draws each path element of the SVG sequentially.  This creates a classic \"drawing\" effect, where elements are revealed one after another.  The order of animation follows the order of elements within the SVG file.  This is often the most visually appealing option for illustrations that tell a story or reveal elements progressively.  The timing of each element can be customized further using `pathTimingFunction`.\n\n### Sync Animation\n\nThe `simultaneously` animation type draws all path elements concurrently.  All parts of the SVG animate at the same time, completing their animation at the same rate.  This creates a more unified and less sequential animation, suitable for simpler SVGs or when a unified effect is desired. The `pathTimingFunction` still applies to individual path elements, affecting how their individual animation progresses within the overall simultaneous animation.\n\n### Random Animation\n\nThe `random` animation type draws each path element in a random order.  This creates a more chaotic and unpredictable animation effect, suitable for designs where a sense of surprise or dynamism is desired.  The timing of each element is still controlled by the `duration` parameter, but the order in which they animate is completely randomized.\n\n### Customizing Animation Parameters (duration, delay, etc.)\n\nSeveral parameters allow you to fine-tune the animation's behavior:\n\n* **`duration`:** Controls the overall animation duration in frames (1 frame = 1/60th of a second).  A higher value extends the animation's length, making it slower.\n\n* **`delay`:** Specifies a delay (in milliseconds) before the animation begins. This can be useful for coordinating animations with other elements on the page.\n\n* **`pathTimingFunction`:**  This property lets you specify the timing function for each path's animation using standard CSS timing functions (e.g., `linear`, `ease`, `ease-in-out`, `ease-in`, `ease-out`, `step-start`, `step-end`).  This controls the pacing of the individual element animations. For example, `ease-in-out` will make the animation start and end slowly, while `linear` will make it progress at a constant speed.\n\n* **`start`:** Controls when the animation begins:\n    * `'auto'`: The animation starts immediately.\n    * `'manual'`: The animation requires a manual start using the `vivus.start()` method.\n    *  A number (in milliseconds): Starts the animation after a specified delay.\n\nThese parameters are passed as options to the `Vivus` constructor.\n\n### Start and Stop Animation Methods\n\nThe `Vivus` object provides methods to control the animation's playback:\n\n* **`vivus.start()`:** Manually starts the animation if `start: 'manual'` was specified in the constructor options.\n\n* **`vivus.stop()`:** Stops the animation at its current state.\n\n\n### Controlling Animation Playback: Play, Pause, Reverse\n\nWhile Vivus doesn't directly offer explicit `play()`, `pause()`, and `reverse()` methods, you can achieve similar functionality by combining `start()`, `stop()`, and potentially manipulating the `stroke-dashoffset` property directly (although this is generally discouraged as it bypasses Vivus's internal animation management).  For pausing, you can use `stop()` to freeze the animation.  There isn't a built-in reverse function; achieving reverse animation would require creating a separate Vivus instance with reversed animation parameters or manually manipulating the SVG properties, which is more complex.  It is recommended to control the animation through `start()` and `stop()` and the options passed to the Vivus constructor to achieve the desired effects.\n\n\n## Advanced Techniques\n\n### Animating Multiple SVGs\n\nAnimating multiple SVGs involves creating a separate `Vivus` instance for each SVG element.  Each instance will have its own set of options and will control the animation of its corresponding SVG.  This allows for independent control over the timing and type of animation for each SVG on the page.  You can synchronize animations across multiple SVGs by using the `delay` parameter to carefully orchestrate their start times.\n\n\n```javascript\nconst vivus1 = new Vivus('svg1', {type: 'oneByOne', duration: 100});\nconst vivus2 = new Vivus('svg2', {type: 'simultaneously', duration: 150, delay: 1000}); //Starts after 1 second\n```\n\nThis example animates two SVGs, identified by the IDs `svg1` and `svg2`, with different animation types and durations. `svg2` starts animating 1 second after `svg1`.\n\n\n### Using Vivus with Different SVG Libraries\n\nVivus works with SVGs generated from various sources, including vector editing software (Adobe Illustrator, Inkscape) and libraries like Snap.svg or D3.js.  As long as the resulting SVG is valid and contains path elements, Vivus will animate it.  However, be aware that the complexity and structure of the SVG might affect animation performance.  Very large or complex SVGs may require optimization techniques.\n\n### Creating Custom Animation Paths\n\nWhile Vivus primarily animates existing paths within an SVG, you can create custom animation paths programmatically. This usually involves manipulating the SVG's DOM structure after the SVG is loaded. You would dynamically add new `<path>` elements or modify existing ones using JavaScript before initializing the `Vivus` instance. This grants advanced control over the animation flow.  However, this method requires a deeper understanding of SVG structure and manipulation in JavaScript.\n\n### Performance Optimization\n\nFor optimal performance, particularly with large or complex SVGs:\n\n* **Reduce the number of path elements:** Simplify your SVG designs where possible to minimize the number of paths Vivus needs to animate.\n* **Optimize SVG structure:** Well-organized SVGs with concise paths can significantly improve performance.\n* **Use appropriate animation type:** `simultaneously` animation may be faster than `oneByOne` for large SVGs.\n* **Minimize unnecessary DOM manipulation:** Avoid excessive changes to the SVG's DOM structure during animation.\n* **Consider using a smaller SVG:** If resolution allows, use a lower-resolution SVG for better performance.  The browser's rendering engine will have less work to do.\n* **Use a more efficient SVG library (if applicable):** For dynamic SVG generation, consider SVG libraries optimized for performance.\n\n\n### Troubleshooting Common Issues\n\n* **Animation not working:** Ensure your SVG is correctly loaded and accessible to Vivus. Double-check the target ID and the path to your SVG file. Confirm that the necessary JavaScript file is correctly included. Browser's developer tools can help identify JavaScript errors.\n\n* **Incorrect animation type:**  Verify you are using the correct animation type (`oneByOne`, `simultaneously`, `random`, `delayed`).\n\n* **Unexpected animation behavior:** Check the settings for `duration`, `delay`, and `pathTimingFunction` to ensure they match the desired animation.\n\n* **Performance issues:**  If you have performance problems, try simplifying your SVG, reducing the number of path elements, or optimizing the SVG structure. If still slow, profile your code to identify bottlenecks.\n\n* **Rendering issues:** Use the `forceRender` option to force a redraw of the SVG to overcome some rendering problems in certain browsers or situations.  If problems persist, check for browser compatibility issues.  The browser's developer tools are invaluable for tracking down such issues.\n\nRemember to consult the Vivus project's documentation and issue tracker for further assistance and reporting bugs.\n\n\n## Examples and Use Cases\n\n### Interactive Illustrations\n\nVivus excels at creating engaging interactive illustrations. By triggering animations on user interaction (e.g., hover, click), you can add dynamic elements to your designs.  This can be achieved by associating events with the animation start, such as a button click initiating the animation of an illustration.  This makes static images come alive and enhances the user experience.  The `start()` method becomes particularly useful in such interactive scenarios.\n\n### Data Visualization\n\nWhile not a primary focus, Vivus can be incorporated into data visualization projects.  For example, you can use it to animate the appearance of chart elements, highlighting data points as they're revealed, creating a more visually appealing representation of data.  The animation type (e.g., `oneByOne`) can be used to emphasize the sequential nature of data entry or highlight individual data points.  However, for complex data visualizations, dedicated charting libraries are often more suitable.\n\n### Loading Animations\n\nVivus can easily create visually appealing loading animations.  You can animate a simple SVG icon or graphic while data is being fetched. This provides a visual cue to the user that something is happening, improving the user experience.  The animation can be triggered after the loading process is complete or stopped as needed.\n\n### Creating Animated Icons\n\nVivus is particularly well-suited for creating animated icons. By animating simple SVG path elements, you can easily transform static icons into engaging animated versions. This adds a unique and interactive touch to the user interface.  The lightweight nature of Vivus makes it ideal for this use case.\n\n### Complex SVG Animation\n\nVivus can handle complex SVGs, but performance might be affected by the number of paths and the complexity of the SVG structure.  For extremely intricate animations, consider optimization techniques such as:\n\n* **Breaking down complex paths:** Splitting intricate paths into smaller, simpler paths can improve performance.\n\n* **Using SVG optimization tools:** Several tools can help optimize the SVG structure for better performance.\n\n* **Using a combination of animation techniques:** You can combine Vivus with other animation libraries or techniques (e.g., CSS animations) for more sophisticated animation effects.\n\n* **Lazy loading:**  If loading multiple complex SVGs at once is an issue, consider lazy loading them so that only the currently visible elements are animated.\n\nIn complex cases, profiling the animation performance with your browser's developer tools is crucial for identifying and addressing performance bottlenecks.  For very complex SVG animations, other animation libraries or custom JavaScript animation routines might be more efficient.\n\n\n## API Reference\n\n### Vivus Constructor Options\n\nThe `Vivus` constructor accepts several options to configure the animation:\n\n* **`target` (String | HTMLElement):**  (Required) The ID of the SVG element or the element itself to animate.\n\n* **`type` (String):** The animation type. Options include: `'oneByOne'`, `'simultaneously'`, `'random'`, `'delayed'`. Defaults to `'oneByOne'`.\n\n* **`duration` (Number):** The animation duration in frames (1 frame = 1/60th of a second). Defaults to 120.\n\n* **`start` (String | Number):** When the animation starts. Options include: `'auto'` (immediately), `'manual'` (requires manual start with `start()` method), or a number representing a delay in milliseconds. Defaults to `'auto'`.\n\n* **`delay` (Number):** The delay before the animation begins (in milliseconds). Defaults to 0.\n\n* **`forceRender` (Boolean):** Forces a redraw of the SVG. Useful for troubleshooting rendering issues. Defaults to `false`.\n\n* **`onReady` (Function):** Callback function executed when the animation is ready to start.\n\n* **`onEnter` (Function):** Callback function executed at the start of the animation.\n\n* **`onFrame` (Function):** Callback function executed every animation frame. The progress value is passed as an argument.\n\n* **`onFinish` (Function):** Callback function executed when the animation completes.\n\n* **`pathTimingFunction` (String):** Timing function for each path's animation (e.g., `'linear'`, `'ease'`, `'ease-in-out'`). Defaults to `'linear'`.\n\n* **`morphing` (Boolean):** Use morphing animation instead of stroke dash array. Defaults to `false`.\n\n\n### Methods (play, stop, reset, etc.)\n\nThe `Vivus` object exposes several methods to control animation:\n\n* **`start()`:** Manually starts the animation if `start: 'manual'` was used in the constructor.\n\n* **`stop()`:** Stops the animation at its current state.\n\n* **`reset()`:** Resets the animation to its initial state.\n\n* **`destroy()`:** Removes the Vivus instance and cleans up events.\n\n\n* **`getProgress()`:** Returns the current progress of the animation (0-1).\n\n* **`setProgress(progress)`:** Sets the animation progress directly to a specific value (0-1).\n\n\n\n### Events\n\nVivus triggers several events throughout its lifecycle:\n\n* **`ready`:** Fired when the Vivus instance is ready.\n\n* **`start`:** Fired when the animation begins.\n\n* **`frame`:** Fired for each animation frame.  Passes the current progress as an argument to the callback function.\n\n* **`end`:** Fired when the animation completes.\n\nEvents are handled using the `on` method:\n\n```javascript\nvivus.on('start', function() { /* ... */ });\nvivus.on('frame', function(progress) { /* ... */ });\nvivus.on('end', function() { /* ... */ });\n```\n\n\n### Properties\n\nThe `Vivus` object has several properties, accessible using the dot notation:\n\n* **`opts`:** The options object passed to the constructor.\n\n* **`frameLength`:** The duration of the animation in frames (same as the `duration` option).\n\n* **`duration`:** The duration of the animation in milliseconds.\n\n* **`currentFrame`:** The current frame of the animation.\n\n* **`totalFrame`:** The total number of frames in the animation.\n\n* **`isDrawing`:** Boolean indicating whether the animation is currently running.\n\n* **`isComplete`:** Boolean indicating whether the animation has completed.\n\nDirect manipulation of these properties is generally not recommended, and the provided methods are preferred for controlling animation behavior.  Modifying these properties directly might lead to unexpected behavior and may break internal synchronization of the animation process.\n\nNote:  The specific properties and methods available might vary slightly between versions. Always refer to the latest official documentation for the most accurate and up-to-date information.\n\n\n## Contributing to Vivus\n\nWe welcome contributions to Vivus!  Whether it's bug fixes, new features, or improvements to the documentation, your help is valuable.  Here's how you can contribute:\n\n### Setting up the Development Environment\n\n1. **Clone the repository:** Fork the Vivus repository on GitHub and clone your fork to your local machine:\n\n   ```bash\n   git clone git@github.com:YOUR_USERNAME/Vivus.git\n   cd Vivus\n   ```\n   Replace `YOUR_USERNAME` with your GitHub username.\n\n2. **Install dependencies:** Install the project dependencies using npm:\n\n   ```bash\n   npm install\n   ```\n\n3. **Run the development server:**  Start a development server to build and serve the project. The exact command might vary depending on the project's setup; check the project's `README` file for instructions.  It will typically involve a command like:\n\n   ```bash\n   npm run dev\n   ```\n\nThis will usually start a local development server, enabling you to test your changes.\n\n\n### Coding Style Guide\n\nAdhere to the existing coding style in the project.  Generally, this involves:\n\n* **Consistent indentation:** Use two spaces for indentation.\n* **Meaningful variable and function names:**  Use descriptive names that clearly communicate the purpose.\n* **Comments:** Add comments to explain complex logic or non-obvious code sections.\n* **ES6 JavaScript:** Use modern JavaScript syntax and features.\n\nRefer to the project's existing codebase for style conventions and examples.\n\n\n### Testing\n\nVivus likely uses a testing framework (e.g., Jest, Mocha).  Before submitting a pull request, ensure your changes are thoroughly tested.  The project's `README` file will usually contain instructions on running the tests:  Typically, this involves a command like:\n\n```bash\nnpm test\n```\n\n\nEnsure all existing tests pass and add new tests for any new features or bug fixes you've implemented.  Comprehensive testing helps guarantee code quality and prevent regressions.\n\n\n### Submitting Pull Requests\n\n1. **Create a new branch:** Create a new branch for your changes:\n\n   ```bash\n   git checkout -b feature/your-feature-name\n   ```\n\n2. **Commit your changes:** Commit your changes with clear and concise commit messages.\n\n3. **Push your branch:** Push your branch to your GitHub fork:\n\n   ```bash\n   git push origin feature/your-feature-name\n   ```\n\n4. **Create a pull request:** On GitHub, create a pull request from your branch to the main branch of the Vivus repository (usually `main` or `master`).  Provide a detailed description of your changes and address any comments from reviewers.\n\n5. **Address feedback:** Respond to any comments or suggestions from the maintainers, making necessary revisions and pushing updated commits to your branch.  Continue this iterative process until the pull request is approved and merged.\n\nRemember to follow the project's contribution guidelines, which might include specific requirements for code style, testing, and commit messages.  Always be respectful and collaborative in your interactions with the project maintainers and other contributors.\n\n","srcMarkdownNoYaml":"\n\n\n### What is Vivus?\n\nVivus is a lightweight JavaScript library that animates SVGs.  It allows you to bring your static SVG illustrations to life by animating their strokes or fills, creating engaging and visually appealing effects.  Whether you're drawing a simple icon or a complex illustration, Vivus provides a simple and intuitive way to add animation to your SVGs without requiring extensive animation knowledge. It supports various animation types and allows for significant customization.\n\n### Key Features and Benefits\n\n* **Simplicity:** Vivus offers a clean and easy-to-use API, making it accessible to developers of all skill levels.\n* **Lightweight:** The library is small and efficient, minimizing the impact on your website's performance.\n* **Multiple Animation Types:**  Choose from several animation types, including `oneByOne`, `simultaneously`, `random`, and `delayed`, to customize the animation style.\n* **Customizability:** Fine-tune the animation speed, delay, type, and other parameters to match your specific design requirements.\n* **SVG Support:** Works seamlessly with SVG files created using any vector graphics editor.\n* **Ease of Integration:**  Easily integrate Vivus into your existing web projects using a simple script inclusion.\n* **Cross-browser Compatibility:**  Vivus is designed to work across a wide range of modern web browsers.\n\n\n### Setting up Vivus: Installation and Dependencies\n\nVivus is available via npm and CDN.\n\n**Using npm:**\n\n1. Install Vivus using npm:\n   ```bash\n   npm install vivus\n   ```\n2. Import it into your JavaScript code:\n   ```javascript\n   import Vivus from 'vivus';\n   ```\n\n**Using a CDN:**\n\nInclude the Vivus JavaScript file in your HTML `<head>`:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/vivus@latest/dist/vivus.min.js\"></script>\n```\n\nVivus has no external dependencies beyond a standard JavaScript environment supporting the `Promise` object.  Older browsers might require a polyfill if `Promise` is not natively supported.\n\n### Basic Usage Example\n\nThis example animates an SVG using the `oneByOne` animation type:\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<title>Vivus Example</title>\n<script src=\"https://cdn.jsdelivr.net/npm/vivus@latest/dist/vivus.min.js\"></script>\n</head>\n<body>\n\n<svg id=\"my-svg\" width=\"200\" height=\"200\">\n  <path d=\"M100,100 L150,150 L100,150 Z\" fill=\"none\" stroke=\"black\" stroke-width=\"2\"/>\n</svg>\n\n<script>\n  new Vivus('my-svg', {type: 'oneByOne'});\n</script>\n\n</body>\n</html>\n```\n\nThis code will find the SVG with the ID `my-svg` and animate its path using the `oneByOne` animation type.  Replace the SVG content with your own, and experiment with different animation types and options outlined in the Vivus documentation for more advanced usage.\n\n\n## Core Concepts\n\n### Understanding SVG Animation\n\nVivus animates SVGs by manipulating the `stroke-dasharray` and `stroke-dashoffset` properties of SVG paths.  Initially, the `stroke-dasharray` property is set to a value that represents the total length of the path, effectively hiding the stroke. The `stroke-dashoffset` property is then animated, gradually reducing its value from the total path length to zero. This reveals the stroke, creating the animation effect.  Vivus handles this complex process automatically, allowing you to focus on the creative aspects of your animations.  For fill animations, a similar approach is used, manipulating the fill properties to create the animation effect.\n\n\n### Types of Animation: One-by-one, Sync, and Random\n\nVivus offers several animation types to control how the SVG is animated:\n\n* **`oneByOne`:**  Animates each path element sequentially. This creates a drawing effect, where each part of the SVG is drawn one after the other.  The order of animation follows the order of the elements in the SVG file.\n\n* **`simultaneously`:** Animates all path elements concurrently.  This creates a more uniform animation effect, with all parts of the SVG animating at the same time.\n\n* **`random`:**  Animates each path element in a random order. This provides a more dynamic and less predictable animation effect.\n\n* **`delayed`:** Animates elements sequentially, but each element has a delay before starting its animation. This creates a wave-like animation effect.\n\n\n### The Vivus Object and its Properties\n\nThe core of Vivus is the `Vivus` object.  Creating a new `Vivus` instance initiates the animation. The constructor accepts several options to customize the animation:\n\n\n* **`target` (String or HTMLElement):**  The ID of the SVG element to animate, or the element itself. This is a required parameter.\n\n* **`type` (String, default: 'oneByOne'):** The animation type (`oneByOne`, `simultaneously`, `random`, `delayed`).\n\n* **`duration` (Number, default: 120):** The duration of the animation in frames (1 frame = 1/60th of a second).\n\n* **`start` (String, default: 'auto'):** When the animation should start (`auto`, `manual`, a specific time in milliseconds).  Setting it to `manual` requires manually starting the animation using the `start()` method.\n\n* **`delay` (Number, default: 0):**  Delay before the animation starts (in milliseconds).\n\n* **`forceRender` (Boolean, default: false):** Force a redraw of the SVG.  Useful for troubleshooting rendering issues.\n\n* **`onReady` (Function):** A callback function to be executed once the animation is ready to be started.\n\n* **`pathTimingFunction` (String, default: 'linear'):**  Specifies the timing function for individual path animations.\n\n* **`morphing` (Boolean, default: false):** Use morphing animation instead of stroke dash array.\n\n\n  These are just some of the key properties. Refer to the full documentation for a comprehensive list of options.\n\n\n### Event Handling\n\nVivus provides events that you can listen for to track the progress of the animation:\n\n* **`ready`:** Fired when the Vivus instance is ready.\n\n* **`start`:** Fired when the animation starts.\n\n* **`frame`:** Fired for every frame of the animation, providing the current progress.\n\n* **`end`:** Fired when the animation completes.\n\nTo handle these events, you use the `on` method:\n\n\n```javascript\nconst vivus = new Vivus('my-svg', {\n  type: 'oneByOne',\n  onReady: function(v){ console.log(\"Ready\") },\n  onEnter: function(v){ console.log(\"Entered\") },\n  onFrame: function(v){ console.log(\"Frame\") },\n  onFinish: function(v){ console.log(\"Finished\") }\n});\n```\n\nThis code example shows how to use the `onReady`,`onEnter`,`onFrame`, and `onFinish` events.  Replace `\"my-svg\"` with the ID of your SVG element.  Consult the Vivus documentation for a complete list of events.\n\n\n## Animation Types and Options\n\n### One-by-one Animation\n\nThe `oneByOne` animation type draws each path element of the SVG sequentially.  This creates a classic \"drawing\" effect, where elements are revealed one after another.  The order of animation follows the order of elements within the SVG file.  This is often the most visually appealing option for illustrations that tell a story or reveal elements progressively.  The timing of each element can be customized further using `pathTimingFunction`.\n\n### Sync Animation\n\nThe `simultaneously` animation type draws all path elements concurrently.  All parts of the SVG animate at the same time, completing their animation at the same rate.  This creates a more unified and less sequential animation, suitable for simpler SVGs or when a unified effect is desired. The `pathTimingFunction` still applies to individual path elements, affecting how their individual animation progresses within the overall simultaneous animation.\n\n### Random Animation\n\nThe `random` animation type draws each path element in a random order.  This creates a more chaotic and unpredictable animation effect, suitable for designs where a sense of surprise or dynamism is desired.  The timing of each element is still controlled by the `duration` parameter, but the order in which they animate is completely randomized.\n\n### Customizing Animation Parameters (duration, delay, etc.)\n\nSeveral parameters allow you to fine-tune the animation's behavior:\n\n* **`duration`:** Controls the overall animation duration in frames (1 frame = 1/60th of a second).  A higher value extends the animation's length, making it slower.\n\n* **`delay`:** Specifies a delay (in milliseconds) before the animation begins. This can be useful for coordinating animations with other elements on the page.\n\n* **`pathTimingFunction`:**  This property lets you specify the timing function for each path's animation using standard CSS timing functions (e.g., `linear`, `ease`, `ease-in-out`, `ease-in`, `ease-out`, `step-start`, `step-end`).  This controls the pacing of the individual element animations. For example, `ease-in-out` will make the animation start and end slowly, while `linear` will make it progress at a constant speed.\n\n* **`start`:** Controls when the animation begins:\n    * `'auto'`: The animation starts immediately.\n    * `'manual'`: The animation requires a manual start using the `vivus.start()` method.\n    *  A number (in milliseconds): Starts the animation after a specified delay.\n\nThese parameters are passed as options to the `Vivus` constructor.\n\n### Start and Stop Animation Methods\n\nThe `Vivus` object provides methods to control the animation's playback:\n\n* **`vivus.start()`:** Manually starts the animation if `start: 'manual'` was specified in the constructor options.\n\n* **`vivus.stop()`:** Stops the animation at its current state.\n\n\n### Controlling Animation Playback: Play, Pause, Reverse\n\nWhile Vivus doesn't directly offer explicit `play()`, `pause()`, and `reverse()` methods, you can achieve similar functionality by combining `start()`, `stop()`, and potentially manipulating the `stroke-dashoffset` property directly (although this is generally discouraged as it bypasses Vivus's internal animation management).  For pausing, you can use `stop()` to freeze the animation.  There isn't a built-in reverse function; achieving reverse animation would require creating a separate Vivus instance with reversed animation parameters or manually manipulating the SVG properties, which is more complex.  It is recommended to control the animation through `start()` and `stop()` and the options passed to the Vivus constructor to achieve the desired effects.\n\n\n## Advanced Techniques\n\n### Animating Multiple SVGs\n\nAnimating multiple SVGs involves creating a separate `Vivus` instance for each SVG element.  Each instance will have its own set of options and will control the animation of its corresponding SVG.  This allows for independent control over the timing and type of animation for each SVG on the page.  You can synchronize animations across multiple SVGs by using the `delay` parameter to carefully orchestrate their start times.\n\n\n```javascript\nconst vivus1 = new Vivus('svg1', {type: 'oneByOne', duration: 100});\nconst vivus2 = new Vivus('svg2', {type: 'simultaneously', duration: 150, delay: 1000}); //Starts after 1 second\n```\n\nThis example animates two SVGs, identified by the IDs `svg1` and `svg2`, with different animation types and durations. `svg2` starts animating 1 second after `svg1`.\n\n\n### Using Vivus with Different SVG Libraries\n\nVivus works with SVGs generated from various sources, including vector editing software (Adobe Illustrator, Inkscape) and libraries like Snap.svg or D3.js.  As long as the resulting SVG is valid and contains path elements, Vivus will animate it.  However, be aware that the complexity and structure of the SVG might affect animation performance.  Very large or complex SVGs may require optimization techniques.\n\n### Creating Custom Animation Paths\n\nWhile Vivus primarily animates existing paths within an SVG, you can create custom animation paths programmatically. This usually involves manipulating the SVG's DOM structure after the SVG is loaded. You would dynamically add new `<path>` elements or modify existing ones using JavaScript before initializing the `Vivus` instance. This grants advanced control over the animation flow.  However, this method requires a deeper understanding of SVG structure and manipulation in JavaScript.\n\n### Performance Optimization\n\nFor optimal performance, particularly with large or complex SVGs:\n\n* **Reduce the number of path elements:** Simplify your SVG designs where possible to minimize the number of paths Vivus needs to animate.\n* **Optimize SVG structure:** Well-organized SVGs with concise paths can significantly improve performance.\n* **Use appropriate animation type:** `simultaneously` animation may be faster than `oneByOne` for large SVGs.\n* **Minimize unnecessary DOM manipulation:** Avoid excessive changes to the SVG's DOM structure during animation.\n* **Consider using a smaller SVG:** If resolution allows, use a lower-resolution SVG for better performance.  The browser's rendering engine will have less work to do.\n* **Use a more efficient SVG library (if applicable):** For dynamic SVG generation, consider SVG libraries optimized for performance.\n\n\n### Troubleshooting Common Issues\n\n* **Animation not working:** Ensure your SVG is correctly loaded and accessible to Vivus. Double-check the target ID and the path to your SVG file. Confirm that the necessary JavaScript file is correctly included. Browser's developer tools can help identify JavaScript errors.\n\n* **Incorrect animation type:**  Verify you are using the correct animation type (`oneByOne`, `simultaneously`, `random`, `delayed`).\n\n* **Unexpected animation behavior:** Check the settings for `duration`, `delay`, and `pathTimingFunction` to ensure they match the desired animation.\n\n* **Performance issues:**  If you have performance problems, try simplifying your SVG, reducing the number of path elements, or optimizing the SVG structure. If still slow, profile your code to identify bottlenecks.\n\n* **Rendering issues:** Use the `forceRender` option to force a redraw of the SVG to overcome some rendering problems in certain browsers or situations.  If problems persist, check for browser compatibility issues.  The browser's developer tools are invaluable for tracking down such issues.\n\nRemember to consult the Vivus project's documentation and issue tracker for further assistance and reporting bugs.\n\n\n## Examples and Use Cases\n\n### Interactive Illustrations\n\nVivus excels at creating engaging interactive illustrations. By triggering animations on user interaction (e.g., hover, click), you can add dynamic elements to your designs.  This can be achieved by associating events with the animation start, such as a button click initiating the animation of an illustration.  This makes static images come alive and enhances the user experience.  The `start()` method becomes particularly useful in such interactive scenarios.\n\n### Data Visualization\n\nWhile not a primary focus, Vivus can be incorporated into data visualization projects.  For example, you can use it to animate the appearance of chart elements, highlighting data points as they're revealed, creating a more visually appealing representation of data.  The animation type (e.g., `oneByOne`) can be used to emphasize the sequential nature of data entry or highlight individual data points.  However, for complex data visualizations, dedicated charting libraries are often more suitable.\n\n### Loading Animations\n\nVivus can easily create visually appealing loading animations.  You can animate a simple SVG icon or graphic while data is being fetched. This provides a visual cue to the user that something is happening, improving the user experience.  The animation can be triggered after the loading process is complete or stopped as needed.\n\n### Creating Animated Icons\n\nVivus is particularly well-suited for creating animated icons. By animating simple SVG path elements, you can easily transform static icons into engaging animated versions. This adds a unique and interactive touch to the user interface.  The lightweight nature of Vivus makes it ideal for this use case.\n\n### Complex SVG Animation\n\nVivus can handle complex SVGs, but performance might be affected by the number of paths and the complexity of the SVG structure.  For extremely intricate animations, consider optimization techniques such as:\n\n* **Breaking down complex paths:** Splitting intricate paths into smaller, simpler paths can improve performance.\n\n* **Using SVG optimization tools:** Several tools can help optimize the SVG structure for better performance.\n\n* **Using a combination of animation techniques:** You can combine Vivus with other animation libraries or techniques (e.g., CSS animations) for more sophisticated animation effects.\n\n* **Lazy loading:**  If loading multiple complex SVGs at once is an issue, consider lazy loading them so that only the currently visible elements are animated.\n\nIn complex cases, profiling the animation performance with your browser's developer tools is crucial for identifying and addressing performance bottlenecks.  For very complex SVG animations, other animation libraries or custom JavaScript animation routines might be more efficient.\n\n\n## API Reference\n\n### Vivus Constructor Options\n\nThe `Vivus` constructor accepts several options to configure the animation:\n\n* **`target` (String | HTMLElement):**  (Required) The ID of the SVG element or the element itself to animate.\n\n* **`type` (String):** The animation type. Options include: `'oneByOne'`, `'simultaneously'`, `'random'`, `'delayed'`. Defaults to `'oneByOne'`.\n\n* **`duration` (Number):** The animation duration in frames (1 frame = 1/60th of a second). Defaults to 120.\n\n* **`start` (String | Number):** When the animation starts. Options include: `'auto'` (immediately), `'manual'` (requires manual start with `start()` method), or a number representing a delay in milliseconds. Defaults to `'auto'`.\n\n* **`delay` (Number):** The delay before the animation begins (in milliseconds). Defaults to 0.\n\n* **`forceRender` (Boolean):** Forces a redraw of the SVG. Useful for troubleshooting rendering issues. Defaults to `false`.\n\n* **`onReady` (Function):** Callback function executed when the animation is ready to start.\n\n* **`onEnter` (Function):** Callback function executed at the start of the animation.\n\n* **`onFrame` (Function):** Callback function executed every animation frame. The progress value is passed as an argument.\n\n* **`onFinish` (Function):** Callback function executed when the animation completes.\n\n* **`pathTimingFunction` (String):** Timing function for each path's animation (e.g., `'linear'`, `'ease'`, `'ease-in-out'`). Defaults to `'linear'`.\n\n* **`morphing` (Boolean):** Use morphing animation instead of stroke dash array. Defaults to `false`.\n\n\n### Methods (play, stop, reset, etc.)\n\nThe `Vivus` object exposes several methods to control animation:\n\n* **`start()`:** Manually starts the animation if `start: 'manual'` was used in the constructor.\n\n* **`stop()`:** Stops the animation at its current state.\n\n* **`reset()`:** Resets the animation to its initial state.\n\n* **`destroy()`:** Removes the Vivus instance and cleans up events.\n\n\n* **`getProgress()`:** Returns the current progress of the animation (0-1).\n\n* **`setProgress(progress)`:** Sets the animation progress directly to a specific value (0-1).\n\n\n\n### Events\n\nVivus triggers several events throughout its lifecycle:\n\n* **`ready`:** Fired when the Vivus instance is ready.\n\n* **`start`:** Fired when the animation begins.\n\n* **`frame`:** Fired for each animation frame.  Passes the current progress as an argument to the callback function.\n\n* **`end`:** Fired when the animation completes.\n\nEvents are handled using the `on` method:\n\n```javascript\nvivus.on('start', function() { /* ... */ });\nvivus.on('frame', function(progress) { /* ... */ });\nvivus.on('end', function() { /* ... */ });\n```\n\n\n### Properties\n\nThe `Vivus` object has several properties, accessible using the dot notation:\n\n* **`opts`:** The options object passed to the constructor.\n\n* **`frameLength`:** The duration of the animation in frames (same as the `duration` option).\n\n* **`duration`:** The duration of the animation in milliseconds.\n\n* **`currentFrame`:** The current frame of the animation.\n\n* **`totalFrame`:** The total number of frames in the animation.\n\n* **`isDrawing`:** Boolean indicating whether the animation is currently running.\n\n* **`isComplete`:** Boolean indicating whether the animation has completed.\n\nDirect manipulation of these properties is generally not recommended, and the provided methods are preferred for controlling animation behavior.  Modifying these properties directly might lead to unexpected behavior and may break internal synchronization of the animation process.\n\nNote:  The specific properties and methods available might vary slightly between versions. Always refer to the latest official documentation for the most accurate and up-to-date information.\n\n\n## Contributing to Vivus\n\nWe welcome contributions to Vivus!  Whether it's bug fixes, new features, or improvements to the documentation, your help is valuable.  Here's how you can contribute:\n\n### Setting up the Development Environment\n\n1. **Clone the repository:** Fork the Vivus repository on GitHub and clone your fork to your local machine:\n\n   ```bash\n   git clone git@github.com:YOUR_USERNAME/Vivus.git\n   cd Vivus\n   ```\n   Replace `YOUR_USERNAME` with your GitHub username.\n\n2. **Install dependencies:** Install the project dependencies using npm:\n\n   ```bash\n   npm install\n   ```\n\n3. **Run the development server:**  Start a development server to build and serve the project. The exact command might vary depending on the project's setup; check the project's `README` file for instructions.  It will typically involve a command like:\n\n   ```bash\n   npm run dev\n   ```\n\nThis will usually start a local development server, enabling you to test your changes.\n\n\n### Coding Style Guide\n\nAdhere to the existing coding style in the project.  Generally, this involves:\n\n* **Consistent indentation:** Use two spaces for indentation.\n* **Meaningful variable and function names:**  Use descriptive names that clearly communicate the purpose.\n* **Comments:** Add comments to explain complex logic or non-obvious code sections.\n* **ES6 JavaScript:** Use modern JavaScript syntax and features.\n\nRefer to the project's existing codebase for style conventions and examples.\n\n\n### Testing\n\nVivus likely uses a testing framework (e.g., Jest, Mocha).  Before submitting a pull request, ensure your changes are thoroughly tested.  The project's `README` file will usually contain instructions on running the tests:  Typically, this involves a command like:\n\n```bash\nnpm test\n```\n\n\nEnsure all existing tests pass and add new tests for any new features or bug fixes you've implemented.  Comprehensive testing helps guarantee code quality and prevent regressions.\n\n\n### Submitting Pull Requests\n\n1. **Create a new branch:** Create a new branch for your changes:\n\n   ```bash\n   git checkout -b feature/your-feature-name\n   ```\n\n2. **Commit your changes:** Commit your changes with clear and concise commit messages.\n\n3. **Push your branch:** Push your branch to your GitHub fork:\n\n   ```bash\n   git push origin feature/your-feature-name\n   ```\n\n4. **Create a pull request:** On GitHub, create a pull request from your branch to the main branch of the Vivus repository (usually `main` or `master`).  Provide a detailed description of your changes and address any comments from reviewers.\n\n5. **Address feedback:** Respond to any comments or suggestions from the maintainers, making necessary revisions and pushing updated commits to your branch.  Continue this iterative process until the pull request is approved and merged.\n\nRemember to follow the project's contribution guidelines, which might include specific requirements for code style, testing, and commit messages.  Always be respectful and collaborative in your interactions with the project maintainers and other contributors.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["../../styles.css"],"html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"},"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"},"../../footer.html"],"output-file":"vivus.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"license":"MIT","author-meta":"Muthukrishnan","title":"Vivus - Documentation","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}