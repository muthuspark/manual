{"title":"css3-mediaqueries.js - Documentation","markdown":{"yaml":{"title":"css3-mediaqueries.js - Documentation","categories":["JavaScript Libraries and Functions"]},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n### What is css3-mediaqueries.js?\n\n`css3-mediaqueries.js` is a JavaScript library that provides a consistent and reliable way to handle CSS3 media queries across different browsers and devices.  It allows developers to detect and respond to changes in the browser viewport, device orientation, and other media features, even in browsers that don't fully support native CSS3 media query functionality.  Essentially, it acts as a polyfill, bridging the gap between modern media query support and older browsers.  The library offers a simple API to register callbacks that are executed when specific media queries match or unmatch.\n\n### Why use css3-mediaqueries.js?\n\nUsing `css3-mediaqueries.js` offers several key advantages:\n\n* **Cross-browser compatibility:** Ensures consistent behavior across a wide range of browsers, including older ones that lack full CSS3 media query support. This guarantees your responsive design works as intended on a broader audience.\n* **Simplified implementation:** Provides a clean and easy-to-use JavaScript API, simplifying the process of handling media query events compared to writing custom browser-specific solutions.\n* **Improved performance:**  While it adds a layer of JavaScript, efficient implementation in the library minimizes performance overhead.  It avoids unnecessary recalculations and only triggers events when necessary.\n* **Maintainability:**  Using a dedicated library reduces code complexity and makes maintenance significantly easier, especially in larger projects.\n\n### Browser Compatibility\n\nWhile `css3-mediaqueries.js` aims to provide backward compatibility, it's crucial to understand that its primary purpose is to *enhance* support, not replace it completely.  Browsers with robust native CSS3 media query support will leverage those features preferentially; the library will only step in where native support is lacking or incomplete.  Therefore, it's generally recommended to style your pages with CSS media queries as the primary method, and use `css3-mediaqueries.js` to handle the remaining edge cases for older browsers.  The library itself is designed to be lightweight and should work in most modern and legacy browsers.  However, exceptionally old or uncommon browsers may still experience issues.\n\n### Installation and Setup\n\nThe most common method of installation is via a package manager like npm or yarn:\n\n```bash\nnpm install css3-mediaqueries\n# or\nyarn add css3-mediaqueries\n```\n\nAfter installation, you can include it in your project using a `<script>` tag:\n\n```html\n<script src=\"node_modules/css3-mediaqueries/css3-mediaqueries.js\"></script>  \n```\n\nAlternatively, if you downloaded the library directly, include the appropriate `.js` file path.  After including the script, you can utilize the library's API to register and manage your media queries (refer to the API documentation for detailed usage instructions).  Remember to place the `<script>` tag either at the end of the `<body>` or within a `DOMContentLoaded` event listener to ensure the DOM is fully loaded before the library is used.\n\n\n## Core Functionality\n\n### Matching Media Queries\n\n`css3-mediaqueries.js` allows you to check if a given media query matches the current environment.  This is done using the `matchMedia` function, which takes a media query string as an argument and returns a `MediaQueryList` object.  This object has a `matches` property that's a boolean indicating whether the query currently matches.  Here's an example:\n\n```javascript\nconst query = window.matchMedia('(min-width: 768px)');\nif (query.matches) {\n  // Apply styles for larger screens\n  console.log(\"Large screen detected!\");\n} else {\n  // Apply styles for smaller screens\n  console.log(\"Small screen detected!\");\n}\n\n// Listen for changes\nquery.addListener(function(mql) {\n  if (mql.matches) {\n    // Styles to be applied when query matches.\n    console.log('Screen size changed to large.');\n  } else {\n    // Styles to be applied when query doesn't match\n    console.log('Screen size changed to small.');\n  }\n});\n```\n\nNote that while the example shows using `window.matchMedia`, `css3-mediaqueries.js` enhances this functionality for older browsers.\n\n### Adding and Removing Styles\n\nThe library doesn't directly handle adding and removing CSS styles. It provides the mechanism to detect when a media query matches or unmatches. You'll need to use standard DOM manipulation techniques (e.g., `classList.add`, `classList.remove`, or direct style manipulation) to apply and remove styles based on the results of media query matching.\n\n\n```javascript\nconst query = window.matchMedia('(max-width: 600px)');\n\nfunction handleQueryChange(mql) {\n  const element = document.getElementById('myElement');\n  if (mql.matches) {\n    element.classList.add('small-screen');\n    element.classList.remove('large-screen');\n  } else {\n    element.classList.remove('small-screen');\n    element.classList.add('large-screen');\n  }\n}\n\nquery.addListener(handleQueryChange);\nhandleQueryChange(query); //Initial check\n```\n\nThis example adds/removes classes based on the match; you'd define the CSS rules for `.small-screen` and `.large-screen` separately.\n\n### Event Handling\n\nThe primary mechanism for handling media query changes is through the `addListener` method of the `MediaQueryList` object.  This method takes a callback function as an argument.  The callback is executed whenever the match state of the media query changes (e.g., the user resizes the browser window, changes device orientation).  The callback receives a `MediaQueryList` object as its argument, which contains the updated `matches` property.  The `removeListener` method is used to remove previously added listeners.\n\n\n### Working with Different Media Types\n\n`css3-mediaqueries.js` supports all standard CSS media types and features. You can use any valid media query string in the `matchMedia` function, including those targeting print, screen, speech, etc., and those incorporating features like `min-width`, `max-height`, `orientation`, `resolution`, and more.  The library ensures consistent handling across browsers, allowing seamless interaction with different media types.  For example:\n\n```javascript\nconst printQuery = window.matchMedia('print');\nif (printQuery.matches) {\n  // Apply styles specifically for print\n}\n```\n\n\n### Handling Multiple Queries\n\nYou can use multiple `matchMedia` calls to handle several media queries simultaneously. Each call will return a separate `MediaQueryList` object, allowing independent event handling and state management for each query.  Remember to add appropriate listeners for each query to respond to changes correctly.\n\n```javascript\nconst query1 = window.matchMedia('(min-width: 768px)');\nconst query2 = window.matchMedia('(orientation: landscape)');\n\nquery1.addListener(handleQuery1Change);\nquery2.addListener(handleQuery2Change);\n\nfunction handleQuery1Change(mql){\n    //handle changes for query1\n}\n\nfunction handleQuery2Change(mql){\n    //handle changes for query2\n}\n\n```\nThis allows for complex responsive design scenarios where behavior depends on multiple environmental factors.\n\n\n## Advanced Usage\n\n### Custom Query Functions\n\nWhile `css3-mediaqueries.js` primarily uses standard media query strings, you can enhance its functionality by creating custom query functions that perform more complex checks or integrate with other parts of your application.  These custom functions would internally use the `matchMedia` functionality of the library or its underlying browser support to determine the match state. For instance, you might create a function that checks for both screen size and device type:\n\n\n```javascript\nfunction isLargeTabletLandscape() {\n  const widthQuery = window.matchMedia('(min-width: 1024px)');\n  const orientationQuery = window.matchMedia('(orientation: landscape)');\n  return widthQuery.matches && orientationQuery.matches;\n}\n\n\nif (isLargeTabletLandscape()) {\n  // Apply styles for large tablet in landscape mode.\n}\n```\n\nThis function leverages the core `matchMedia` functionality but encapsulates a more specific condition.\n\n\n### Asynchronous Operations\n\nMedia query matching is typically a synchronous operation; however, if you need to perform asynchronous tasks based on media query changes, you should structure your code appropriately using Promises or async/await to ensure proper sequencing.  For example:\n\n```javascript\nasync function handleQueryChange(mql) {\n    if (mql.matches) {\n        try{\n            const data = await fetch('/api/data'); // Example asynchronous operation\n            // Process the data\n        } catch(error) {\n            console.error(\"Error fetching data:\", error);\n        }\n    } else {\n        // Handle the case where the query doesn't match.\n    }\n}\n\nconst query = window.matchMedia('(min-width: 1200px)');\nquery.addListener(handleQueryChange);\n```\n\n\n### Integration with Other Libraries\n\n`css3-mediaqueries.js` is designed to work alongside other JavaScript libraries.  There are no inherent conflicts.  Ensure your inclusion order is correct (avoiding conflicts if other libraries modify the `window.matchMedia` function), and you can use the results from this library to inform the behavior of other parts of your application.  For example, you could use this library to detect screen size and then dynamically load components from a framework like React or Vue based on the media query results.\n\n### Performance Optimization\n\nFor optimal performance:\n\n* **Minimize listener usage:** Don't add unnecessary listeners.  Only attach listeners to the queries that directly affect your application's behavior.\n* **Efficient callbacks:** Keep your callback functions concise and performant. Avoid computationally intensive tasks within the listener.  If necessary, defer heavy processing to a separate function.\n* **Debouncing/throttling:** If rapid changes (like during rapid resizing) trigger your callbacks, consider implementing debouncing or throttling techniques to reduce the frequency of updates. This will prevent unnecessary DOM manipulations or other potentially expensive operations.\n\n### Debugging and Troubleshooting\n\nIf you encounter problems:\n\n* **Browser console:** Check your browser's developer console for errors or warnings.  `css3-mediaqueries.js` itself is relatively simple and unlikely to throw many errors, but errors in your custom code using the library will be visible here.\n* **Media query validation:** Verify your media query strings for syntax errors.  Use browser developer tools to inspect whether the queries are actually being matched as you intend.\n* **Testing across browsers:**  Test your implementation in multiple browsers to ensure consistent behavior.  Discrepancies might indicate issues with browser-specific quirks that are not fully addressed by the polyfill.\n* **Simplified test cases:** If debugging complex interactions, try creating simplified test cases to isolate potential problems.  Start with a minimal example using a single media query to pinpoint the source of any issues.\n\nRemember to consult the library's source code or any associated unit tests for additional troubleshooting information.\n\n\n## API Reference\n\nThis section details the API available within `css3-mediaqueries.js`.  Note that the exact API may vary slightly depending on the version of the library; always refer to the latest documentation for the most accurate information.  The examples below assume you've included the library in your project and have access to the `matchMedia` function.\n\n### Constructor Options\n\nThe `matchMedia` function, which is the core of the library, doesn't directly have constructor options in the same way a class might.  The options are implicitly provided through the media query string itself.  The `matchMedia` function accepts a single argument:\n\n* **`mediaQueryString` (string):**  A valid CSS media query string. This string defines the conditions that must be met for the query to match. This is where you specify options like `min-width`, `max-height`, `orientation`, etc.  Any valid CSS media query string is accepted.\n\n```javascript\nconst query = window.matchMedia('(min-width: 768px) and (orientation: landscape)'); //Example\n```\n\n### `addListener()` Method\n\nThe `addListener()` method attaches a callback function to a `MediaQueryList` object. This callback function will be executed whenever the match state of the media query changes.\n\n* **`listener` (function):**  A callback function that takes a single argument: a `MediaQueryList` object representing the updated state of the media query.  The `MediaQueryList` object has a `matches` property (boolean) indicating whether the query currently matches.\n\n```javascript\nconst query = window.matchMedia('(min-width: 500px)');\nquery.addListener(function(mql) {\n  if (mql.matches) {\n    console.log('Media query now matches!');\n  } else {\n    console.log('Media query no longer matches.');\n  }\n});\n```\n\n### `removeListener()` Method\n\nThe `removeListener()` method removes a previously added listener from a `MediaQueryList` object.  This is crucial for preventing memory leaks or unwanted behavior when a listener is no longer needed.\n\n* **`listener` (function):** The callback function that was previously added using `addListener()`.\n\n```javascript\nconst query = window.matchMedia('(min-width: 500px)');\nconst myListener = function(mql) { /* ... */ };\nquery.addListener(myListener);\n// ... later, when you no longer need the listener ...\nquery.removeListener(myListener);\n```\n\n### `matches` Property\n\nThe `matches` property of the `MediaQueryList` object is a boolean that indicates whether the media query currently matches the browser's environment.\n\n```javascript\nconst query = window.matchMedia('(max-width: 600px)');\nconsole.log(query.matches); // true or false\n```\n\n\n### `getMatchedStyles()` Method\n\nThis method is **not** part of the standard `MediaQueryList` object.  The library itself doesn't inherently provide a method to directly fetch applied styles based on media query matches. Styles are applied through standard CSS rules using the information provided by the `matches` property. The developer needs to manage style changes manually based on the `matches` state.\n\n\n### `destroy()` Method\n\nThere is no inherent `destroy()` method within the `css3-mediaqueries.js` API or the standard `MediaQueryList` object.  To cleanup, simply remove any event listeners using `removeListener()`.  The library's resources are managed automatically by the browser's garbage collection once they are no longer referenced.  This implies that once there are no more references to a `MediaQueryList` object and its associated listeners, the browser will reclaim the memory.\n\n\n\n\n## Examples\n\nThese examples demonstrate how to use `css3-mediaqueries.js` in various scenarios. Remember to include the library in your HTML file before using these code snippets.\n\n### Basic Media Query Matching\n\nThis example shows how to detect if the screen width is greater than 768 pixels and apply different styles accordingly.\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<title>Basic Media Query</title>\n<style>\n.large-screen {\n  font-size: 24px;\n}\n.small-screen {\n  font-size: 16px;\n}\n</style>\n<script src=\"css3-mediaqueries.js\"></script> </head>\n<body>\n\n<p id=\"myText\">This is some text.</p>\n\n<script>\n  const query = window.matchMedia('(min-width: 768px)');\n\n  function handleQueryChange(mql) {\n    const textElement = document.getElementById('myText');\n    if (mql.matches) {\n      textElement.classList.add('large-screen');\n      textElement.classList.remove('small-screen');\n    } else {\n      textElement.classList.add('small-screen');\n      textElement.classList.remove('large-screen');\n    }\n  }\n\n  query.addListener(handleQueryChange);\n  handleQueryChange(query); // Initial check\n</script>\n\n</body>\n</html>\n```\n\n### Responsive Image Handling\n\nThis example demonstrates how to dynamically switch between different images based on screen width.\n\n```javascript\nconst query = window.matchMedia('(max-width: 600px)');\nconst img = document.getElementById('myImage');\nconst smallImg = 'small.jpg';\nconst largeImg = 'large.jpg';\n\nfunction handleImageChange(mql) {\n  img.src = mql.matches ? smallImg : largeImg;\n}\n\nquery.addListener(handleImageChange);\nhandleImageChange(query); //Initial check\n\n```\n\nRemember to replace  `'small.jpg'` and `'large.jpg'` with the actual paths to your images and to include the image element with the id `myImage` in your HTML.\n\n\n### Dynamic Styling Based on Device Orientation\n\nThis example changes the background color based on whether the device is in portrait or landscape mode.\n\n```javascript\nconst query = window.matchMedia('(orientation: landscape)');\nconst body = document.body;\n\nfunction handleOrientationChange(mql) {\n  body.style.backgroundColor = mql.matches ? 'lightblue' : 'lightcoral';\n}\n\nquery.addListener(handleOrientationChange);\nhandleOrientationChange(query); //Initial check\n```\n\n\n### Complex Media Query Scenarios\n\nThis example combines multiple media queries to apply different styles based on screen width and resolution.\n\n```javascript\nconst query1 = window.matchMedia('(min-width: 1024px)');\nconst query2 = window.matchMedia('(min-resolution: 2dppx)');\nconst element = document.getElementById('myElement');\n\nfunction handleQueryChanges() {\n  if (query1.matches && query2.matches) {\n    element.classList.add('high-res-large');\n    element.classList.remove('low-res-large', 'high-res-small', 'low-res-small');\n  } else if (query1.matches) {\n    element.classList.add('low-res-large');\n    element.classList.remove('high-res-large', 'high-res-small', 'low-res-small');\n  } else if (query2.matches) {\n    element.classList.add('high-res-small');\n    element.classList.remove('high-res-large', 'low-res-large', 'low-res-small');\n  } else {\n    element.classList.add('low-res-small');\n    element.classList.remove('high-res-large', 'low-res-large', 'high-res-small');\n  }\n}\n\n\nquery1.addListener(handleQueryChanges);\nquery2.addListener(handleQueryChanges);\nhandleQueryChanges(); //Initial check\n\n```\n\nRemember to define the CSS classes (`high-res-large`, `low-res-large`, etc.) in your stylesheet and include an element with the ID `myElement` in your HTML.  This demonstrates a more sophisticated use case where different styles are applied based on a combination of multiple media query conditions.  Remember that the order of conditionals within the `handleQueryChanges` function determines which styles are applied if multiple queries match.\n\n\n## Contributing\n\nWe welcome contributions to `css3-mediaqueries.js`!  Whether you're fixing bugs, adding features, or improving documentation, your help is valuable.  Please follow these guidelines to ensure a smooth and efficient contribution process.\n\n### Coding Style Guidelines\n\nMaintain consistency with the existing codebase.  Generally, follow these guidelines:\n\n* **Indentation:** Use 2 spaces for indentation.\n* **Line length:** Keep lines under 80 characters.\n* **Naming conventions:** Use camelCase for variables and functions.\n* **Comments:**  Write clear and concise comments to explain complex logic or non-obvious code sections.\n* **Semicolons:** Use semicolons consistently to terminate statements.\n\n\nBefore submitting a pull request, ensure your code adheres to these guidelines.  You can use a linter (e.g., ESLint) to automatically check for style violations.\n\n### Testing Procedures\n\nThorough testing is crucial.  Before submitting any code changes, run the existing test suite to ensure your modifications don't introduce regressions.  The test suite likely uses a testing framework (e.g., Jest, Mocha) and may involve unit tests to check individual functions and integration tests to verify that different parts of the library work together correctly.  The project should have clear instructions on how to run the tests (often in a `README.md` file).  If adding new features or fixing bugs, write new tests to cover the changes you've made.  Aim for high test coverage.\n\n### Submitting Pull Requests\n\n1. **Fork the repository:** Create a fork of the `css3-mediaqueries.js` repository on GitHub.\n2. **Create a branch:** Create a new branch for your changes. Use descriptive branch names (e.g., `fix-bug-123`, `feature-new-query-type`).\n3. **Make your changes:** Implement your changes, following the coding style guidelines and writing tests.\n4. **Commit your changes:** Commit your changes with clear and concise commit messages.  Explain what you've changed and why.\n5. **Push your branch:** Push your branch to your forked repository.\n6. **Create a pull request:** Create a pull request from your branch to the main branch of the original repository.  Provide a detailed description of your changes and address any comments or suggestions from the maintainers.\n\nYour pull request will be reviewed by the project maintainers.  Be prepared to address any feedback or make necessary revisions.\n\n\n### Reporting Bugs\n\nIf you discover a bug in `css3-mediaqueries.js`, please report it by creating a new issue on the GitHub repository.  Provide the following information:\n\n* **Clear title:** Summarize the issue in the title.\n* **Detailed description:** Describe the bug clearly and concisely.  Include steps to reproduce the problem and any relevant error messages.\n* **Browser and version:** Specify the browser and version you're using.\n* **Operating system:** Indicate the operating system you're using.\n* **Library version:** Specify the version of `css3-mediaqueries.js` you are using.\n* **Code snippet:** If possible, include a minimal, reproducible code snippet that demonstrates the bug.\n\n\nThe more information you provide, the easier it will be to diagnose and fix the bug.  You can also attach screenshots or screen recordings if that helps clarify the issue.\n\n","srcMarkdownNoYaml":"\n## Introduction\n\n### What is css3-mediaqueries.js?\n\n`css3-mediaqueries.js` is a JavaScript library that provides a consistent and reliable way to handle CSS3 media queries across different browsers and devices.  It allows developers to detect and respond to changes in the browser viewport, device orientation, and other media features, even in browsers that don't fully support native CSS3 media query functionality.  Essentially, it acts as a polyfill, bridging the gap between modern media query support and older browsers.  The library offers a simple API to register callbacks that are executed when specific media queries match or unmatch.\n\n### Why use css3-mediaqueries.js?\n\nUsing `css3-mediaqueries.js` offers several key advantages:\n\n* **Cross-browser compatibility:** Ensures consistent behavior across a wide range of browsers, including older ones that lack full CSS3 media query support. This guarantees your responsive design works as intended on a broader audience.\n* **Simplified implementation:** Provides a clean and easy-to-use JavaScript API, simplifying the process of handling media query events compared to writing custom browser-specific solutions.\n* **Improved performance:**  While it adds a layer of JavaScript, efficient implementation in the library minimizes performance overhead.  It avoids unnecessary recalculations and only triggers events when necessary.\n* **Maintainability:**  Using a dedicated library reduces code complexity and makes maintenance significantly easier, especially in larger projects.\n\n### Browser Compatibility\n\nWhile `css3-mediaqueries.js` aims to provide backward compatibility, it's crucial to understand that its primary purpose is to *enhance* support, not replace it completely.  Browsers with robust native CSS3 media query support will leverage those features preferentially; the library will only step in where native support is lacking or incomplete.  Therefore, it's generally recommended to style your pages with CSS media queries as the primary method, and use `css3-mediaqueries.js` to handle the remaining edge cases for older browsers.  The library itself is designed to be lightweight and should work in most modern and legacy browsers.  However, exceptionally old or uncommon browsers may still experience issues.\n\n### Installation and Setup\n\nThe most common method of installation is via a package manager like npm or yarn:\n\n```bash\nnpm install css3-mediaqueries\n# or\nyarn add css3-mediaqueries\n```\n\nAfter installation, you can include it in your project using a `<script>` tag:\n\n```html\n<script src=\"node_modules/css3-mediaqueries/css3-mediaqueries.js\"></script>  \n```\n\nAlternatively, if you downloaded the library directly, include the appropriate `.js` file path.  After including the script, you can utilize the library's API to register and manage your media queries (refer to the API documentation for detailed usage instructions).  Remember to place the `<script>` tag either at the end of the `<body>` or within a `DOMContentLoaded` event listener to ensure the DOM is fully loaded before the library is used.\n\n\n## Core Functionality\n\n### Matching Media Queries\n\n`css3-mediaqueries.js` allows you to check if a given media query matches the current environment.  This is done using the `matchMedia` function, which takes a media query string as an argument and returns a `MediaQueryList` object.  This object has a `matches` property that's a boolean indicating whether the query currently matches.  Here's an example:\n\n```javascript\nconst query = window.matchMedia('(min-width: 768px)');\nif (query.matches) {\n  // Apply styles for larger screens\n  console.log(\"Large screen detected!\");\n} else {\n  // Apply styles for smaller screens\n  console.log(\"Small screen detected!\");\n}\n\n// Listen for changes\nquery.addListener(function(mql) {\n  if (mql.matches) {\n    // Styles to be applied when query matches.\n    console.log('Screen size changed to large.');\n  } else {\n    // Styles to be applied when query doesn't match\n    console.log('Screen size changed to small.');\n  }\n});\n```\n\nNote that while the example shows using `window.matchMedia`, `css3-mediaqueries.js` enhances this functionality for older browsers.\n\n### Adding and Removing Styles\n\nThe library doesn't directly handle adding and removing CSS styles. It provides the mechanism to detect when a media query matches or unmatches. You'll need to use standard DOM manipulation techniques (e.g., `classList.add`, `classList.remove`, or direct style manipulation) to apply and remove styles based on the results of media query matching.\n\n\n```javascript\nconst query = window.matchMedia('(max-width: 600px)');\n\nfunction handleQueryChange(mql) {\n  const element = document.getElementById('myElement');\n  if (mql.matches) {\n    element.classList.add('small-screen');\n    element.classList.remove('large-screen');\n  } else {\n    element.classList.remove('small-screen');\n    element.classList.add('large-screen');\n  }\n}\n\nquery.addListener(handleQueryChange);\nhandleQueryChange(query); //Initial check\n```\n\nThis example adds/removes classes based on the match; you'd define the CSS rules for `.small-screen` and `.large-screen` separately.\n\n### Event Handling\n\nThe primary mechanism for handling media query changes is through the `addListener` method of the `MediaQueryList` object.  This method takes a callback function as an argument.  The callback is executed whenever the match state of the media query changes (e.g., the user resizes the browser window, changes device orientation).  The callback receives a `MediaQueryList` object as its argument, which contains the updated `matches` property.  The `removeListener` method is used to remove previously added listeners.\n\n\n### Working with Different Media Types\n\n`css3-mediaqueries.js` supports all standard CSS media types and features. You can use any valid media query string in the `matchMedia` function, including those targeting print, screen, speech, etc., and those incorporating features like `min-width`, `max-height`, `orientation`, `resolution`, and more.  The library ensures consistent handling across browsers, allowing seamless interaction with different media types.  For example:\n\n```javascript\nconst printQuery = window.matchMedia('print');\nif (printQuery.matches) {\n  // Apply styles specifically for print\n}\n```\n\n\n### Handling Multiple Queries\n\nYou can use multiple `matchMedia` calls to handle several media queries simultaneously. Each call will return a separate `MediaQueryList` object, allowing independent event handling and state management for each query.  Remember to add appropriate listeners for each query to respond to changes correctly.\n\n```javascript\nconst query1 = window.matchMedia('(min-width: 768px)');\nconst query2 = window.matchMedia('(orientation: landscape)');\n\nquery1.addListener(handleQuery1Change);\nquery2.addListener(handleQuery2Change);\n\nfunction handleQuery1Change(mql){\n    //handle changes for query1\n}\n\nfunction handleQuery2Change(mql){\n    //handle changes for query2\n}\n\n```\nThis allows for complex responsive design scenarios where behavior depends on multiple environmental factors.\n\n\n## Advanced Usage\n\n### Custom Query Functions\n\nWhile `css3-mediaqueries.js` primarily uses standard media query strings, you can enhance its functionality by creating custom query functions that perform more complex checks or integrate with other parts of your application.  These custom functions would internally use the `matchMedia` functionality of the library or its underlying browser support to determine the match state. For instance, you might create a function that checks for both screen size and device type:\n\n\n```javascript\nfunction isLargeTabletLandscape() {\n  const widthQuery = window.matchMedia('(min-width: 1024px)');\n  const orientationQuery = window.matchMedia('(orientation: landscape)');\n  return widthQuery.matches && orientationQuery.matches;\n}\n\n\nif (isLargeTabletLandscape()) {\n  // Apply styles for large tablet in landscape mode.\n}\n```\n\nThis function leverages the core `matchMedia` functionality but encapsulates a more specific condition.\n\n\n### Asynchronous Operations\n\nMedia query matching is typically a synchronous operation; however, if you need to perform asynchronous tasks based on media query changes, you should structure your code appropriately using Promises or async/await to ensure proper sequencing.  For example:\n\n```javascript\nasync function handleQueryChange(mql) {\n    if (mql.matches) {\n        try{\n            const data = await fetch('/api/data'); // Example asynchronous operation\n            // Process the data\n        } catch(error) {\n            console.error(\"Error fetching data:\", error);\n        }\n    } else {\n        // Handle the case where the query doesn't match.\n    }\n}\n\nconst query = window.matchMedia('(min-width: 1200px)');\nquery.addListener(handleQueryChange);\n```\n\n\n### Integration with Other Libraries\n\n`css3-mediaqueries.js` is designed to work alongside other JavaScript libraries.  There are no inherent conflicts.  Ensure your inclusion order is correct (avoiding conflicts if other libraries modify the `window.matchMedia` function), and you can use the results from this library to inform the behavior of other parts of your application.  For example, you could use this library to detect screen size and then dynamically load components from a framework like React or Vue based on the media query results.\n\n### Performance Optimization\n\nFor optimal performance:\n\n* **Minimize listener usage:** Don't add unnecessary listeners.  Only attach listeners to the queries that directly affect your application's behavior.\n* **Efficient callbacks:** Keep your callback functions concise and performant. Avoid computationally intensive tasks within the listener.  If necessary, defer heavy processing to a separate function.\n* **Debouncing/throttling:** If rapid changes (like during rapid resizing) trigger your callbacks, consider implementing debouncing or throttling techniques to reduce the frequency of updates. This will prevent unnecessary DOM manipulations or other potentially expensive operations.\n\n### Debugging and Troubleshooting\n\nIf you encounter problems:\n\n* **Browser console:** Check your browser's developer console for errors or warnings.  `css3-mediaqueries.js` itself is relatively simple and unlikely to throw many errors, but errors in your custom code using the library will be visible here.\n* **Media query validation:** Verify your media query strings for syntax errors.  Use browser developer tools to inspect whether the queries are actually being matched as you intend.\n* **Testing across browsers:**  Test your implementation in multiple browsers to ensure consistent behavior.  Discrepancies might indicate issues with browser-specific quirks that are not fully addressed by the polyfill.\n* **Simplified test cases:** If debugging complex interactions, try creating simplified test cases to isolate potential problems.  Start with a minimal example using a single media query to pinpoint the source of any issues.\n\nRemember to consult the library's source code or any associated unit tests for additional troubleshooting information.\n\n\n## API Reference\n\nThis section details the API available within `css3-mediaqueries.js`.  Note that the exact API may vary slightly depending on the version of the library; always refer to the latest documentation for the most accurate information.  The examples below assume you've included the library in your project and have access to the `matchMedia` function.\n\n### Constructor Options\n\nThe `matchMedia` function, which is the core of the library, doesn't directly have constructor options in the same way a class might.  The options are implicitly provided through the media query string itself.  The `matchMedia` function accepts a single argument:\n\n* **`mediaQueryString` (string):**  A valid CSS media query string. This string defines the conditions that must be met for the query to match. This is where you specify options like `min-width`, `max-height`, `orientation`, etc.  Any valid CSS media query string is accepted.\n\n```javascript\nconst query = window.matchMedia('(min-width: 768px) and (orientation: landscape)'); //Example\n```\n\n### `addListener()` Method\n\nThe `addListener()` method attaches a callback function to a `MediaQueryList` object. This callback function will be executed whenever the match state of the media query changes.\n\n* **`listener` (function):**  A callback function that takes a single argument: a `MediaQueryList` object representing the updated state of the media query.  The `MediaQueryList` object has a `matches` property (boolean) indicating whether the query currently matches.\n\n```javascript\nconst query = window.matchMedia('(min-width: 500px)');\nquery.addListener(function(mql) {\n  if (mql.matches) {\n    console.log('Media query now matches!');\n  } else {\n    console.log('Media query no longer matches.');\n  }\n});\n```\n\n### `removeListener()` Method\n\nThe `removeListener()` method removes a previously added listener from a `MediaQueryList` object.  This is crucial for preventing memory leaks or unwanted behavior when a listener is no longer needed.\n\n* **`listener` (function):** The callback function that was previously added using `addListener()`.\n\n```javascript\nconst query = window.matchMedia('(min-width: 500px)');\nconst myListener = function(mql) { /* ... */ };\nquery.addListener(myListener);\n// ... later, when you no longer need the listener ...\nquery.removeListener(myListener);\n```\n\n### `matches` Property\n\nThe `matches` property of the `MediaQueryList` object is a boolean that indicates whether the media query currently matches the browser's environment.\n\n```javascript\nconst query = window.matchMedia('(max-width: 600px)');\nconsole.log(query.matches); // true or false\n```\n\n\n### `getMatchedStyles()` Method\n\nThis method is **not** part of the standard `MediaQueryList` object.  The library itself doesn't inherently provide a method to directly fetch applied styles based on media query matches. Styles are applied through standard CSS rules using the information provided by the `matches` property. The developer needs to manage style changes manually based on the `matches` state.\n\n\n### `destroy()` Method\n\nThere is no inherent `destroy()` method within the `css3-mediaqueries.js` API or the standard `MediaQueryList` object.  To cleanup, simply remove any event listeners using `removeListener()`.  The library's resources are managed automatically by the browser's garbage collection once they are no longer referenced.  This implies that once there are no more references to a `MediaQueryList` object and its associated listeners, the browser will reclaim the memory.\n\n\n\n\n## Examples\n\nThese examples demonstrate how to use `css3-mediaqueries.js` in various scenarios. Remember to include the library in your HTML file before using these code snippets.\n\n### Basic Media Query Matching\n\nThis example shows how to detect if the screen width is greater than 768 pixels and apply different styles accordingly.\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<title>Basic Media Query</title>\n<style>\n.large-screen {\n  font-size: 24px;\n}\n.small-screen {\n  font-size: 16px;\n}\n</style>\n<script src=\"css3-mediaqueries.js\"></script> </head>\n<body>\n\n<p id=\"myText\">This is some text.</p>\n\n<script>\n  const query = window.matchMedia('(min-width: 768px)');\n\n  function handleQueryChange(mql) {\n    const textElement = document.getElementById('myText');\n    if (mql.matches) {\n      textElement.classList.add('large-screen');\n      textElement.classList.remove('small-screen');\n    } else {\n      textElement.classList.add('small-screen');\n      textElement.classList.remove('large-screen');\n    }\n  }\n\n  query.addListener(handleQueryChange);\n  handleQueryChange(query); // Initial check\n</script>\n\n</body>\n</html>\n```\n\n### Responsive Image Handling\n\nThis example demonstrates how to dynamically switch between different images based on screen width.\n\n```javascript\nconst query = window.matchMedia('(max-width: 600px)');\nconst img = document.getElementById('myImage');\nconst smallImg = 'small.jpg';\nconst largeImg = 'large.jpg';\n\nfunction handleImageChange(mql) {\n  img.src = mql.matches ? smallImg : largeImg;\n}\n\nquery.addListener(handleImageChange);\nhandleImageChange(query); //Initial check\n\n```\n\nRemember to replace  `'small.jpg'` and `'large.jpg'` with the actual paths to your images and to include the image element with the id `myImage` in your HTML.\n\n\n### Dynamic Styling Based on Device Orientation\n\nThis example changes the background color based on whether the device is in portrait or landscape mode.\n\n```javascript\nconst query = window.matchMedia('(orientation: landscape)');\nconst body = document.body;\n\nfunction handleOrientationChange(mql) {\n  body.style.backgroundColor = mql.matches ? 'lightblue' : 'lightcoral';\n}\n\nquery.addListener(handleOrientationChange);\nhandleOrientationChange(query); //Initial check\n```\n\n\n### Complex Media Query Scenarios\n\nThis example combines multiple media queries to apply different styles based on screen width and resolution.\n\n```javascript\nconst query1 = window.matchMedia('(min-width: 1024px)');\nconst query2 = window.matchMedia('(min-resolution: 2dppx)');\nconst element = document.getElementById('myElement');\n\nfunction handleQueryChanges() {\n  if (query1.matches && query2.matches) {\n    element.classList.add('high-res-large');\n    element.classList.remove('low-res-large', 'high-res-small', 'low-res-small');\n  } else if (query1.matches) {\n    element.classList.add('low-res-large');\n    element.classList.remove('high-res-large', 'high-res-small', 'low-res-small');\n  } else if (query2.matches) {\n    element.classList.add('high-res-small');\n    element.classList.remove('high-res-large', 'low-res-large', 'low-res-small');\n  } else {\n    element.classList.add('low-res-small');\n    element.classList.remove('high-res-large', 'low-res-large', 'high-res-small');\n  }\n}\n\n\nquery1.addListener(handleQueryChanges);\nquery2.addListener(handleQueryChanges);\nhandleQueryChanges(); //Initial check\n\n```\n\nRemember to define the CSS classes (`high-res-large`, `low-res-large`, etc.) in your stylesheet and include an element with the ID `myElement` in your HTML.  This demonstrates a more sophisticated use case where different styles are applied based on a combination of multiple media query conditions.  Remember that the order of conditionals within the `handleQueryChanges` function determines which styles are applied if multiple queries match.\n\n\n## Contributing\n\nWe welcome contributions to `css3-mediaqueries.js`!  Whether you're fixing bugs, adding features, or improving documentation, your help is valuable.  Please follow these guidelines to ensure a smooth and efficient contribution process.\n\n### Coding Style Guidelines\n\nMaintain consistency with the existing codebase.  Generally, follow these guidelines:\n\n* **Indentation:** Use 2 spaces for indentation.\n* **Line length:** Keep lines under 80 characters.\n* **Naming conventions:** Use camelCase for variables and functions.\n* **Comments:**  Write clear and concise comments to explain complex logic or non-obvious code sections.\n* **Semicolons:** Use semicolons consistently to terminate statements.\n\n\nBefore submitting a pull request, ensure your code adheres to these guidelines.  You can use a linter (e.g., ESLint) to automatically check for style violations.\n\n### Testing Procedures\n\nThorough testing is crucial.  Before submitting any code changes, run the existing test suite to ensure your modifications don't introduce regressions.  The test suite likely uses a testing framework (e.g., Jest, Mocha) and may involve unit tests to check individual functions and integration tests to verify that different parts of the library work together correctly.  The project should have clear instructions on how to run the tests (often in a `README.md` file).  If adding new features or fixing bugs, write new tests to cover the changes you've made.  Aim for high test coverage.\n\n### Submitting Pull Requests\n\n1. **Fork the repository:** Create a fork of the `css3-mediaqueries.js` repository on GitHub.\n2. **Create a branch:** Create a new branch for your changes. Use descriptive branch names (e.g., `fix-bug-123`, `feature-new-query-type`).\n3. **Make your changes:** Implement your changes, following the coding style guidelines and writing tests.\n4. **Commit your changes:** Commit your changes with clear and concise commit messages.  Explain what you've changed and why.\n5. **Push your branch:** Push your branch to your forked repository.\n6. **Create a pull request:** Create a pull request from your branch to the main branch of the original repository.  Provide a detailed description of your changes and address any comments or suggestions from the maintainers.\n\nYour pull request will be reviewed by the project maintainers.  Be prepared to address any feedback or make necessary revisions.\n\n\n### Reporting Bugs\n\nIf you discover a bug in `css3-mediaqueries.js`, please report it by creating a new issue on the GitHub repository.  Provide the following information:\n\n* **Clear title:** Summarize the issue in the title.\n* **Detailed description:** Describe the bug clearly and concisely.  Include steps to reproduce the problem and any relevant error messages.\n* **Browser and version:** Specify the browser and version you're using.\n* **Operating system:** Indicate the operating system you're using.\n* **Library version:** Specify the version of `css3-mediaqueries.js` you are using.\n* **Code snippet:** If possible, include a minimal, reproducible code snippet that demonstrates the bug.\n\n\nThe more information you provide, the easier it will be to diagnose and fix the bug.  You can also attach screenshots or screen recordings if that helps clarify the issue.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["../../styles.css"],"html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"},"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"},"../../footer.html"],"output-file":"css3-mediaqueriesjs.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"license":"MIT","author-meta":"Muthukrishnan","title":"css3-mediaqueries.js - Documentation","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}