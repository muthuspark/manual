---
title: "Underscore.js - Documentation"
categories: [ "JavaScript Libraries and Functions" ]
---


### What is Underscore.js?

Underscore.js is a JavaScript library that provides a whole mess of helpful utility functions.  It's a foundational library that offers a consistent and robust set of tools for working with collections (arrays, objects), iterating, and performing common data manipulations.  While it doesn't directly interact with the DOM (unlike jQuery), it excels at providing the functional programming building blocks that make JavaScript development more efficient and readable.  Think of it as a Swiss Army knife for your JavaScript toolkit.

### Why Use Underscore.js?

Underscore.js offers several compelling reasons for inclusion in your projects:

* **Improved Code Readability:** Underscore's functions provide concise and expressive ways to perform common tasks, making your code easier to understand and maintain.  Instead of writing verbose loops and conditional statements, you can leverage Underscore's higher-order functions for a more declarative style.

* **Functional Programming Paradigm:** Underscore promotes a functional programming approach, encouraging immutability and avoiding side effects. This leads to more predictable and testable code.

* **Cross-Browser Compatibility:** Underscore handles cross-browser inconsistencies, ensuring your code works reliably across different browsers and environments.

* **Enhanced Productivity:** Underscore's extensive collection of functions saves you time and effort by providing pre-built solutions for common programming problems.  This allows developers to focus on the unique logic of their application instead of reinventing the wheel.

* **Lightweight:**  Underscore.js has a small footprint, minimizing the impact on your application's performance.


### Setting up Underscore.js

There are several ways to incorporate Underscore.js into your project:

* **Download and Include:** Download the Underscore.js library from the official website (typically a minified version, `underscore-min.js`), and include it in your HTML file using a `<script>` tag:

```html
<script src="underscore-min.js"></script>
```

* **Using a CDN:** Include Underscore.js via a Content Delivery Network (CDN) like jsDelivr or cdnjs.  This avoids the need to download and manage the library yourself.  For example, using jsDelivr:

```html
<script src="https://cdn.jsdelivr.net/npm/underscore@1.13.1/underscore-min.js"></script>
```

* **Using a Package Manager (npm or yarn):** If you're using a module bundler like Webpack or Parcel, or a package manager like npm or yarn, you can install Underscore.js as a dependency:

```bash
npm install underscore
# or
yarn add underscore
```

Then, import it into your JavaScript modules as needed (the specific import syntax depends on your module bundler).  For example, with ES6 modules:

```javascript
import _ from 'underscore';
```


### Core Concepts and Terminology

Understanding these core concepts is crucial for effectively using Underscore.js:

* **Collections:** Underscore primarily works with collections, which are arrays and objects. Many functions operate on these collections to perform transformations, filtering, and other operations.

* **Iterators:**  Functions like `each`, `map`, `reduce`, `filter`, and `find` are iterators that traverse collections and apply a given function to each element. These are fundamental to functional programming with Underscore.

* **Chaining:** Underscore allows method chaining, enabling you to string together multiple operations on a collection in a fluent and readable manner. This significantly improves code clarity.

* **Higher-Order Functions:**  Underscore heavily utilizes higher-order functions. These are functions that take other functions as arguments (e.g., callbacks passed to iterators) or return functions as results.  This enables powerful abstraction and code reusability.

* **Predicates:**  A predicate is a function that returns a boolean value (true or false).  Many Underscore functions use predicates to filter or test elements within a collection (e.g., `filter`, `every`, `some`).

* **Memoization:** Some Underscore functions utilize memoization to improve performance by caching the results of expensive computations.


By understanding these concepts and the functions detailed in the following sections of this manual, you will be well-equipped to harness the power of Underscore.js for your JavaScript projects.




## Collections

Underscore.js provides a rich set of functions for working with collections (arrays and objects).  These functions often utilize iterators and higher-order functions to perform efficient and expressive data manipulation.

### `each` (alias: `forEach`)

Iterates over a list of elements, executing a provided function for each element.  This function doesn't return a value; it's primarily used for side effects (e.g., modifying elements, logging output).

**Signature:**

```javascript
_.each(list, iteratee, [context])
```

* `list`: The array or object to iterate over.
* `iteratee`: The function invoked per iteration.  It receives the element value, index (or key for objects), and the list as arguments.
* `context`:  Optional.  The context (`this`) within which `iteratee` is executed.


**Example:**

```javascript
_.each([1, 2, 3], function(num) { console.log(num); }); // Logs 1, 2, 3 to the console.
_.each({a: 1, b: 2}, function(value, key) { console.log(key + ': ' + value); }); // Logs a: 1, b: 2
```

### `map` (alias: `collect`)

Produces a new array of values by mapping each element in the input list through a transformation function.

**Signature:**

```javascript
_.map(list, iteratee, [context])
```

* `list`: The array or object to iterate over.
* `iteratee`: The function applied to each element.  It receives the element value, index (or key for objects), and the list as arguments.  It should return the transformed value.
* `context`: Optional.  The context (`this`) within which `iteratee` is executed.

**Example:**

```javascript
var doubled = _.map([1, 2, 3], function(num){ return num * 2; }); // doubled will be [2, 4, 6]
```

### `reduce` (alias: `foldl`, `inject`)

Boils down a list of values into a single value.  It iteratively applies a function to each element and accumulates the result.

**Signature:**

```javascript
_.reduce(list, iteratee, memo, [context])
```

* `list`: The array or object to reduce.
* `iteratee`: The function applied to each element.  It receives the accumulated value (`memo`), the current element, its index (or key for objects), and the list as arguments. It should return the updated accumulated value.
* `memo`: The initial value of the accumulator.
* `context`: Optional.  The context (`this`) within which `iteratee` is executed.

**Example:**

```javascript
var sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num; }, 0); // sum will be 6
```

### `filter` (alias: `select`)

Looks through each value in the list, returning an array of all the values that pass a truth test (predicate).

**Signature:**

```javascript
_.filter(list, predicate, [context])
```

* `list`: The array or object to filter.
* `predicate`: The function that determines whether an element is included. It receives the element value, index (or key for objects), and the list as arguments.  It should return `true` if the element should be included, `false` otherwise.
* `context`: Optional. The context (`this`) within which `predicate` is executed.

**Example:**

```javascript
var evens = _.filter([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; }); // evens will be [2, 4, 6]
```

### `reject`

The opposite of `filter`; returns the values that *do not* pass the truth test.

**Signature:**  Similar to `filter`.

**Example:**

```javascript
var odds = _.reject([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; }); // odds will be [1, 3, 5]
```

### `every` (alias: `all`)

Checks if all elements in the list satisfy the given predicate.  Returns `true` if all do, `false` otherwise.

**Signature:** Similar to `filter`.

### `some` (alias: `any`)

Checks if at least one element in the list satisfies the given predicate. Returns `true` if at least one does, `false` otherwise.

**Signature:** Similar to `filter`.


### `contains` (alias: `include`)

Checks if the list contains the given value.

**Signature:**

```javascript
_.contains(list, value, [fromIndex])
```

* `list`: The array or object to search.
* `value`: The value to search for.
* `fromIndex`: Optional. The index to start searching from.

### `invoke`

Calls a method on each value in the list.  Useful for invoking methods on objects within an array.

**Signature:**

```javascript
_.invoke(list, methodName, *args)
```

* `list`: The list of objects.
* `methodName`: The name of the method to invoke.
* `*args`:  Optional arguments to pass to the method.

### `pluck`

Extracts a list of property values from a list of objects.

**Signature:**

```javascript
_.pluck(list, propertyName)
```

* `list`: The list of objects.
* `propertyName`: The name of the property to extract.

### `max`

Returns the maximum value in the list.

**Signature:**

```javascript
_.max(list, [iteratee])
```

* `list`: The list of values.
* `iteratee`: Optional.  A function that returns the value to compare for determining the maximum.

### `min`

Returns the minimum value in the list.

**Signature:** Similar to `max`.

### `sortBy`

Sorts a list of values by a given property or function.

**Signature:**

```javascript
_.sortBy(list, iteratee, [context])
```

* `list`: The list to sort.
* `iteratee`: The property name or function to sort by.
* `context`: Optional. The context (`this`) for the iteratee function.

### `groupBy`

Groups a list of values into an object based on the result of a given function.

**Signature:**

```javascript
_.groupBy(list, iteratee, [context])
```

* `list`: The list to group.
* `iteratee`: The property name or function to group by.
* `context`: Optional. The context (`this`) for the iteratee function.

### `indexBy`

Similar to `groupBy`, but creates an object where the keys are the results of the iteratee and the values are the original elements.

**Signature:** Similar to `groupBy`.

### `countBy`

Counts the number of occurrences of each unique result of an iteratee function.

**Signature:** Similar to `groupBy`.


### `shuffle`

Randomly shuffles the elements in the list.

**Signature:**

```javascript
_.shuffle(list)
```

### `sample`

Returns a random element from the list.  If a number is provided, returns an array of that many random elements.

**Signature:**

```javascript
_.sample(list, [n])
```

* `list`: The list to sample from.
* `n`: Optional. The number of random elements to return.

### `toArray`

Converts an object into an array of its values.

**Signature:**

```javascript
_.toArray(obj)
```

### `size`

Returns the number of elements in a collection.

**Signature:**

```javascript
_.size(obj)
```

This section provides a concise overview of Underscore.js's collection functions.  Refer to the Underscore.js documentation for complete details and advanced usage examples.




## Arrays

Underscore.js extends JavaScript's built-in array functionality with several powerful utility functions.  These functions simplify common array manipulations and improve code readability.

### `first`

Returns the first element of an array.  If a number `n` is provided, returns the first `n` elements as a new array.

**Signature:**

```javascript
_.first(array, [n])
```

* `array`: The input array.
* `n`: Optional. The number of elements to return.

**Example:**

```javascript
_.first([1, 2, 3]); // => 1
_.first([1, 2, 3], 2); // => [1, 2]
```

### `initial`

Returns all elements of an array except the last one.  If a number `n` is provided, returns all but the last `n` elements.

**Signature:**

```javascript
_.initial(array, [n])
```

* `array`: The input array.
* `n`: Optional. The number of elements to exclude from the end.

**Example:**

```javascript
_.initial([1, 2, 3]); // => [1, 2]
_.initial([1, 2, 3, 4], 2); // => [1, 2]
```

### `rest` (alias: `tail`)

Returns all elements of an array except the first one.  If a number `n` is provided, returns all but the first `n` elements.

**Signature:**

```javascript
_.rest(array, [n])
```

* `array`: The input array.
* `n`: Optional. The number of elements to exclude from the beginning.

**Example:**

```javascript
_.rest([1, 2, 3]); // => [2, 3]
_.rest([1, 2, 3, 4], 2); // => [3, 4]
```

### `last`

Returns the last element of an array.  If a number `n` is provided, returns the last `n` elements as a new array.

**Signature:**

```javascript
_.last(array, [n])
```

* `array`: The input array.
* `n`: Optional. The number of elements to return.

**Example:**

```javascript
_.last([1, 2, 3]); // => 3
_.last([1, 2, 3], 2); // => [2, 3]
```

### `compact`

Creates a new array with all falsey values removed.  Falsey values are `false`, `null`, `0`, `""`, `undefined`, and `NaN`.

**Signature:**

```javascript
_.compact(array)
```

* `array`: The input array.

**Example:**

```javascript
_.compact([0, 1, false, 2, '', 3]); // => [1, 2, 3]
```

### `flatten`

Flattens a nested array (array of arrays) into a single level.  Can handle multiple levels of nesting.

**Signature:**

```javascript
_.flatten(array, [shallow])
```

* `array`: The input array.
* `shallow`: Optional.  If true, only flattens one level.

**Example:**

```javascript
_.flatten([1, [2, [3, 4], 5]]); // => [1, 2, 3, 4, 5]
_.flatten([1, [2, [3, 4], 5]], true); // => [1, 2, [3, 4], 5]
```

### `without`

Returns a new array without the given values.

**Signature:**

```javascript
_.without(array, *values)
```

* `array`: The input array.
* `*values`: The values to exclude.

**Example:**

```javascript
_.without([1, 2, 1, 0, 3, 1, 4], 0, 1); // => [2, 3, 4]
```

### `uniq` (alias: `unique`)

Produces a duplicate-free version of the array, using a simple === comparison for equality.  Uses a Set internally for efficiency.

**Signature:**

```javascript
_.uniq(array, [isSorted], [iteratee])
```

* `array`: The input array.
* `isSorted`: Optional.  If true, the input array is assumed to be sorted.  This can improve performance.
* `iteratee`: Optional. A function to extract a value from each element for comparison.

### `union`

Produces the union of multiple arrays.  Returns a new array that contains unique values from all input arrays.

**Signature:**

```javascript
_.union(*arrays)
```

* `*arrays`: Two or more arrays.

### `intersection`

Returns the intersection of multiple arrays; i.e., the elements that appear in *all* input arrays.

**Signature:**

```javascript
_.intersection(*arrays)
```

* `*arrays`: Two or more arrays.


### `difference`

Returns the values from array that are not present in the other arrays.

**Signature:**

```javascript
_.difference(array, *others)
```

* `array`: The input array.
* `*others`: One or more arrays to compare against.


### `zip`

Merges together the values of several arrays, returning an array of arrays where each sub-array contains corresponding values from the input arrays.

**Signature:**

```javascript
_.zip(*arrays)
```

* `*arrays`: Two or more arrays.

**Example:**

```javascript
_.zip(['a', 'b'], [1, 2], [true, false]); // => [['a', 1, true], ['b', 2, false]]
```

### `unzip`

The inverse of `zip`.  Takes an array of arrays and groups the elements based on their position.

**Signature:**

```javascript
_.unzip(array)
```

* `array`: An array of arrays.


### `range`

Generates an array of numbers within a given range.

**Signature:**

```javascript
_.range([start], stop, [step])
```

* `start`: Optional. The starting number (default: 0).
* `stop`: The ending number (exclusive).
* `step`: Optional. The increment (default: 1).


### `bindAll`

Binds a number of methods to an object's scope. Useful for creating functions that maintain context when called later.

**Signature:**

```javascript
_.bindAll(object, *methodNames)
```

* `object`: The object whose methods should be bound.
* `*methodNames`:  The names of the methods to bind.


This section provides a concise overview.  Consult the Underscore.js documentation for detailed examples and edge cases.




## Functions

Underscore.js offers a suite of functions for working with and manipulating JavaScript functions themselves.  These functions provide powerful tools for controlling function execution, managing context, and optimizing performance.

### `bind`

Creates a function that, when called, has its `this` keyword set to a provided value, with a given sequence of arguments prepended to those provided during the actual call.

**Signature:**

```javascript
_.bind(func, context, *args)
```

* `func`: The function to bind.
* `context`: The value to be assigned to `this` when the bound function is called.
* `*args`:  Optional arguments to be prepended to those passed when the bound function is invoked.

**Example:**

```javascript
function greet(greeting) { console.log(greeting + ", " + this.name); }
var person = {name: "Alice"};
var boundGreet = _.bind(greet, person, "Hello");
boundGreet(); // Logs "Hello, Alice"
```

### `partial`

Partially applies a function by filling in given arguments, and returning a new version of the function that accepts the remaining arguments.

**Signature:**

```javascript
_.partial(func, *args)
```

* `func`: The function to partially apply.
* `*args`: Arguments to pre-fill.

**Example:**

```javascript
function add(a, b, c) { return a + b + c; }
var add5 = _.partial(add, 5); // Partially apply the first argument as 5.
add5(2, 3); // Returns 10.
```

### `memoize`

Creates a version of a function that will only call the original function once for any given set of arguments. Subsequent calls with the same arguments will return the cached result.  Useful for expensive function calls.

**Signature:**

```javascript
_.memoize(func, [hashFunction])
```

* `func`: The function to memoize.
* `hashFunction`: Optional. A function used to generate a unique key for the cache based on the arguments.

**Example:**

```javascript
var expensiveFunction = _.memoize(function(n){ /* ...some expensive computation... */ return n*2; });
expensiveFunction(5); // Computes and caches the result.
expensiveFunction(5); // Returns cached result.
```


### `delay`

Schedules a function to be called after a given delay in milliseconds.

**Signature:**

```javascript
_.delay(func, wait, *args)
```

* `func`: The function to delay.
* `wait`: The delay in milliseconds.
* `*args`:  Arguments to pass to the function.

### `defer`

Schedules a function to be called as soon as possible after the current call stack is cleared.  Essentially a delay of 0ms.

**Signature:**

```javascript
_.defer(func, *args)
```

* `func`: The function to defer.
* `*args`: Arguments to pass to the function.

### `throttle`

Creates a throttled version of a function that only executes the function at most once every wait milliseconds.  Useful for rate-limiting functions that are called frequently.

**Signature:**

```javascript
_.throttle(func, wait, [options])
```

* `func`: The function to throttle.
* `wait`: The minimum time between function executions.
* `options`: Optional object with `leading` and `trailing` properties (boolean, default true).  Controls whether the function should be executed on the leading edge and/or trailing edge of the wait period.


### `debounce`

Creates a debounced version of a function.  It will only execute the function after a specified delay, ignoring calls within that delay.  Useful for handling events like window resizing or input changes.

**Signature:**

```javascript
_.debounce(func, wait, [immediate])
```

* `func`: The function to debounce.
* `wait`: The delay in milliseconds.
* `immediate`: Optional boolean. If true, executes the function on the leading edge instead of the trailing edge of the delay.

### `once`

Creates a version of a function that can only be called once.  Subsequent calls will return the result of the first call.

**Signature:**

```javascript
_.once(func)
```

* `func`: The function to make callable only once.


### `after`

Creates a function that will only be executed after being called `n` times.

**Signature:**

```javascript
_.after(times, func)
```

* `times`: The number of times the function must be called before it executes.
* `func`: The function to execute.


### `compose`

Creates a function that is the composition of a list of functions.  Each function consumes the return value of the function that follows.

**Signature:**

```javascript
_.compose(*functions)
```

* `*functions`:  A list of functions to compose.


### `wrap`

Wraps the first function with another function, passing it as the first argument.  Useful for adding pre- or post-processing to a function.

**Signature:**

```javascript
_.wrap(func, wrapper)
```

* `func`: The function to wrap.
* `wrapper`: The function that will wrap `func`.  The `wrapper` should accept `func` as its first argument, and return a function that takes any other arguments passed to the wrapped function.


This section provides a concise overview of Underscore.js's function manipulation utilities.  Consult the Underscore.js documentation for detailed examples and nuanced usage considerations.




## Objects

Underscore.js provides a comprehensive set of functions for working with plain JavaScript objects.  These functions simplify common object manipulations and enhance code readability and maintainability.


### `keys`

Retrieve all the names of the object's own enumerable properties.

**Signature:**

```javascript
_.keys(object)
```

* `object`: The object whose keys are to be retrieved.

**Example:**

```javascript
_.keys({one: 1, two: 2, three: 3}); // => ["one", "two", "three"]
```


### `values`

Retrieve all the values of the object's own enumerable properties.

**Signature:**

```javascript
_.values(object)
```

* `object`: The object whose values are to be retrieved.

**Example:**

```javascript
_.values({one: 1, two: 2, three: 3}); // => [1, 2, 3]
```


### `pairs`

Convert an object into a list of [key, value] pairs.

**Signature:**

```javascript
_.pairs(object)
```

* `object`: The object to convert.

**Example:**

```javascript
_.pairs({one: 1, two: 2}); // => [["one", 1], ["two", 2]]
```


### `invert`

Returns a copy of the object where the keys and values are swapped.

**Signature:**

```javascript
_.invert(object)
```

* `object`: The object to invert.

**Example:**

```javascript
_.invert({a: 1, b: 2, c: 1}); // => {1: "c", 2: "b"}  (Note: last key wins in case of duplicates)
```


### `functions` (alias: `methods`)

Retrieve the names of all the object's own enumerable function properties.

**Signature:**

```javascript
_.functions(object)
```

* `object`: The object to inspect.

**Example:**

```javascript
_.functions({a: function() {}, b: "value"}); // => ["a"]
```


### `extend` (alias: `assign`)

Copy all of the properties in the source objects over to the destination object.

**Signature:**

```javascript
_.extend(destination, *sources)
```

* `destination`: The object to extend.
* `*sources`: One or more source objects.

**Example:**

```javascript
var dest = {a: 1};
_.extend(dest, {b: 2}, {c: 3}); // dest now equals {a: 1, b: 2, c: 3}
```


### `pick`

Copy only the specified properties from the source object into a new object.

**Signature:**

```javascript
_.pick(object, *keys)
```

* `object`: The source object.
* `*keys`: The keys to pick.

**Example:**

```javascript
_.pick({a: 1, b: 2, c: 3}, 'a', 'c'); // => {a: 1, c: 3}
```


### `omit`

Create a new object omitting the specified properties from the source object.

**Signature:**

```javascript
_.omit(object, *keys)
```

* `object`: The source object.
* `*keys`: The keys to omit.


**Example:**

```javascript
_.omit({a: 1, b: 2, c: 3}, 'a', 'c'); // => {b: 2}
```


### `defaults`

Fill in undefined properties in object with values from the defaults objects, recursively.

**Signature:**

```javascript
_.defaults(object, *defaults)
```

* `object`: The target object.
* `*defaults`: One or more default objects.

**Example:**

```javascript
_.defaults({a: 1}, {a: 2, b: 3}); // => {a: 1, b: 3}
```


### `clone`

Create a shallow-copied clone of the object.

**Signature:**

```javascript
_.clone(object)
```

* `object`: The object to clone.


### `isEqual`

Perform a deep comparison between two objects or values.

**Signature:**

```javascript
_.isEqual(object, other)
```

* `object`: The first object or value.
* `other`: The second object or value.


### `isEmpty`

Check if an object (or array) is empty.

**Signature:**

```javascript
_.isEmpty(object)
```

* `object`: The object or array to check.


### `isElement`

Check if an object is a DOM element.

**Signature:**

```javascript
_.isElement(object)
```

* `object`: The object to check.


### `isArray`, `isObject`, `isArguments`, `isFunction`, `isString`, `isNumber`, `isDate`, `isBoolean`, `isUndefined`, `isNull`

These functions are type-checking predicates, returning `true` if the object is of the specified type, and `false` otherwise.  Their signatures are all:

```javascript
_.isArray(object) // etc.
```

* `object`: The object to check.


### `has`

Check if an object has a given key.

**Signature:**

```javascript
_.has(object, key)
```

* `object`: The object to check.
* `key`: The key to check for.


This section provides a concise overview.  Refer to the Underscore.js documentation for complete details and examples.  Note that many of these functions operate on arrays as well as objects, leveraging Underscore's flexible handling of collections.




## Utility Functions

Underscore.js includes a set of general-purpose utility functions that don't neatly fit into the other categories (Collections, Arrays, Objects, Functions). These functions are invaluable for various tasks throughout your JavaScript code.

### `identity`

A function that returns its first argument.  Useful as a default iteratee or when you need a no-op function.

**Signature:**

```javascript
_.identity(value)
```

* `value`: The value to return.

**Example:**

```javascript
_.map([1, 2, 3], _.identity); // => [1, 2, 3]
```

### `constant`

Creates a function that returns a particular value.  Useful for creating functions that always return the same result, regardless of input.

**Signature:**

```javascript
_.constant(value)
```

* `value`: The value to return.

**Example:**

```javascript
var five = _.constant(5);
five(); // => 5
five(10); // => 5
```

### `uniqueId`

Generates a unique ID.  The ID is a string, and subsequent calls generate incrementing IDs.  Optionally, you can provide a prefix.

**Signature:**

```javascript
_.uniqueId([prefix])
```

* `prefix`: Optional string prefix for the ID.

**Example:**

```javascript
_.uniqueId(); // => "id1"
_.uniqueId('prefix-'); // => "prefix-id2"
```

### `escape`

Escapes a string for insertion into HTML.  Escapes `<`, `>`, `"`, `'`, and `&`.

**Signature:**

```javascript
_.escape(string)
```

* `string`: The string to escape.

**Example:**

```javascript
_.escape("<h1>Hello</h1>"); // => "&lt;h1&gt;Hello&lt;/h1&gt;"
```

### `unescape`

The inverse of `escape`.  Unescapes escaped HTML entities.

**Signature:**

```javascript
_.unescape(string)
```

* `string`: The string to unescape.


### `result`

Call a method on a given object with some arguments, and return the result.  If the method is not found, returns the property directly.

**Signature:**

```javascript
_.result(object, property, *args)
```

* `object`: The object to call the method on.
* `property`: The name of the property (or method) to access.
* `*args`: Optional arguments to pass to the method.


**Example:**

```javascript
var obj = {
  name: 'moe',
  greet: function(name){ return 'hi: ' + name; }
};
_.result(obj, 'name');      // => 'moe'
_.result(obj, 'greet', 'curly'); // => 'hi: curly'
```


### `template`

Compiles a template string into a function that can be used to generate HTML.  Uses a simple templating syntax (similar to ERB).

**Signature:**

```javascript
_.template(templateString, [data], [settings])
```

* `templateString`: The template string.
* `data`: Optional data object to populate the template.
* `settings`: Optional settings object (e.g., for escaping).

**Example:**

```javascript
var compiled = _.template("Hello, <%= name %>!");
compiled({name: "World"}); // => "Hello, World!"
```

### `mixin`

Adds functions to the Underscore object, or an arbitrary object.  Allows you to extend Underscore's functionality or create your own utility libraries.

**Signature:**

```javascript
_.mixin(object)
```

* `object`: An object containing functions to add to Underscore.


This section provides a concise overview.  Consult the Underscore.js documentation for comprehensive details and examples of these versatile utility functions.  Remember that `template` requires careful consideration of security if user-supplied data is involved, to avoid potential XSS vulnerabilities.




## Chaining

Underscore.js supports method chaining, allowing you to string together multiple operations on a collection in a fluent and readable manner. This significantly improves code clarity and reduces the need for intermediate variables.

### Chain Methods

Most Underscore.js collection methods (those that operate on arrays or objects) return a wrapped version of the collection. This wrapped object has its own methods, allowing you to chain additional operations.  The methods available on the wrapped object are the same as those on the `_` object itself, but they operate on the wrapped collection and return new wrapped objects, enabling further chaining.  The chain is broken when you call a method that doesn't return a wrapped object (e.g., `_.value()`).

### `_.chain()`

Initiates a chain sequence. It takes a collection (array or object) as input and returns a wrapped object. This object has all the Underscore.js collection methods available for chaining.

**Signature:**

```javascript
_.chain(obj)
```

* `obj`: The array or object to start the chain with.

**Example:**

```javascript
var result = _( [1, 2, 3, 4, 5, 6] )
  .chain()
  .filter( function(num){ return num % 2 === 0; } )
  .map( function(num){ return num * 2; } )
  .value(); //Remember to call value() to get the final result

console.log(result); // => [4, 8, 12]
```

In this example, `_.chain()` creates a wrapped object. The `.filter()` and `.map()` methods operate on the wrapped object and return new wrapped objects, allowing the chain to continue.  Finally, `.value()` unwraps the final result, returning a regular array.


### `_.value()`

Terminates a chain sequence and returns the unwrapped result.  It's crucial to call `_.value()` at the end of a chain to obtain the final result of the chained operations.  Without it, you'd only have a wrapped object, not the actual processed data.

**Signature:**

```javascript
_.value() // Called on the wrapped object
```

**Example:** (same as the previous example, but highlighting `.value()`)

```javascript
var result = _( [1, 2, 3, 4, 5, 6] )
  .chain()
  .filter( function(num){ return num % 2 === 0; } )
  .map( function(num){ return num * 2; } )
  .value(); // <---  Here's the crucial _.value() call

console.log(result); // => [4, 8, 12]
```

Without the `.value()` call, `result` would be a wrapped Underscore object, not the array `[4, 8, 12]`.  This is a common mistake when working with Underscore's chaining functionality.  Always remember to unwrap the result using `.value()`.


This section explains the fundamentals of chaining in Underscore.js.  Efficient use of chaining can significantly improve the elegance and readability of your code when performing multiple operations on collections. Remember that only methods that return wrapped objects can be chained.




## Advanced Techniques and Best Practices

This section delves into more advanced aspects of using Underscore.js effectively, focusing on best practices and techniques to maximize its benefits.

### Error Handling

Underscore.js itself doesn't offer specific error-handling mechanisms beyond the standard JavaScript exceptions.  However, you should incorporate robust error handling within your code *when using* Underscore.js functions.  This is especially crucial when working with iterators and functions that might encounter unexpected input:

* **Validate Input:** Before passing data to Underscore functions, check for null, undefined, or unexpected types.  This prevents unexpected behavior or crashes.

* **Handle Callback Errors:** If you use custom callback functions within Underscore's iterators (`each`, `map`, `reduce`, etc.), implement `try...catch` blocks inside those callbacks to handle potential errors gracefully.  Consider returning a special value or logging the error to help with debugging.

* **Check Return Values:**  Be aware of what the Underscore functions return. Some return new collections, while others return single values or modify collections in place. Understanding these return values allows you to anticipate and handle potential issues more effectively.

* **Test Thoroughly:** Write comprehensive unit tests to ensure your code using Underscore.js handles various scenarios, including edge cases and error conditions.


### Performance Optimization

While Underscore.js is generally efficient, you can further optimize performance in your applications:

* **Memoization:** Utilize `_.memoize()` for computationally expensive functions that are called repeatedly with the same arguments. This can drastically reduce processing time.

* **Avoid Unnecessary Operations:**  Chain methods judiciously.  Avoid unnecessary operations within iterators or other functions, as these can impact performance, especially on large datasets.

* **Use Optimized Functions:**  Underscore.js often provides optimized versions of common tasks (like `_.uniq()`).  Leverage these whenever possible instead of writing your own custom implementations.

* **Iterate Efficiently:** Choose the appropriate iterator for the job. `_.each` is for side effects, while `_.map` transforms data.  `_.reduce` is powerful but requires understanding.  Select the most efficient iterator for your specific needs.

* **Profile Your Code:** Use browser developer tools (or Node.js profilers) to identify performance bottlenecks.  This allows you to target optimization efforts effectively.


### Integration with other libraries

Underscore.js works well with other JavaScript libraries.  There's no inherent conflict.  However, be mindful of potential naming collisions.  If another library uses the same names as Underscore functions, you might need to adjust your code (e.g., using aliases or a different naming scheme).  Also, be aware that Underscore.js does *not* directly manipulate the DOM.  If DOM manipulation is needed, you'll typically use a library like jQuery in conjunction with Underscore.


### Common Use Cases and Examples

Underscore.js shines in several common development scenarios:

* **Data Transformation:**  Use `_.map`, `_.filter`, `_.reduce`, and other collection methods to manipulate and transform data efficiently.

* **Data Validation:**  Leverage `_.isArray`, `_.isObject`, and other type-checking functions to ensure your data meets expectations.

* **Asynchronous Operations:**  Combine Underscore.js with Promises or async/await to handle asynchronous operations while maintaining clean and readable code.

* **Event Handling (Indirectly):**  While Underscore doesn't directly handle DOM events, you can use it to process data from events after they are handled by a DOM library like jQuery.

* **Creating Reusable Utility Functions:** Use Underscore.js functions as building blocks for your own custom utility functions, increasing code reusability.

**Example:**  Transforming an array of objects:

```javascript
var users = [
  {id: 1, name: "Alice", active: true},
  {id: 2, name: "Bob", active: false},
  {id: 3, name: "Charlie", active: true}
];

var activeUsers = _.chain(users)
  .filter(user => user.active)
  .map(user => user.name)
  .value();

console.log(activeUsers); // => ["Alice", "Charlie"]
```


This section provides guidance on leveraging Underscore.js effectively. By incorporating these best practices, you can build robust, maintainable, and efficient JavaScript applications. Remember to always consult the official Underscore.js documentation for the most up-to-date information.




## Appendix

This appendix provides supplementary information to aid your understanding and use of Underscore.js.

### Glossary of Terms

* **Collection:** In Underscore.js, a collection refers to either an array or an object.  Many Underscore functions operate on both types interchangeably.

* **Iteratee:** A function passed as an argument to another function (often an Underscore function) that is executed for each item in a collection.  It typically receives the element value, index (or key for objects), and the collection itself as arguments.

* **Predicate:** A function that returns a boolean value (`true` or `false`).  Underscore often uses predicates to filter collections based on a condition.

* **Higher-Order Function:** A function that takes one or more functions as arguments or returns a function as its result. Underscore is heavily reliant on higher-order functions.

* **Memoization:** An optimization technique used to speed up computations by caching the results of expensive function calls. Underscore's `_.memoize()` function facilitates this.

* **Chaining:** The ability to call multiple Underscore methods sequentially on a collection, improving code readability and reducing temporary variables.

* **Wrapped Object:**  The object returned by `_.chain()`. It has methods that allow you to continue chaining Underscore operations.


### Frequently Asked Questions (FAQ)

* **Should I still use Underscore.js in 2024?**  While many of Underscore's functions are now natively available in modern JavaScript (via array methods and other features), Underscore still offers benefits:  consistency across older browsers, a familiar API, and some functions (like `_.memoize()` or `_.template()`) that may not have direct equivalents with the same ease of use.  The decision depends on your project's requirements and target browsers.

* **What's the difference between `_.each` and `_.map`?** `_.each` is primarily for side effects (e.g., logging, modifying in place).  It doesn't return a value. `_.map` transforms each element in the collection and returns a new array with the transformed elements.

* **How do I handle errors in my Underscore code?**  Underscore itself doesn't handle errors directly.  Implement robust error handling within your callback functions using `try...catch` blocks and validate your input data before passing it to Underscore methods.

* **Why is my chain not working?** Make sure that you are calling `.value()` at the end of your chain to retrieve the final result. Also ensure that you're chaining methods that return wrapped objects.

* **How do I integrate Underscore with other libraries?**  Generally, there are no inherent conflicts.  Be cautious of potential naming collisions; use aliases if necessary.  For DOM manipulation, use a library like jQuery alongside Underscore.


### Further Resources and Learning

* **Official Underscore.js Documentation:** The most authoritative source for information.  Check the official website for the latest API documentation and release notes.

* **Underscore.js Source Code:** Studying the source code itself can be beneficial for a deeper understanding of how Underscore functions work.

* **Online Tutorials and Articles:** Numerous tutorials and articles on Underscore.js are available online. Search for "Underscore.js tutorial" or similar terms.

* **Books on Functional Programming:** Underscore promotes functional programming principles.  Learning more about functional programming can significantly improve your ability to leverage Underscore effectively.


This appendix provides supplemental material to enhance your Underscore.js experience.  Remember to always refer to the official documentation for the most accurate and up-to-date information.

