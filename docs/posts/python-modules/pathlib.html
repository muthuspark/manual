<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Muthukrishnan">

<title>pathlib - Documentation – Technical Manuals</title>
<style>
html {
  color: #1a1a1a;
  background-color: #fdfdfd;
}
body {
  margin: 0 auto;
  max-width: 36em;
  padding-left: 50px;
  padding-right: 50px;
  padding-top: 50px;
  padding-bottom: 50px;
  hyphens: auto;
  overflow-wrap: break-word;
  text-rendering: optimizeLegibility;
  font-kerning: normal;
}
@media (max-width: 600px) {
  body {
    font-size: 0.9em;
    padding: 12px;
  }
  h1 {
    font-size: 1.8em;
  }
}
@media print {
  html {
    background-color: white;
  }
  body {
    background-color: transparent;
    color: black;
    font-size: 12pt;
  }
  p, h2, h3 {
    orphans: 3;
    widows: 3;
  }
  h2, h3, h4 {
    page-break-after: avoid;
  }
}
p {
  margin: 1em 0;
}
a {
  color: #1a1a1a;
}
a:visited {
  color: #1a1a1a;
}
img {
  max-width: 100%;
}
svg {
  height; auto;
  max-width: 100%;
}
h1, h2, h3, h4, h5, h6 {
  margin-top: 1.4em;
}
h5, h6 {
  font-size: 1em;
  font-style: italic;
}
h6 {
  font-weight: normal;
}
ol, ul {
  padding-left: 1.7em;
  margin-top: 1em;
}
li > ol, li > ul {
  margin-top: 0;
}
ul > li:not(:has(> p)) > ul,
ol > li:not(:has(> p)) > ul,
ul > li:not(:has(> p)) > ol,
ol > li:not(:has(> p)) > ol {
  margin-bottom: 0;
}
ul > li:not(:has(> p)) > ul > li:has(> p),
ol > li:not(:has(> p)) > ul > li:has(> p),
ul > li:not(:has(> p)) > ol > li:has(> p),
ol > li:not(:has(> p)) > ol > li:has(> p) {
  margin-top: 1rem;
}
blockquote {
  margin: 1em 0 1em 1.7em;
  padding-left: 1em;
  border-left: 2px solid #e6e6e6;
  color: #606060;
}
code {
  font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
  font-size: 85%;
  margin: 0;
  hyphens: manual;
}
pre {
  margin: 1em 0;
  overflow: auto;
}
pre code {
  padding: 0;
  overflow: visible;
  overflow-wrap: normal;
}
.sourceCode {
 background-color: transparent;
 overflow: visible;
}
hr {
  background-color: #1a1a1a;
  border: none;
  height: 1px;
  margin: 1em 0;
}
table {
  margin: 1em 0;
  border-collapse: collapse;
  width: 100%;
  overflow-x: auto;
  display: block;
  font-variant-numeric: lining-nums tabular-nums;
}
table caption {
  margin-bottom: 0.75em;
}
tbody {
  margin-top: 0.5em;
  border-top: 1px solid #1a1a1a;
  border-bottom: 1px solid #1a1a1a;
}
th {
  border-top: 1px solid #1a1a1a;
  padding: 0.25em 0.5em 0.25em 0.5em;
}
td {
  padding: 0.125em 0.5em 0.25em 0.5em;
}
header {
  margin-bottom: 4em;
  text-align: center;
}
#TOC li {
  list-style: none;
}
#TOC ul {
  padding-left: 1.3em;
}
#TOC > ul {
  padding-left: 0;
}
#TOC a:not(:hover) {
  text-decoration: none;
}
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<link href="../../favicon.ico" rel="icon">
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-MXDPF6L5TL"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-MXDPF6L5TL', { 'anonymize_ip': true});
</script>
<link rel="icon" type="image/x-icon" href="favicon.ico">
<meta property="og:title" content="pathlib - Documentation – Technical Manuals">
<meta property="og:site_name" content="Technical Manuals">
</head><body><div class="navigation-header">
    <nav>
        <div>
            <div class="logo">
                <a href="../../" aria-label="Home">
                    <span>Technical Manuals - Home</span>
                </a>
            </div>
            <div class="nav-menu">
                <ul>
                    <li>
                        <a href="../../about.html">
                            <span class="menu-text">About</span>
                        </a>
                    </li>
                    <li> 
                        <a href="https://github.com/muthuspark" target="_blank">
                            <span class="menu-text">Github</span>
                        </a>
                    </li>
                    <li>
                        <a href="https://linkedin.com/in/krimuthu" target="_blank">
                            <span class="menu-text">Linkedin</span>
                        </a>
                    </li>
                    <li>
                        <button onclick="window.print()" class="print-button">
                            <svg width="20" height="20" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <path d="M6 9V2h12v7"></path>
                              <path d="M6 18H4a2 2 0 01-2-2v-5a2 2 0 012-2h16a2 2 0 012 2v5a2 2 0 01-2 2h-2"></path>
                              <path d="M6 14h12v8H6z"></path>
                            </svg>
                            Print Page
                        </button>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
</div>


<link rel="stylesheet" href="../../styles.css">





<header id="title-block-header">
<h1 class="title">pathlib - Documentation</h1>

</header>

<nav id="TOC" role="doc-toc">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#what-is-pathlib" id="toc-what-is-pathlib">What is pathlib?</a></li>
  <li><a href="#why-use-pathlib" id="toc-why-use-pathlib">Why use pathlib?</a></li>
  <li><a href="#pathlib-vs.-os.path" id="toc-pathlib-vs.-os.path">pathlib vs.&nbsp;os.path</a></li>
  <li><a href="#installing-pathlib" id="toc-installing-pathlib">Installing pathlib</a></li>
  <li><a href="#core-concepts" id="toc-core-concepts">Core Concepts</a>
  <ul>
  <li><a href="#path-objects" id="toc-path-objects">Path Objects</a></li>
  <li><a href="#path-representation" id="toc-path-representation">Path Representation</a></li>
  <li><a href="#absolute-vs.-relative-paths" id="toc-absolute-vs.-relative-paths">Absolute vs.&nbsp;Relative Paths</a></li>
  <li><a href="#pure-paths" id="toc-pure-paths">Pure Paths</a></li>
  </ul></li>
  <li><a href="#creating-paths" id="toc-creating-paths">Creating Paths</a>
  <ul>
  <li><a href="#creating-paths-from-strings" id="toc-creating-paths-from-strings">Creating Paths from Strings</a></li>
  <li><a href="#creating-paths-from-other-paths" id="toc-creating-paths-from-other-paths">Creating Paths from other Paths</a></li>
  <li><a href="#joining-paths" id="toc-joining-paths">Joining Paths</a></li>
  <li><a href="#resolving-paths" id="toc-resolving-paths">Resolving Paths</a></li>
  </ul></li>
  <li><a href="#path-manipulation" id="toc-path-manipulation">Path Manipulation</a>
  <ul>
  <li><a href="#getting-path-components" id="toc-getting-path-components">Getting Path Components</a></li>
  <li><a href="#modifying-path-components" id="toc-modifying-path-components">Modifying Path Components</a></li>
  <li><a href="#working-with-suffixes-and-prefixes" id="toc-working-with-suffixes-and-prefixes">Working with suffixes and prefixes</a></li>
  <li><a href="#normalization" id="toc-normalization">Normalization</a></li>
  <li><a href="#iteration" id="toc-iteration">Iteration</a></li>
  </ul></li>
  <li><a href="#file-system-operations" id="toc-file-system-operations">File System Operations</a>
  <ul>
  <li><a href="#checking-file-existence" id="toc-checking-file-existence">Checking File Existence</a></li>
  <li><a href="#creating-files-and-directories" id="toc-creating-files-and-directories">Creating Files and Directories</a></li>
  <li><a href="#deleting-files-and-directories" id="toc-deleting-files-and-directories">Deleting Files and Directories</a></li>
  <li><a href="#renaming-files-and-directories" id="toc-renaming-files-and-directories">Renaming Files and Directories</a></li>
  <li><a href="#copying-files-and-directories" id="toc-copying-files-and-directories">Copying Files and Directories</a></li>
  <li><a href="#moving-files-and-directories" id="toc-moving-files-and-directories">Moving Files and Directories</a></li>
  <li><a href="#getting-file-information-size-modification-time-etc." id="toc-getting-file-information-size-modification-time-etc.">Getting File Information (size, modification time, etc.)</a></li>
  <li><a href="#globbing-finding-files-matching-patterns" id="toc-globbing-finding-files-matching-patterns">Globbing (finding files matching patterns)</a></li>
  </ul></li>
  <li><a href="#working-with-directories" id="toc-working-with-directories">Working with Directories</a>
  <ul>
  <li><a href="#listing-directory-contents" id="toc-listing-directory-contents">Listing Directory Contents</a></li>
  <li><a href="#creating-directories" id="toc-creating-directories">Creating Directories</a></li>
  <li><a href="#removing-directories" id="toc-removing-directories">Removing Directories</a></li>
  <li><a href="#iterating-over-directories" id="toc-iterating-over-directories">Iterating over Directories</a></li>
  <li><a href="#walking-directory-trees" id="toc-walking-directory-trees">Walking Directory Trees</a></li>
  </ul></li>
  <li><a href="#advanced-usage" id="toc-advanced-usage">Advanced Usage</a>
  <ul>
  <li><a href="#symbolic-links" id="toc-symbolic-links">Symbolic Links</a></li>
  <li><a href="#handling-errors" id="toc-handling-errors">Handling Errors</a></li>
  <li><a href="#performance-optimization" id="toc-performance-optimization">Performance Optimization</a></li>
  <li><a href="#integration-with-other-modules" id="toc-integration-with-other-modules">Integration with other modules</a></li>
  </ul></li>
  <li><a href="#examples-and-best-practices" id="toc-examples-and-best-practices">Examples and Best Practices</a>
  <ul>
  <li><a href="#common-use-cases" id="toc-common-use-cases">Common Use Cases</a></li>
  <li><a href="#coding-style-guidelines" id="toc-coding-style-guidelines">Coding Style Guidelines</a></li>
  <li><a href="#error-handling-examples" id="toc-error-handling-examples">Error Handling Examples</a></li>
  <li><a href="#advanced-examples" id="toc-advanced-examples">Advanced Examples</a></li>
  </ul></li>
  <li><a href="#appendix-reference" id="toc-appendix-reference">Appendix: Reference</a>
  <ul>
  <li><a href="#path-methods-and-attributes" id="toc-path-methods-and-attributes">Path methods and attributes</a></li>
  <li><a href="#exceptions" id="toc-exceptions">Exceptions</a></li>
  </ul></li>
  </ul>
</nav>
<h3 id="what-is-pathlib">What is pathlib?</h3>
<p><code>pathlib</code> is a Python module that offers an object-oriented way to interact with files and directories. Instead of manipulating file paths as strings, <code>pathlib</code> provides a <code>Path</code> object that represents a file system path. These objects have methods for performing common file system operations, making code more readable and less error-prone. It’s designed to be more Pythonic and intuitive than working directly with strings and the <code>os</code> module.</p>
<h3 id="why-use-pathlib">Why use pathlib?</h3>
<p><code>pathlib</code> offers several advantages over using strings and the <code>os</code> module for file path manipulation:</p>
<ul>
<li><p><strong>Readability and Maintainability:</strong> <code>pathlib</code>’s methods (e.g., <code>.exists()</code>, <code>.mkdir()</code>, <code>.rename()</code>) are more descriptive and easier to understand than their <code>os</code> module equivalents. This improves code readability and makes it easier to maintain.</p></li>
<li><p><strong>Type Safety:</strong> <code>Path</code> objects are explicitly typed, leading to fewer runtime errors caused by incorrect path manipulation. The compiler (or your IDE) can catch some mistakes that would be silent with string manipulation.</p></li>
<li><p><strong>Improved Error Handling:</strong> <code>pathlib</code> methods often raise more specific exceptions, allowing for more targeted error handling in your code.</p></li>
<li><p><strong>Object-Oriented Approach:</strong> The object-oriented nature of <code>pathlib</code> allows for chaining of operations, leading to more concise and elegant code.</p></li>
<li><p><strong>Platform Independence:</strong> <code>pathlib</code> handles the differences between operating systems (Windows, macOS, Linux) transparently, so your code is more portable.</p></li>
</ul>
<h3 id="pathlib-vs.-os.path">pathlib vs.&nbsp;os.path</h3>
<p><code>os.path</code> provides functions for manipulating file paths as strings. While functional, this approach is prone to errors due to string manipulation and lacks the readability and object-oriented advantages of <code>pathlib</code>. <code>pathlib</code> builds upon the functionality of <code>os.path</code> but offers a significantly improved user experience and reduced risk of errors. For new projects, <code>pathlib</code> is strongly recommended. Migrating existing projects to <code>pathlib</code> can greatly improve maintainability and reduce bugs.</p>
<h3 id="installing-pathlib">Installing pathlib</h3>
<p><code>pathlib</code> is part of Python’s standard library, meaning it’s included with every standard Python installation. There’s no separate installation required. You can simply import it into your scripts using:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span></code></pre></div>
<h2 id="core-concepts">Core Concepts</h2>
<h3 id="path-objects">Path Objects</h3>
<p>The central element of <code>pathlib</code> is the <code>Path</code> object. A <code>Path</code> object represents a file system path. You create a <code>Path</code> object by passing a string representing a path to the <code>Path()</code> constructor:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>my_path <span class="op">=</span> Path(<span class="st">"/tmp/my_file.txt"</span>)  <span class="co"># For POSIX systems</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>my_path <span class="op">=</span> Path(<span class="st">"C:</span><span class="ch">\\</span><span class="st">Users</span><span class="ch">\\</span><span class="st">username</span><span class="ch">\\</span><span class="st">Documents</span><span class="ch">\\</span><span class="st">my_file.txt"</span>) <span class="co"># For Windows</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>my_path <span class="op">=</span> Path(<span class="st">"relative/path/to/file.txt"</span>) <span class="co"># Relative path</span></span></code></pre></div>
<p>Once you have a <code>Path</code> object, you can use its methods to perform various operations on the file or directory it represents, such as checking if it exists, creating directories, reading files, etc.</p>
<h3 id="path-representation">Path Representation</h3>
<p><code>Path</code> objects internally represent paths in a way that’s independent of the underlying operating system. However, when you need to convert a <code>Path</code> object to a string (e.g., for printing or use with other libraries), it adapts to the current operating system’s path conventions. This means the string representation will use forward slashes (<code>/</code>) on POSIX systems and backslashes (<code>\</code>) on Windows. You can explicitly control the string representation using the <code>as_posix()</code> and <code>as_uri()</code> methods.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>my_path <span class="op">=</span> Path(<span class="st">"/tmp/my_file.txt"</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">str</span>(my_path)) <span class="co"># Output will be OS-specific</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(my_path.as_posix()) <span class="co"># Output: /tmp/my_file.txt (POSIX style)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(my_path.as_uri()) <span class="co"># Output: file:///tmp/my_file.txt (URI style)</span></span></code></pre></div>
<h3 id="absolute-vs.-relative-paths">Absolute vs.&nbsp;Relative Paths</h3>
<p>A <em>absolute path</em> specifies the location of a file or directory starting from the root of the file system. Examples include <code>/tmp/my_file.txt</code> (POSIX) and <code>C:\Users\username\Documents\my_file.txt</code> (Windows). An <em>relative path</em> specifies the location of a file or directory relative to the current working directory. For example, <code>data/myfile.txt</code> would locate the file in the <code>data</code> subdirectory relative to where your script is running.</p>
<p><code>pathlib</code> allows you to easily work with both types of paths. The <code>is_absolute()</code> method can be used to determine if a <code>Path</code> object represents an absolute path. The <code>resolve()</code> method can convert a relative path to an absolute path.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>absolute_path <span class="op">=</span> Path(<span class="st">"/tmp/my_file.txt"</span>) <span class="co"># Absolute path (POSIX)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>relative_path <span class="op">=</span> Path(<span class="st">"data/myfile.txt"</span>) <span class="co"># Relative path</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(absolute_path.is_absolute()) <span class="co"># Output: True</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(relative_path.is_absolute()) <span class="co"># Output: False</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>absolute_relative_path <span class="op">=</span> relative_path.resolve() <span class="co"># Convert to absolute path (requires appropriate current working directory)</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(absolute_relative_path)</span></code></pre></div>
<h3 id="pure-paths">Pure Paths</h3>
<p>A <code>PurePath</code> object is similar to a <code>Path</code> object, but it doesn’t interact with the actual file system. It’s purely for path manipulation without file system I/O. This is useful for situations where you want to perform path operations (like joining paths or extracting components) without the overhead of file system access or the risk of exceptions due to nonexistent files. You can create a <code>PurePath</code> object using the <code>PurePath()</code> constructor. Note that methods that involve interaction with the file system (like <code>exists()</code>, <code>mkdir()</code>, <code>open()</code>) are not available on <code>PurePath</code> objects.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> PurePath</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>pure_path <span class="op">=</span> PurePath(<span class="st">"/tmp/my_file.txt"</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pure_path.parent) <span class="co"># Output: PurePosixPath('/tmp')</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co"># pure_path.exists()  # This would raise an AttributeError because PurePath cannot interact with the file system.</span></span></code></pre></div>
<h2 id="creating-paths">Creating Paths</h2>
<h3 id="creating-paths-from-strings">Creating Paths from Strings</h3>
<p>The most common way to create a <code>Path</code> object is by passing a string representing the file path to the <code>Path()</code> constructor:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Absolute paths</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>posix_path <span class="op">=</span> Path(<span class="st">"/tmp/my_file.txt"</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>windows_path <span class="op">=</span> Path(<span class="st">"C:</span><span class="ch">\\</span><span class="st">Users</span><span class="ch">\\</span><span class="st">username</span><span class="ch">\\</span><span class="st">Documents</span><span class="ch">\\</span><span class="st">myfile.txt"</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Relative paths</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>relative_path <span class="op">=</span> Path(<span class="st">"data/file.txt"</span>)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(posix_path)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(windows_path)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(relative_path)</span></code></pre></div>
<p>The constructor automatically handles the appropriate path separators for the operating system.</p>
<h3 id="creating-paths-from-other-paths">Creating Paths from other Paths</h3>
<p>You can create new <code>Path</code> objects from existing ones using path manipulation methods. For example, you can create a new path by combining an existing path with a new component using the <code>/</code> operator or the <code>joinpath()</code> method:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>base_path <span class="op">=</span> Path(<span class="st">"/tmp"</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>new_file <span class="op">=</span> base_path <span class="op">/</span> <span class="st">"my_new_file.txt"</span>  <span class="co"># Using the / operator</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>another_file <span class="op">=</span> base_path.joinpath(<span class="st">"another_file.txt"</span>) <span class="co"># Using joinpath()</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(new_file)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(another_file)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">#Creating subdirectories</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>directory <span class="op">=</span> Path(<span class="st">"/tmp/mydir"</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>subdirectory <span class="op">=</span> directory <span class="op">/</span> <span class="st">"subdir1"</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>subdirectory.mkdir(parents<span class="op">=</span><span class="va">True</span>, exist_ok<span class="op">=</span><span class="va">True</span>) <span class="co"># Creates both mydir and subdir1 if they do not already exist</span></span></code></pre></div>
<p>The <code>parents=True</code> argument to <code>mkdir()</code> ensures that parent directories are created if they do not exist, and <code>exist_ok=True</code> prevents errors if the directory already exists.</p>
<h3 id="joining-paths">Joining Paths</h3>
<p>The <code>/</code> operator and the <code>joinpath()</code> method are primarily used for joining paths. They intelligently handle path separators and ensure that the resulting path is correctly formatted:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>path1 <span class="op">=</span> Path(<span class="st">"/tmp"</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>path2 <span class="op">=</span> Path(<span class="st">"data"</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>path3 <span class="op">=</span> Path(<span class="st">"file.txt"</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>joined_path <span class="op">=</span> path1 <span class="op">/</span> path2 <span class="op">/</span> path3</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(joined_path) <span class="co"># Output: /tmp/data/file.txt (or equivalent for your OS)</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>joined_path_2 <span class="op">=</span> path1.joinpath(path2,path3)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(joined_path_2) <span class="co"># Output: /tmp/data/file.txt (or equivalent for your OS)</span></span></code></pre></div>
<h3 id="resolving-paths">Resolving Paths</h3>
<p>The <code>resolve()</code> method converts a relative path to an absolute path. It takes into account symbolic links and resolves them to their ultimate target, making the resulting path fully qualified.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>relative_path <span class="op">=</span> Path(<span class="st">"my_file.txt"</span>) <span class="co"># relative to the current working directory</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>absolute_path <span class="op">=</span> relative_path.resolve()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(absolute_path) <span class="co"># Prints the absolute path of my_file.txt</span></span></code></pre></div>
<p>Note that <code>resolve()</code> needs to know the current working directory, and may fail if it cannot determine the absolute path (e.g., due to symbolic links that cannot be fully resolved). In such cases, you might see the original relative path returned instead of an absolute path.</p>
<h2 id="path-manipulation">Path Manipulation</h2>
<h3 id="getting-path-components">Getting Path Components</h3>
<p><code>pathlib</code> provides attributes and methods to access individual components of a path:</p>
<ul>
<li><strong><code>parts</code>:</strong> A tuple containing all path components.</li>
<li><strong><code>name</code>:</strong> The final component of the path (filename or directory name).</li>
<li><strong><code>stem</code>:</strong> The filename without the suffix (extension).</li>
<li><strong><code>suffix</code>:</strong> The file extension (including the leading dot).</li>
<li><strong><code>suffixes</code>:</strong> A list of all suffixes (extensions) if there are multiple.</li>
<li><strong><code>parent</code>:</strong> The parent directory of the path.</li>
<li><strong><code>drive</code>:</strong> (Windows only) The drive letter.</li>
</ul>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path(<span class="st">"/tmp/my_file.txt"</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Parts: </span><span class="sc">{</span>path<span class="sc">.</span>parts<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Name: </span><span class="sc">{</span>path<span class="sc">.</span>name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Stem: </span><span class="sc">{</span>path<span class="sc">.</span>stem<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Suffix: </span><span class="sc">{</span>path<span class="sc">.</span>suffix<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Suffixes: </span><span class="sc">{</span>path<span class="sc">.</span>suffixes<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Parent: </span><span class="sc">{</span>path<span class="sc">.</span>parent<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Drive: </span><span class="sc">{</span>path<span class="sc">.</span>drive<span class="sc">}</span><span class="ss">"</span>) <span class="co"># Output will be empty on POSIX systems</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>path2 <span class="op">=</span> Path(<span class="st">"C:/Users/User/Documents/my_report.csv.gz"</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Suffixes of path2: </span><span class="sc">{</span>path2<span class="sc">.</span>suffixes<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div>
<h3 id="modifying-path-components">Modifying Path Components</h3>
<p>While you can create new paths by combining existing ones (as described in the “Creating Paths” section), <code>pathlib</code> doesn’t directly provide methods to modify components of an existing <code>Path</code> object <em>in place</em>. Instead, you create a new <code>Path</code> object with the desired modifications:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path(<span class="st">"/tmp/my_file.txt"</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>new_path <span class="op">=</span> path.with_name(<span class="st">"new_file.csv"</span>) <span class="co"># Changes the filename and extension</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Original path: </span><span class="sc">{</span>path<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"New path: </span><span class="sc">{</span>new_path<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>new_path2 <span class="op">=</span> path.with_suffix(<span class="st">".csv"</span>) <span class="co"># Changes only the extension</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"New path2: </span><span class="sc">{</span>new_path2<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div>
<h3 id="working-with-suffixes-and-prefixes">Working with suffixes and prefixes</h3>
<p>Besides changing suffixes as shown above, you can check for suffixes and prefixes:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path(<span class="st">"/tmp/my_file.txt"</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(path.match(<span class="st">"*.txt"</span>)) <span class="co">#Returns True if the path matches the pattern</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(path.match(<span class="st">"*.csv"</span>)) <span class="co">#Returns False</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>path2 <span class="op">=</span> Path(<span class="st">"/tmp/my_report.csv.gz"</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(path2.suffixes)</span></code></pre></div>
<h3 id="normalization">Normalization</h3>
<p>The <code>resolve()</code> method (already discussed in “Creating Paths”) normalizes paths to their canonical form, handling symbolic links and resolving relative paths to absolute ones. Additionally, <code>path.resolve()</code> eliminates redundant path separators and up-level references (<code>..</code>).</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path(<span class="st">"/tmp/../tmp/./my_file.txt"</span>) <span class="co"># Redundant separators and '..'</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>normalized_path <span class="op">=</span> path.resolve()</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Original path: </span><span class="sc">{</span>path<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Normalized path: </span><span class="sc">{</span>normalized_path<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div>
<p>The <code>absolute()</code> method is similar, but does not resolve symlinks.</p>
<h3 id="iteration">Iteration</h3>
<p><code>Path</code> objects representing directories can be iterated over to access their contents:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>directory <span class="op">=</span> Path(<span class="st">"./my_directory"</span>) <span class="co">#Make sure my_directory exists</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>directory.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>) <span class="co">#Create directory if it doesn't exist</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>(directory <span class="op">/</span> <span class="st">"file1.txt"</span>).touch()</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>(directory <span class="op">/</span> <span class="st">"file2.txt"</span>).touch()</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> directory.iterdir():</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> directory.glob(<span class="st">"*.txt"</span>): <span class="co">#Use glob for pattern matching</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> directory.rglob(<span class="st">"*"</span>): <span class="co"># Use rglob for recursive search</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)</span></code></pre></div>
<p><code>iterdir()</code> yields all immediate children, <code>glob()</code> provides pattern matching within the current directory, and <code>rglob()</code> performs recursive globbing through subdirectories. Remember to handle exceptions properly, as <code>iterdir()</code> and related methods can raise exceptions if the directory does not exist or if access is denied.</p>
<h2 id="file-system-operations">File System Operations</h2>
<h3 id="checking-file-existence">Checking File Existence</h3>
<p>The <code>exists()</code> method checks if a file or directory exists:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>file_path <span class="op">=</span> Path(<span class="st">"./my_file.txt"</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> file_path.exists():</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"File exists!"</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"File does not exist."</span>)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="co">#Check if a directory exists</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>directory_path <span class="op">=</span> Path(<span class="st">"./my_directory"</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> directory_path.is_dir() <span class="kw">and</span> directory_path.exists():</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Directory exists!"</span>)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Directory does not exist."</span>)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p><code>is_file()</code> and <code>is_dir()</code> can be used for more specific checks.</p>
<h3 id="creating-files-and-directories">Creating Files and Directories</h3>
<ul>
<li><code>touch()</code> creates an empty file.</li>
<li><code>mkdir()</code> creates a directory. The <code>parents=True</code> argument creates parent directories if they don’t exist, and <code>exist_ok=True</code> prevents an error if the directory already exists.</li>
</ul>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>file_path <span class="op">=</span> Path(<span class="st">"./new_file.txt"</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>file_path.touch()</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>directory_path <span class="op">=</span> Path(<span class="st">"./new_directory/subdir"</span>)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>directory_path.mkdir(parents<span class="op">=</span><span class="va">True</span>, exist_ok<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<h3 id="deleting-files-and-directories">Deleting Files and Directories</h3>
<ul>
<li><code>unlink()</code> deletes a file.</li>
<li><code>rmdir()</code> deletes an empty directory.</li>
<li><code>rmtree()</code> recursively deletes a directory and all its contents. Use with caution!</li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>file_path <span class="op">=</span> Path(<span class="st">"./new_file.txt"</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>file_path.unlink()</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>empty_directory <span class="op">=</span> Path(<span class="st">"./empty_directory"</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>empty_directory.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>empty_directory.rmdir()</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Be extremely careful when using rmtree:</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>recursive_directory <span class="op">=</span> Path(<span class="st">"./recursive_dir"</span>)</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>recursive_directory.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>(recursive_directory<span class="op">/</span><span class="st">"file_in_subdir"</span>).touch()</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="co">#recursive_directory.rmtree() # Uncomment to delete recursively.  Use with caution!</span></span></code></pre></div>
<h3 id="renaming-files-and-directories">Renaming Files and Directories</h3>
<p><code>rename()</code> renames a file or directory:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>source_path <span class="op">=</span> Path(<span class="st">"./my_file.txt"</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>source_path.touch()</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>destination_path <span class="op">=</span> Path(<span class="st">"./renamed_file.txt"</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>source_path.rename(destination_path)</span></code></pre></div>
<h3 id="copying-files-and-directories">Copying Files and Directories</h3>
<ul>
<li><code>copy()</code> copies a file.</li>
<li><code>copytree()</code> recursively copies a directory and its contents.</li>
</ul>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>source_file <span class="op">=</span> Path(<span class="st">"./my_file.txt"</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>source_file.touch()</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>destination_file <span class="op">=</span> Path(<span class="st">"./copied_file.txt"</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>source_file.copy(destination_file)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co">#For directories use copytree</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>source_dir <span class="op">=</span> Path(<span class="st">"./source_dir"</span>)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>source_dir.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>(source_dir <span class="op">/</span> <span class="st">"file1.txt"</span>).touch()</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>destination_dir <span class="op">=</span> Path(<span class="st">"./destination_dir"</span>)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>shutil.copytree(source_dir, destination_dir) <span class="co">#Requires shutil module</span></span></code></pre></div>
<p>Note that <code>copytree</code> requires the <code>shutil</code> module.</p>
<h3 id="moving-files-and-directories">Moving Files and Directories</h3>
<p><code>replace()</code> moves (renames) a file or directory. If the destination exists, it will be overwritten. <code>rename()</code> is generally preferred for simple renaming unless overwrite is needed.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>source_path <span class="op">=</span> Path(<span class="st">"./my_file.txt"</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>source_path.touch()</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>destination_path <span class="op">=</span> Path(<span class="st">"./moved_file.txt"</span>)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>source_path.replace(destination_path)</span></code></pre></div>
<h3 id="getting-file-information-size-modification-time-etc.">Getting File Information (size, modification time, etc.)</h3>
<ul>
<li><code>stat()</code> returns a <code>stat</code> object containing various file information (size, modification time, etc.).</li>
<li><code>lstat()</code> is similar to <code>stat()</code> but doesn’t follow symbolic links.</li>
<li><code>exists()</code>, <code>is_file()</code>, <code>is_dir()</code> can be used for basic checks.</li>
</ul>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>file_path <span class="op">=</span> Path(<span class="st">"./my_file.txt"</span>)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>file_path.touch()</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>file_info <span class="op">=</span> file_path.stat()</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"File size: </span><span class="sc">{</span>file_info<span class="sc">.</span>st_size<span class="sc">}</span><span class="ss"> bytes"</span>)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Last modified time: </span><span class="sc">{</span>time<span class="sc">.</span>ctime(file_info.st_mtime)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Is file: </span><span class="sc">{</span>file_info<span class="sc">.</span>st_mode<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div>
<h3 id="globbing-finding-files-matching-patterns">Globbing (finding files matching patterns)</h3>
<p>The <code>glob()</code> and <code>rglob()</code> methods find files matching specified patterns:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> glob</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create some files for testing</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>(Path(<span class="st">"./my_dir"</span>) <span class="op">/</span> <span class="st">"file1.txt"</span>).touch()</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>(Path(<span class="st">"./my_dir"</span>) <span class="op">/</span> <span class="st">"image.jpg"</span>).touch()</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>(Path(<span class="st">"./my_dir"</span>) <span class="op">/</span> <span class="st">"file2.txt"</span>).touch()</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> file_path <span class="kw">in</span> Path(<span class="st">"./my_dir"</span>).glob(<span class="st">"*.txt"</span>):</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(file_path)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> file_path <span class="kw">in</span> Path(<span class="st">"./my_dir"</span>).rglob(<span class="st">"*"</span>): <span class="co"># Recursive glob</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(file_path)</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Using glob module for comparison</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> file_path <span class="kw">in</span> glob.glob(<span class="st">"./my_dir/*.txt"</span>):</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(file_path)</span></code></pre></div>
<p><code>glob()</code> searches only the current directory, while <code>rglob()</code> recursively searches subdirectories. The <code>glob</code> module (part of Python’s standard library) provides similar functionality but with string-based path manipulation. <code>pathlib</code>’s methods are generally preferred for better readability and type safety.</p>
<h2 id="working-with-directories">Working with Directories</h2>
<h3 id="listing-directory-contents">Listing Directory Contents</h3>
<p>The <code>listdir()</code> method returns a list of the names (as <code>Path</code> objects) of files and subdirectories within a directory:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>my_dir <span class="op">=</span> Path(<span class="st">"./my_directory"</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>my_dir.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>(my_dir <span class="op">/</span> <span class="st">"file1.txt"</span>).touch()</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>(my_dir <span class="op">/</span> <span class="st">"subdir"</span>).mkdir()</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>contents <span class="op">=</span> <span class="bu">list</span>(my_dir.iterdir()) <span class="co">#or list(my_dir.listdir())</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> contents:</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)</span></code></pre></div>
<p>Note that <code>iterdir()</code> is generally preferred for better memory efficiency in cases with many files, as it yields items one at a time rather than creating a full list in memory.</p>
<h3 id="creating-directories">Creating Directories</h3>
<p>The <code>mkdir()</code> method creates a directory. The <code>parents=True</code> argument creates any necessary parent directories, and <code>exist_ok=True</code> prevents an error if the directory already exists.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>dir_to_create <span class="op">=</span> Path(<span class="st">"./new_directory/subdir1/subdir2"</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>dir_to_create.mkdir(parents<span class="op">=</span><span class="va">True</span>, exist_ok<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<h3 id="removing-directories">Removing Directories</h3>
<ul>
<li><code>rmdir()</code> removes an empty directory. It will raise an exception if the directory is not empty.</li>
<li><code>rmtree()</code> recursively removes a directory and all its contents. Use with extreme caution!</li>
</ul>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> shutil</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>empty_dir <span class="op">=</span> Path(<span class="st">"./empty_dir"</span>)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>empty_dir.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>empty_dir.rmdir()</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="co">#Recursive Removal - Use with extreme caution!</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>recursive_dir <span class="op">=</span> Path(<span class="st">"./recursive_dir"</span>)</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>recursive_dir.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>(recursive_dir <span class="op">/</span> <span class="st">"file1.txt"</span>).touch()</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>(recursive_dir <span class="op">/</span> <span class="st">"subdir"</span> <span class="op">/</span> <span class="st">"file2.txt"</span>).mkdir(parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a><span class="co">#shutil.rmtree(recursive_dir) #Uncomment to delete recursively</span></span></code></pre></div>
<p>Note that <code>rmtree()</code> requires the <code>shutil</code> module for recursive deletion. Always double-check before using <code>rmtree()</code> to avoid accidental data loss.</p>
<h3 id="iterating-over-directories">Iterating over Directories</h3>
<p>The <code>iterdir()</code> method provides an iterator that yields <code>Path</code> objects for each item (file or subdirectory) within a directory. This is generally preferred over <code>listdir()</code> for large directories as it avoids loading all the file names into memory at once.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>my_dir <span class="op">=</span> Path(<span class="st">"./my_directory"</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>my_dir.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>(my_dir <span class="op">/</span> <span class="st">"file1.txt"</span>).touch()</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>(my_dir <span class="op">/</span> <span class="st">"subdir"</span>).mkdir()</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> my_dir.iterdir():</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)</span></code></pre></div>
<h3 id="walking-directory-trees">Walking Directory Trees</h3>
<p>For recursively traversing a directory tree, <code>os.walk()</code> from the <code>os</code> module is commonly used and still very efficient, though pathlib’s <code>rglob</code> can be used for pattern-based traversal:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>root_dir <span class="op">=</span> Path(<span class="st">"./my_large_directory"</span>)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>root_dir.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>(root_dir <span class="op">/</span> <span class="st">"subdir1"</span> <span class="op">/</span> <span class="st">"file1.txt"</span>).touch()</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>(root_dir <span class="op">/</span> <span class="st">"subdir2"</span> <span class="op">/</span> <span class="st">"file2.txt"</span>).touch()</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="co">#Using os.walk:</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> root, dirs, files <span class="kw">in</span> os.walk(root_dir):</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Root:"</span>, root)</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Dirs:"</span>, dirs)</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Files:"</span>, files)</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="co">#Using pathlib's rglob for pattern matching:</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> root_dir.rglob(<span class="st">"*"</span>):</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(item)</span></code></pre></div>
<p><code>os.walk()</code> provides more detailed information (root directory, subdirectories, files), while <code>rglob()</code> is more concise if you only need to process files that match a certain pattern. Choose the approach best suited to your specific needs. For simple iteration through all items in subdirectories, <code>rglob()</code> is often more convenient. If you need more control over the traversal process or information, <code>os.walk()</code> offers greater flexibility.</p>
<h2 id="advanced-usage">Advanced Usage</h2>
<h3 id="symbolic-links">Symbolic Links</h3>
<p><code>pathlib</code> handles symbolic links differently depending on the method used. <code>resolve()</code> follows symbolic links and returns the final target path. <code>stat()</code> and <code>lstat()</code> provide different information when dealing with symbolic links; <code>stat()</code> reports information about the target of the symbolic link, while <code>lstat()</code> reports information about the link itself.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a symbolic link (replace with your OS-specific command if needed)</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>link_path <span class="op">=</span> Path(<span class="st">"./my_link"</span>)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>target_path <span class="op">=</span> Path(<span class="st">"./my_target.txt"</span>)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>target_path.touch()</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>os.symlink(target_path, link_path)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Link path: </span><span class="sc">{</span>link_path<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Resolved link path: </span><span class="sc">{</span>link_path<span class="sc">.</span>resolve()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Link stat: </span><span class="sc">{</span>link_path<span class="sc">.</span>lstat()<span class="sc">}</span><span class="ss">"</span>) <span class="co"># Information about the link itself</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Target stat: </span><span class="sc">{</span>link_path<span class="sc">.</span>stat()<span class="sc">}</span><span class="ss">"</span>) <span class="co"># Information about the target file</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<h3 id="handling-errors">Handling Errors</h3>
<p>File system operations can raise exceptions (e.g., <code>FileNotFoundError</code>, <code>PermissionError</code>, <code>OSError</code>). It’s crucial to handle these exceptions appropriately using <code>try...except</code> blocks:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>file_path <span class="op">=</span> Path(<span class="st">"./nonexistent_file.txt"</span>)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    file_path.unlink()</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">FileNotFoundError</span>:</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"File not found."</span>)</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">PermissionError</span>:</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Permission denied."</span>)</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">OSError</span> <span class="im">as</span> e:</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"An OS error occurred: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div>
<p>Always anticipate potential errors and handle them gracefully to prevent your program from crashing. Consider using more specific exception handling when possible to pinpoint the type of error that occurred.</p>
<h3 id="performance-optimization">Performance Optimization</h3>
<p>For performance-critical operations on many files or directories, consider these optimizations:</p>
<ul>
<li><strong>Use iterators:</strong> <code>iterdir()</code>, <code>rglob()</code>, etc., return iterators, reducing memory usage compared to creating lists directly.</li>
<li><strong>Avoid unnecessary operations:</strong> Don’t perform redundant checks or calculations within loops.</li>
<li><strong>Batch operations:</strong> When possible, perform multiple file system operations in a single batch (e.g., creating multiple directories at once).</li>
<li><strong>Use appropriate modules:</strong> For specific tasks (like copying large directories), use optimized modules like <code>shutil</code> for better performance.</li>
</ul>
<p>Example of using iterators:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>large_directory <span class="op">=</span> Path(<span class="st">"./my_large_directory"</span>)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>large_directory.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="co"># inefficient way (creates a list in memory):</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="co">#files = list(large_directory.glob("*"))</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="co">#for file in files:</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="co">#   # Process file...</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="co">#Efficient way (uses an iterator):</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> large_directory.glob(<span class="st">"*"</span>):</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Process file...</span></span></code></pre></div>
<h3 id="integration-with-other-modules">Integration with other modules</h3>
<p><code>pathlib</code> integrates well with other Python modules:</p>
<ul>
<li><strong><code>shutil</code>:</strong> For advanced file operations (copying, moving, archiving, etc.).</li>
<li><strong><code>os</code>:</strong> For lower-level file system operations.</li>
<li><strong><code>glob</code>:</strong> For pattern matching.</li>
<li><strong><code>gzip</code>, <code>bz2</code>, <code>zipfile</code>:</strong> For working with compressed files.</li>
</ul>
<p>Example using <code>shutil</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> shutil</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>source_dir <span class="op">=</span> Path(<span class="st">"./source_directory"</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>source_dir.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>(source_dir <span class="op">/</span> <span class="st">"my_file.txt"</span>).touch()</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>destination_dir <span class="op">=</span> Path(<span class="st">"./destination_directory"</span>)</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>shutil.copytree(source_dir, destination_dir)  <span class="co"># Efficiently copies the directory</span></span></code></pre></div>
<p>Combining <code>pathlib</code> with these modules allows you to write more powerful and efficient file system manipulation code while benefiting from <code>pathlib</code>’s improved readability and error handling.</p>
<h2 id="examples-and-best-practices">Examples and Best Practices</h2>
<h3 id="common-use-cases">Common Use Cases</h3>
<p>Here are some common use cases for <code>pathlib</code>, illustrating best practices:</p>
<p><strong>1. Checking file existence and type:</strong></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>file_path <span class="op">=</span> Path(<span class="st">"./my_data.txt"</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> file_path.exists() <span class="kw">and</span> file_path.is_file():</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"File exists and is a regular file."</span>)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> file_path.exists() <span class="kw">and</span> file_path.is_dir():</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"File exists and is a directory."</span>)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"File does not exist."</span>)</span></code></pre></div>
<p><strong>2. Creating directories and files:</strong></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>output_dir <span class="op">=</span> Path(<span class="st">"./output_data"</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>output_dir.mkdir(parents<span class="op">=</span><span class="va">True</span>, exist_ok<span class="op">=</span><span class="va">True</span>)  <span class="co"># Create directory, parents if needed, no error if exists</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>output_file <span class="op">=</span> output_dir <span class="op">/</span> <span class="st">"results.txt"</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>output_file.touch()  <span class="co"># Create an empty file</span></span></code></pre></div>
<p><strong>3. Processing files in a directory:</strong></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>data_dir <span class="op">=</span> Path(<span class="st">"./data"</span>)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> file_path <span class="kw">in</span> data_dir.glob(<span class="st">"*.txt"</span>):  <span class="co"># Efficiently process only .txt files</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(file_path, <span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Process file contents</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span></code></pre></div>
<p><strong>4. Working with file paths relative to the script:</strong></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>script_dir <span class="op">=</span> Path(<span class="va">__file__</span>).parent <span class="co"># Get the directory of the current script</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>data_file <span class="op">=</span> script_dir <span class="op">/</span> <span class="st">"data.csv"</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> data_file.exists():</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Process data_file</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span></code></pre></div>
<h3 id="coding-style-guidelines">Coding Style Guidelines</h3>
<ul>
<li><strong>Use <code>Path</code> objects:</strong> Always use <code>Path</code> objects instead of string manipulation for file paths.</li>
<li><strong>Be explicit:</strong> Use methods like <code>is_file()</code>, <code>is_dir()</code>, etc., for clarity.</li>
<li><strong>Handle errors:</strong> Use <code>try...except</code> blocks to handle potential exceptions.</li>
<li><strong>Keep it concise:</strong> Utilize <code>pathlib</code>’s methods for chaining operations when possible.</li>
<li><strong>Use descriptive variable names:</strong> Choose names that clearly indicate the purpose of each path object.</li>
</ul>
<h3 id="error-handling-examples">Error Handling Examples</h3>
<p><strong>1. Handling <code>FileNotFoundError</code>:</strong></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>file_path <span class="op">=</span> Path(<span class="st">"./my_file.txt"</span>)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> file_path.<span class="bu">open</span>(<span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>        contents <span class="op">=</span> f.read()</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">FileNotFoundError</span>:</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Error: File '</span><span class="sc">{</span>file_path<span class="sc">}</span><span class="ss">' not found."</span>)</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Handle the error appropriately (e.g., create the file, use default values, etc.)</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p><strong>2. Handling <code>PermissionError</code>:</strong></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>file_path <span class="op">=</span> Path(<span class="st">"./protected_file.txt"</span>) <span class="co">#Assume this file has restricted access</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    file_path.unlink()</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">PermissionError</span>:</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Error: Permission denied when trying to delete '</span><span class="sc">{</span>file_path<span class="sc">}</span><span class="ss">'."</span>)</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Handle the error appropriately (e.g., log the error, request administrative privileges, etc.)</span></span></code></pre></div>
<h3 id="advanced-examples">Advanced Examples</h3>
<p><strong>1. Recursive directory copying with error handling:</strong></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> shutil</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>source_dir <span class="op">=</span> Path(<span class="st">"./source_dir"</span>)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>source_dir.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>(source_dir <span class="op">/</span> <span class="st">"file1.txt"</span>).touch()</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>destination_dir <span class="op">=</span> Path(<span class="st">"./dest_dir"</span>)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    shutil.copytree(source_dir, destination_dir)</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">OSError</span> <span class="im">as</span> e:</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Error copying directory: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div>
<p><strong>2. Processing files based on pattern matching:</strong></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>image_dir <span class="op">=</span> Path(<span class="st">"./images"</span>)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>image_dir.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>(image_dir <span class="op">/</span> <span class="st">"image1.jpg"</span>).touch()</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>(image_dir <span class="op">/</span> <span class="st">"image2.png"</span>).touch()</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>(image_dir <span class="op">/</span> <span class="st">"report.txt"</span>).touch()</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> image_file <span class="kw">in</span> image_dir.glob(<span class="st">"*.jpg"</span>):</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Processing JPG image: </span><span class="sc">{</span>image_file<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Add your image processing code here</span></span></code></pre></div>
<p>These examples demonstrate how to use <code>pathlib</code> effectively, incorporating best practices for error handling, and utilizing advanced features for more complex file system operations. Remember to adapt these examples to your specific use cases and always prioritize robust error handling.</p>
<h2 id="appendix-reference">Appendix: Reference</h2>
<h3 id="path-methods-and-attributes">Path methods and attributes</h3>
<p>This section provides a concise reference to commonly used <code>pathlib</code> methods and attributes. For a complete list, refer to the official Python documentation. Note that some methods may not be available on <code>PurePath</code> objects (which only perform path manipulation without file system access).</p>
<p><strong>Path Creation and Manipulation:</strong></p>
<ul>
<li><code>Path(path)</code>: Creates a <code>Path</code> object from a string path.</li>
<li><code>__truediv__(other)</code> / <code>/</code>: Joins paths. <code>path / "subdir" / "file.txt"</code></li>
<li><code>joinpath(*paths)</code>: Joins multiple paths.</li>
<li><code>with_name(name)</code>: Returns a new <code>Path</code> object with a different name.</li>
<li><code>with_suffix(suffix)</code>: Returns a new <code>Path</code> object with a different suffix.</li>
<li><code>parent</code>: The parent directory.</li>
<li><code>parts</code>: A tuple of path components.</li>
<li><code>name</code>: The name of the last path component.</li>
<li><code>stem</code>: The filename without the suffix.</li>
<li><code>suffix</code>: The file extension (including the dot).</li>
<li><code>suffixes</code>: A list of all suffixes.</li>
<li><code>drive</code> (Windows only): The drive letter.</li>
<li><code>as_posix()</code>: Returns a string representation using POSIX-style path separators.</li>
<li><code>as_uri()</code>: Returns a URI representation of the path.</li>
<li><code>resolve()</code>: Resolves a path to its absolute form, following symbolic links.</li>
<li><code>absolute()</code>: Returns the absolute path without resolving symbolic links.</li>
<li><code>is_absolute()</code>: Checks if a path is absolute.</li>
<li><code>is_relative_to(path)</code>: Checks if the path is relative to a given path.</li>
</ul>
<p><strong>File System Operations:</strong></p>
<ul>
<li><code>exists()</code>: Checks if a path exists.</li>
<li><code>is_dir()</code>: Checks if a path is a directory.</li>
<li><code>is_file()</code>: Checks if a path is a regular file.</li>
<li><code>is_symlink()</code>: Checks if a path is a symbolic link.</li>
<li><code>mkdir(*, exist_ok=False, parents=False)</code>: Creates a directory.</li>
<li><code>rmdir()</code>: Removes an empty directory.</li>
<li><code>unlink()</code>: Deletes a file.</li>
<li><code>rename(target)</code>: Renames a file or directory.</li>
<li><code>replace(target)</code>: Replaces a file or directory (moves and overwrites).</li>
<li><code>touch()</code>: Creates an empty file.</li>
<li><code>stat()</code>: Gets file information (size, modification time, etc.).</li>
<li><code>lstat()</code>: Gets file information without following symbolic links.</li>
<li><code>open(mode='r', encoding=None, errors=None)</code>: Opens a file.</li>
<li><code>read_bytes()</code>: Reads file content as bytes.</li>
<li><code>read_text(encoding=None, errors=None)</code>: Reads file content as text.</li>
<li><code>write_bytes(data)</code>: Writes bytes to a file.</li>
<li><code>write_text(data, encoding=None, errors=None)</code>: Writes text to a file.</li>
<li><code>iterdir()</code>: Iterates over items in a directory.</li>
<li><code>glob(pattern)</code>: Returns an iterator for files matching a pattern.</li>
<li><code>rglob(pattern)</code>: Recursively returns an iterator for files matching a pattern.</li>
<li><code>match(pattern)</code>: Checks if the path matches a given pattern.</li>
</ul>
<p><strong>Other methods:</strong></p>
<ul>
<li><code>chmod(mode)</code>: Changes file permissions.</li>
<li><code>expanduser()</code>: Expands <code>~</code> to the user’s home directory.</li>
<li><code>samefile(other)</code>: Checks if two paths refer to the same file.</li>
</ul>
<h3 id="exceptions">Exceptions</h3>
<p><code>pathlib</code> and its underlying operating system functions can raise various exceptions. Handling these exceptions is crucial for robust code.</p>
<ul>
<li><code>FileNotFoundError</code>: Raised when trying to access a file or directory that doesn’t exist.</li>
<li><code>IsADirectoryError</code>: Raised when trying to perform a file operation on a directory.</li>
<li><code>NotADirectoryError</code>: Raised when trying to perform a directory operation on a file.</li>
<li><code>PermissionError</code>: Raised when the user lacks sufficient permissions to perform an operation.</li>
<li><code>FileExistsError</code>: Raised when trying to create a file or directory that already exists.</li>
<li><code>OSError</code>: A general error raised by the operating system. Provides more context through its <code>.strerror</code> and <code>.errno</code> attributes. This is a broad category and specific sub-exceptions may be more useful to catch individually for cleaner error handling.</li>
<li><code>BlockingIOError</code>: Raised if I/O operations are blocked.</li>
<li><code>BrokenPipeError</code>: Raised if there is a broken pipe during I/O.</li>
<li><code>InterruptedError</code>: Raised if the operation was interrupted.</li>
<li><code>ChildProcessError</code>: Raised if a child process fails during I/O.</li>
<li><code>ConnectionAbortedError</code>: Raised if a network connection is aborted.</li>
<li><code>ConnectionRefusedError</code>: Raised if a network connection is refused.</li>
<li><code>ConnectionResetError</code>: Raised if a network connection is reset.</li>
</ul>
<p>It is recommended to catch exceptions as specifically as possible to handle errors in a targeted and informative manner. For instance, catching <code>FileNotFoundError</code> specifically provides a much clearer indication of the problem than catching the generic <code>OSError</code>.</p>


<footer>Copyright 2025 - Muthukrishnan</footer>
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561" crossorigin="anonymous"></script>




</body></html>