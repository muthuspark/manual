{"title":"React-Intl - Documentation","markdown":{"yaml":{"title":"React-Intl - Documentation","categories":["JavaScript Libraries and Functions"]},"headingText":"What is React Intl?","containsRefs":false,"markdown":"\n\n\n\nReact Intl is a JavaScript library built on top of the `Intl` object provided by modern browsers and Node.js. It provides a simple, powerful, and efficient way to internationalize (i18n) and localize (l10n) React applications.  This means it helps you build applications that can be easily adapted to different languages and cultural conventions, displaying dates, numbers, currencies, and text appropriately for each locale.  Instead of manually managing translations and formatting, React Intl handles the complexities, leaving you to focus on building your application's core features.\n\n\n### Why use React Intl?\n\nUsing React Intl offers several key advantages:\n\n* **Simplified Internationalization:**  It abstracts away the complexities of dealing with different locales and formatting rules, making internationalization significantly easier than manual implementation.\n* **Improved Developer Experience:**  React Intl provides a declarative API that integrates seamlessly with React's component model, leading to cleaner and more maintainable code.\n* **Performance:** It leverages the browser's built-in `Intl` APIs for optimal performance, avoiding the overhead of external libraries for common formatting tasks.\n* **Comprehensive Support:** It supports a wide range of formatting options including dates, times, numbers, currencies, relative time, and pluralization, ensuring your application adapts correctly to diverse linguistic and cultural contexts.\n* **Message Formatting:** It efficiently handles message formatting with placeholders, providing robust support for translating complex sentences while handling potential security concerns related to user-supplied data within messages.\n\n\n### Setting up React Intl\n\nSetting up React Intl in your project is straightforward.  First, install the necessary package:\n\n```bash\nnpm install react-intl\n```\n\nor\n\n```bash\nyarn add react-intl\n```\n\nNext, import and use the necessary components within your React application.  The most common component is `<IntlProvider>`, which provides locale and messages to your application.  Example:\n\n\n```javascript\nimport { IntlProvider, FormattedMessage } from 'react-intl';\nimport messages from './messages'; // Your translation messages\n\nfunction MyComponent() {\n  return (\n    <IntlProvider locale=\"en\" messages={messages.en}>\n      <FormattedMessage id=\"greeting\" /> {/* Example usage */}\n    </IntlProvider>\n  );\n}\n```\n\nThis example requires a `messages.en` object containing your English translations (you'd typically have similar objects for other locales, e.g., `messages.es` for Spanish).  The `<FormattedMessage>` component looks up and renders the translation for the specified `id`.\n\nRemember to handle locale detection and switching (often based on user browser settings or explicit selection) to manage different languages effectively.\n\n### Core Concepts\n\nReact Intl revolves around several core concepts:\n\n* **Locale:** A specification of a region/language (e.g., \"en-US\", \"es-ES\", \"de\").  This determines the formatting rules and translation used.\n\n* **Messages:** A collection of translated strings, often organized by key (ID) for easy lookup.  These are typically loaded from JSON files or other data sources.\n\n* **Formatters:** Functions that handle the formatting of different data types based on the locale, including `NumberFormat`, `DateTimeFormat`, and `RelativeTimeFormat`.  These are accessible through React Intl's components.\n\n* **Components:** React components like `<IntlProvider>`, `<FormattedMessage>`, `<FormattedDate>`, `<FormattedNumber>`, `<FormattedTime>`, and `<FormattedRelative>` simplify the process of rendering localized content and handling various formatting needs.  These components leverage the formatters and locale information provided by `<IntlProvider>`.\n\n* **Pluralization and Gender:** React Intl supports handling plural forms of words and grammatical gender, ensuring your translations accurately reflect the context of the numbers and nouns used.\n\n\nUnderstanding these core concepts is crucial for effectively using React Intl to create robust and internationally-ready applications.\n\n\n## Formatting Messages\n\n### Using `FormattedMessage`\n\nThe `FormattedMessage` component is the cornerstone of translating text within your React application using React Intl. It allows you to display localized messages based on the locale provided by the `<IntlProvider>`.  You identify messages using a unique `id`, which maps to a key within your message catalog (e.g., a JSON object).\n\n**Basic Usage:**\n\n```javascript\nimport { FormattedMessage } from 'react-intl';\n\n// Assuming messages.en = {greeting: \"Hello!\"}\n<FormattedMessage id=\"greeting\" /> \n```\n\nThis will render \"Hello!\" if the locale is \"en\".\n\n**Adding placeholders (interpolation):**\n\nYou can use placeholders within your message strings to dynamically insert values.  These are indicated by `{placeholder}` within the message string.  You provide the values using the `values` prop:\n\n```javascript\n<FormattedMessage\n  id=\"welcomeMessage\"\n  values={{ name: 'John' }}\n/>\n```\n\nWith the message definition (in `messages.en` for example):\n\n```javascript\n\"welcomeMessage\": \"Welcome, {name}!\"\n```\n\nThis will render \"Welcome, John!\"\n\n**Handling HTML:**\n\nFor more complex scenarios, use the `defaultMessage` prop to handle messages that might not be present in all locales or for debugging.  You can also embed HTML using dangerouslySetInnerHTML, but remember to sanitize any user-provided data.  Directly embedding HTML within the `id` message is generally discouraged for security reasons.\n\n\n### Working with Plural Rules\n\nReact Intl handles pluralization automatically, ensuring correct grammatical agreement with numbers.  Use plural forms within your message strings, delineated using special syntax within your message catalog.  The specific syntax varies depending on your chosen pluralization library (often CLDR).\n\nExample (using a common syntax):\n\n```javascript\n\"apples\": \"{count, plural, =0 {No apples} one {One apple} other {# apples}}\"\n```\n\nThis message will render differently depending on the value of `{count}`:\n\n* 0: \"No apples\"\n* 1: \"One apple\"\n* 2+: \"{count} apples\"\n\n\n### Handling Gender and Selectors\n\nSimilar to pluralization, React Intl supports gendered messages.  These use a selector within the message string to choose the correct form based on a provided gender value.  The syntax varies depending on the locale and message format.\n\nExample (a common, but locale-dependent, syntax):\n\n```javascript\n\"greeting\": \"{gender, select, male {Hello, sir!} female {Hello, madam!} other {Hello!}}\"\n```\n\n\n### Using Number Formatting\n\nThe `<FormattedNumber>` component provides robust number formatting, adhering to locale-specific conventions for decimal separators, thousands separators, and currency symbols.\n\n```javascript\nimport { FormattedNumber } from 'react-intl';\n\n<FormattedNumber value={1234.56} style=\"currency\" currency=\"USD\" />\n```\n\n\n### Using Date and Time Formatting\n\nThe `<FormattedDate>` and `<FormattedTime>` components format dates and times according to locale conventions.  You can specify the desired format using the `value` (date object) and `dateStyle` or `timeStyle` props (e.g., 'short', 'medium', 'long', 'full').\n\n```javascript\nimport { FormattedDate, FormattedTime } from 'react-intl';\n\n<FormattedDate value={new Date()} />\n<FormattedTime value={new Date()} />\n```\n\nYou can also customize the formatting even more precisely using the `format` prop with ICU MessageFormat patterns.\n\n\n### Custom Formatting Functions\n\nFor highly customized formatting needs beyond what's offered by built-in components, you can create and use custom formatting functions.  These functions will receive the locale and the value to format.  You'd then integrate these custom functions within your React components, likely alongside `FormattedMessage`.  This is useful for highly specific formatting requirements not directly supported by the default formatters.\n\n\n## Internationalization Components\n\n### `FormattedDate`\n\nThe `FormattedDate` component renders a date according to the current locale. It uses the browser's built-in `Intl.DateTimeFormat` API for optimal performance and accuracy.\n\n**Props:**\n\n* `value` (required): A `Date` object representing the date to format.\n* `dateStyle`: A string specifying the date style (\"full\", \"long\", \"medium\", \"short\").  Defaults to \"medium\".\n* `timeStyle`: A string specifying the time style (\"full\", \"long\", \"medium\", \"short\").  If provided alongside `dateStyle`, combined date and time formatting is applied.\n* `format`:  An ICU MessageFormat pattern string for fine-grained control over the date/time formatting. Overrides `dateStyle` and `timeStyle`.\n\n\n**Example:**\n\n```javascript\nimport { FormattedDate } from 'react-intl';\n\n<FormattedDate value={new Date()} />  {/* Uses default 'medium' style */}\n<FormattedDate value={new Date()} dateStyle=\"long\" />\n<FormattedDate value={new Date()} dateStyle=\"short\" timeStyle=\"short\" />\n<FormattedDate value={new Date()} format=\"yyyy-MM-dd HH:mm:ss\" />\n```\n\n\n### `FormattedNumber`\n\nThe `FormattedNumber` component formats numbers according to the current locale's number formatting conventions, including decimal separators, grouping separators, and currency symbols.\n\n**Props:**\n\n* `value` (required): A number to format.\n* `style`: A string specifying the formatting style (\"decimal\", \"currency\", \"percent\"). Defaults to \"decimal\".\n* `currency`: A string specifying the currency code (e.g., \"USD\", \"EUR\") if `style` is \"currency\".\n* `currencyDisplay`:  A string specifying how to display the currency (\"symbol\", \"code\", \"name\"). Defaults to \"symbol\".\n* `minimumFractionDigits`, `maximumFractionDigits`, etc.:  Options for fine-tuning number formatting as per the `Intl.NumberFormat` API\n\n\n**Example:**\n\n```javascript\nimport { FormattedNumber } from 'react-intl';\n\n<FormattedNumber value={1234.56} />        {/* Decimal style */}\n<FormattedNumber value={1234.56} style=\"currency\" currency=\"USD\" /> {/* USD currency style */}\n<FormattedNumber value={0.75} style=\"percent\" />   {/* Percent style */}\n```\n\n\n### `FormattedTime`\n\nSimilar to `FormattedDate`, `FormattedTime` formats time values according to the current locale.\n\n**Props:**\n\n* `value` (required): A `Date` object.\n* `timeStyle`: A string specifying the time style (\"full\", \"long\", \"medium\", \"short\"). Defaults to \"medium\".\n* `format`: An ICU MessageFormat pattern string for precise time formatting. Overrides `timeStyle`.\n\n\n**Example:**\n\n```javascript\nimport { FormattedTime } from 'react-intl';\n\n<FormattedTime value={new Date()} />      {/* Uses default 'medium' style */}\n<FormattedTime value={new Date()} timeStyle=\"short\" />\n<FormattedTime value={new Date()} format=\"HH:mm:ss\" />\n```\n\n\n### `FormattedRelative`\n\n`FormattedRelative` displays a relative time representation (e.g., \"a few seconds ago\", \"2 hours ago\").  It's ideal for displaying timestamps in a user-friendly manner.\n\n**Props:**\n\n* `value` (required): A `Date` object representing the reference time.\n* `updateInterval`: (Optional) The update interval in milliseconds for automatically updating the relative time display.\n\n\n**Example:**\n\n```javascript\nimport { FormattedRelative } from 'react-intl';\n\n<FormattedRelative value={new Date(Date.now() - 3600000)} /> {/* One hour ago */}\n```\n\n\n### `FormattedPlural`\n\n`FormattedPlural` is used for displaying messages that vary depending on the quantity of items, handling plural forms correctly for the current locale.\n\n**Props:**\n\n* `value` (required): A number representing the quantity.\n* `one`, `two`, `few`, `many`, `other`:  Message strings for different plural categories (defined by the locale).  At least `other` must be specified.\n\n\n**Example (Illustrative, Actual plural rules depend on locale):**\n\n```javascript\nimport { FormattedPlural } from 'react-intl';\n\n<FormattedPlural value={2} one=\"One item\" other=\"{value} items\" />\n```\n\n\n### `FormattedList`\n\n`FormattedList` renders a list of items, applying locale-appropriate separators and conjunctions.\n\n**Props:**\n\n* `type`:  A string specifying the list type (\"unit\", \"unit-conjunction\", \"disjunction\").\n* `values`: An array of values to display.\n* `element`: The type of element to render, defaults to `<ul>`.  Can be set to e.g., `<ol>` for ordered lists.\n\n\n**Example:**\n\n```javascript\nimport { FormattedList } from 'react-intl';\n\n<FormattedList values={['apple', 'banana', 'orange']} />\n```\n\n\nNote:  The exact behavior and available options for these components might be subject to minor changes across different versions of React Intl. Always refer to the latest documentation for the most up-to-date information.\n\n\n## Working with Locale Data\n\n### Loading Locale Data\n\nReact Intl relies on locale data to perform accurate formatting and translation.  This data typically includes translations for messages, as well as rules for number, date, and time formatting.  You load this data in your application using different methods:\n\n* **Static JSON Files:** The most common approach is to create separate JSON files for each supported locale.  These files contain key-value pairs mapping message IDs to their translated text. You then load these files based on the detected or selected locale.\n\n  ```javascript\n  // messages.en.json\n  {\n    \"greeting\": \"Hello!\",\n    \"farewell\": \"Goodbye!\"\n  }\n\n  // messages.es.json\n  {\n    \"greeting\": \"¡Hola!\",\n    \"farewell\": \"¡Adiós!\"\n  }\n\n  // In your component:\n  import messagesEn from './messages.en.json';\n  import messagesEs from './messages.es.json';\n\n  const messages = locale === 'es' ? messagesEs : messagesEn;\n  ```\n\n* **Dynamic Loading:** For larger applications or when dealing with many locales, it might be more efficient to load locale data dynamically on demand.  This prevents loading unnecessary data initially. You could use `import()` to dynamically load the JSON files based on the selected locale.\n\n\n* **External APIs:** For very large scale applications, consider retrieving locale data from a centralized API, perhaps a Content Delivery Network (CDN) or a dedicated translation service.\n\n\n### Defining Custom Locales\n\nWhile React Intl supports a vast number of standard locales, you might need to define custom locales for less common languages or specific formatting requirements. This involves creating a custom locale object that conforms to the `Intl` API's specifications.  This is generally more complex and requires a deep understanding of locale data structures.\n\n\n### Locale Detection and Switching\n\nHandling locale detection and switching is crucial for a good user experience.  Common strategies include:\n\n* **Browser Locale:** Detect the user's preferred locale using the browser's `navigator.language` or `navigator.userLanguage` property.\n\n* **URL Parameters:** Allow users to explicitly specify the locale via a URL parameter (e.g., `example.com/?locale=es`).\n\n* **User Settings:** Provide a mechanism within your application for users to select their preferred locale and store this preference (e.g., using local storage or cookies).\n\n* **Combination:** Combine methods for robust locale determination, giving priority to explicit user selection over inferred browser locale.\n\n  ```javascript\n  const getLocale = () => {\n    const urlLocale = new URLSearchParams(window.location.search).get('locale');\n    return urlLocale || navigator.language || 'en';\n  };\n\n  // Update the locale state when necessary (e.g., using useState hook)\n  ```\n\n  You then use this locale to update the `IntlProvider` to reflect the user’s choice.\n\n\n### Using Different Number/Date/Time Systems\n\nReact Intl relies on the browser's built-in `Intl` API, which respects the locale's inherent number, date, and time formatting rules.  This means if a locale uses different number systems (like Arabic numerals versus Devanagari numerals) or different calendar systems (Gregorian vs. Islamic), React Intl will handle this automatically.  You don't need to explicitly configure this; it's determined by the locale you provide.  However, ensure your message catalogs and JSON files accurately reflect the conventions for the locale to avoid mismatches.\n\n\n## Advanced Usage\n\n### Using React Intl with Redux\n\nIntegrating React Intl with Redux involves managing the application's locale and messages within the Redux store.  This allows for centralized state management and easy sharing of locale information across different parts of the application.\n\n1. **Store Locale:**  Create a slice of your Redux store to hold the current locale.  Actions can be dispatched to change this locale.\n\n2. **Provide `<IntlProvider>`:** Wrap your main app component with the `<IntlProvider>`, passing the locale from the Redux store via a selector. You'll likely use `connect` from `react-redux` to connect your component to the store.\n\n3. **Dispatch Locale Changes:**  Dispatch actions to update the locale in the store whenever the user changes their preference.\n\nExample (conceptual):\n\n```javascript\n// Redux actions\nexport const setLocale = (locale) => ({ type: 'SET_LOCALE', locale });\n\n// Redux reducer\nconst reducer = (state = { locale: 'en' }, action) => {\n  switch (action.type) {\n    case 'SET_LOCALE':\n      return { ...state, locale: action.locale };\n    default:\n      return state;\n  }\n};\n\n// Connected component\nconst MyComponent = connect(state => ({ locale: state.locale }))(MyComponent);\n```\n\n\n### Internationalization of UI Components\n\nWhen internationalizing UI components, consider these best practices:\n\n* **Separate Messages:** Keep translation messages separate from component logic. This promotes maintainability and allows for easy updates.\n\n* **Component-Specific Messages:** Create message catalogs specific to each component, organizing your translations logically.\n\n* **Prop-Based Localization:** Pass locale and messages as props to your components.  Avoid hardcoding locale-specific values within components.\n\n* **Test Thoroughly:** Test your components with different locales to ensure consistent functionality and accurate translations.\n\n\n### Testing React Intl applications\n\nTesting React Intl applications requires careful consideration of how to manage the locale context during testing.\n\n* **Static Context:** Use the `IntlProvider` during testing with a static locale to ensure predictable behavior.\n\n* **Shallow Rendering:**  For unit tests, shallow rendering often suffices, especially when focusing on the component's logic separate from the formatting handled by React Intl components.\n\n* **Snapshot Testing:** Use snapshot testing with caution, since changes in formatting based on locale could lead to frequent snapshot updates.\n\n* **Integration Tests:**  For integration tests, you'll likely need a full rendering environment to test the interactions between React Intl and other parts of the application.\n\nExample using enzyme and a mocked `IntlProvider`:\n\n```javascript\nimport { shallow } from 'enzyme';\nimport { IntlProvider } from 'react-intl';\nimport MyComponent from './MyComponent';\n\nit('renders correctly', () => {\n  const wrapper = shallow(\n    <IntlProvider locale=\"en\">\n      <MyComponent />\n    </IntlProvider>\n  );\n  // assertions here\n});\n```\n\n\n### Performance Optimization\n\nFor optimal performance, consider:\n\n* **Lazy Loading:**  Load locale data dynamically only when needed.\n\n* **Code Splitting:**  Split your application into smaller chunks to avoid loading unnecessary code.\n\n* **Message Caching:** Cache translated messages to avoid repeated lookups.  React Intl has built-in mechanisms to handle this to some extent.\n\n* **Minimize Component Rerenders:**  Use techniques like `React.memo` or `useMemo` to prevent unnecessary rerenders of components that do not require updates.\n\n\n### Handling Complex Data Structures\n\nFor complex data structures needing translation, you need to design a mechanism for translating nested objects or arrays.  Recursive functions or custom helper functions can traverse and translate deeply nested data.  This often requires restructuring your data to use keys and IDs that map to your translation strings.\n\n\n### Extending React Intl with Custom Components\n\nReact Intl provides extensibility to create custom components for specific formatting needs. You can build custom components to handle complex formatting scenarios not directly addressed by the built-in components.  This involves utilizing the `Intl` APIs and constructing your own components that integrate with the React Intl context.  You might create components for specialized date formatting, custom number display, or even creating custom message formatters that handle complex data.\n\n\n## Contributing and Community\n\n### Contributing to the Project\n\nContributions to React Intl are welcome!  Before contributing, please take the time to review the project's contribution guidelines. These guidelines outline the process for submitting pull requests, writing tests, and adhering to the project's coding style.  Key aspects typically covered include:\n\n* **Issue Reporting:**  When reporting issues, provide clear and concise descriptions, including steps to reproduce the problem, expected behavior, actual behavior, and relevant versions of React Intl and other dependencies.\n\n* **Pull Requests:**  Ensure your pull requests are well-documented and include thorough testing.  Follow the project's coding style and conventions.  Address any feedback promptly and iteratively.\n\n* **Code Style:** Adhere to the project's code style guide to maintain consistency and readability.\n\n* **Testing:**  Write comprehensive tests to ensure that your changes do not introduce regressions or break existing functionality.  The project likely uses a testing framework (e.g., Jest) and follows a test-driven development (TDD) or test-first approach.\n\n* **Documentation:**  Update documentation to reflect any changes you've made.\n\n\n### Community Support and Resources\n\nThe React Intl community provides various avenues for support and collaboration:\n\n* **Issue Tracker:** The project's issue tracker is a primary resource for reporting bugs, requesting features, and discussing technical questions.\n\n* **Discussion Forums:**  The project might have dedicated discussion forums or use a broader platform (e.g., a forum on a site like Stack Overflow or a community forum dedicated to React) where you can ask questions and connect with other users.\n\n* **Online Chat:**  A real-time chat channel (e.g., Discord, Slack) might exist, facilitating quicker communication and discussions among users and contributors.\n\n* **Official Documentation:**  The official documentation (likely hosted on a site like GitHub Pages or a similar platform) provides comprehensive information on using React Intl, including tutorials, API references, and examples.\n\n* **Examples and Tutorials:** The project likely includes a variety of examples and tutorials in the form of code snippets, code repositories, and blog posts showcasing practical applications of React Intl in different contexts.\n\n\nEngaging with the community is highly encouraged to get assistance, share your knowledge, and contribute to the ongoing development and improvement of React Intl.  Check the project's repository for links to community resources and communication channels.\n\n","srcMarkdownNoYaml":"\n\n\n### What is React Intl?\n\nReact Intl is a JavaScript library built on top of the `Intl` object provided by modern browsers and Node.js. It provides a simple, powerful, and efficient way to internationalize (i18n) and localize (l10n) React applications.  This means it helps you build applications that can be easily adapted to different languages and cultural conventions, displaying dates, numbers, currencies, and text appropriately for each locale.  Instead of manually managing translations and formatting, React Intl handles the complexities, leaving you to focus on building your application's core features.\n\n\n### Why use React Intl?\n\nUsing React Intl offers several key advantages:\n\n* **Simplified Internationalization:**  It abstracts away the complexities of dealing with different locales and formatting rules, making internationalization significantly easier than manual implementation.\n* **Improved Developer Experience:**  React Intl provides a declarative API that integrates seamlessly with React's component model, leading to cleaner and more maintainable code.\n* **Performance:** It leverages the browser's built-in `Intl` APIs for optimal performance, avoiding the overhead of external libraries for common formatting tasks.\n* **Comprehensive Support:** It supports a wide range of formatting options including dates, times, numbers, currencies, relative time, and pluralization, ensuring your application adapts correctly to diverse linguistic and cultural contexts.\n* **Message Formatting:** It efficiently handles message formatting with placeholders, providing robust support for translating complex sentences while handling potential security concerns related to user-supplied data within messages.\n\n\n### Setting up React Intl\n\nSetting up React Intl in your project is straightforward.  First, install the necessary package:\n\n```bash\nnpm install react-intl\n```\n\nor\n\n```bash\nyarn add react-intl\n```\n\nNext, import and use the necessary components within your React application.  The most common component is `<IntlProvider>`, which provides locale and messages to your application.  Example:\n\n\n```javascript\nimport { IntlProvider, FormattedMessage } from 'react-intl';\nimport messages from './messages'; // Your translation messages\n\nfunction MyComponent() {\n  return (\n    <IntlProvider locale=\"en\" messages={messages.en}>\n      <FormattedMessage id=\"greeting\" /> {/* Example usage */}\n    </IntlProvider>\n  );\n}\n```\n\nThis example requires a `messages.en` object containing your English translations (you'd typically have similar objects for other locales, e.g., `messages.es` for Spanish).  The `<FormattedMessage>` component looks up and renders the translation for the specified `id`.\n\nRemember to handle locale detection and switching (often based on user browser settings or explicit selection) to manage different languages effectively.\n\n### Core Concepts\n\nReact Intl revolves around several core concepts:\n\n* **Locale:** A specification of a region/language (e.g., \"en-US\", \"es-ES\", \"de\").  This determines the formatting rules and translation used.\n\n* **Messages:** A collection of translated strings, often organized by key (ID) for easy lookup.  These are typically loaded from JSON files or other data sources.\n\n* **Formatters:** Functions that handle the formatting of different data types based on the locale, including `NumberFormat`, `DateTimeFormat`, and `RelativeTimeFormat`.  These are accessible through React Intl's components.\n\n* **Components:** React components like `<IntlProvider>`, `<FormattedMessage>`, `<FormattedDate>`, `<FormattedNumber>`, `<FormattedTime>`, and `<FormattedRelative>` simplify the process of rendering localized content and handling various formatting needs.  These components leverage the formatters and locale information provided by `<IntlProvider>`.\n\n* **Pluralization and Gender:** React Intl supports handling plural forms of words and grammatical gender, ensuring your translations accurately reflect the context of the numbers and nouns used.\n\n\nUnderstanding these core concepts is crucial for effectively using React Intl to create robust and internationally-ready applications.\n\n\n## Formatting Messages\n\n### Using `FormattedMessage`\n\nThe `FormattedMessage` component is the cornerstone of translating text within your React application using React Intl. It allows you to display localized messages based on the locale provided by the `<IntlProvider>`.  You identify messages using a unique `id`, which maps to a key within your message catalog (e.g., a JSON object).\n\n**Basic Usage:**\n\n```javascript\nimport { FormattedMessage } from 'react-intl';\n\n// Assuming messages.en = {greeting: \"Hello!\"}\n<FormattedMessage id=\"greeting\" /> \n```\n\nThis will render \"Hello!\" if the locale is \"en\".\n\n**Adding placeholders (interpolation):**\n\nYou can use placeholders within your message strings to dynamically insert values.  These are indicated by `{placeholder}` within the message string.  You provide the values using the `values` prop:\n\n```javascript\n<FormattedMessage\n  id=\"welcomeMessage\"\n  values={{ name: 'John' }}\n/>\n```\n\nWith the message definition (in `messages.en` for example):\n\n```javascript\n\"welcomeMessage\": \"Welcome, {name}!\"\n```\n\nThis will render \"Welcome, John!\"\n\n**Handling HTML:**\n\nFor more complex scenarios, use the `defaultMessage` prop to handle messages that might not be present in all locales or for debugging.  You can also embed HTML using dangerouslySetInnerHTML, but remember to sanitize any user-provided data.  Directly embedding HTML within the `id` message is generally discouraged for security reasons.\n\n\n### Working with Plural Rules\n\nReact Intl handles pluralization automatically, ensuring correct grammatical agreement with numbers.  Use plural forms within your message strings, delineated using special syntax within your message catalog.  The specific syntax varies depending on your chosen pluralization library (often CLDR).\n\nExample (using a common syntax):\n\n```javascript\n\"apples\": \"{count, plural, =0 {No apples} one {One apple} other {# apples}}\"\n```\n\nThis message will render differently depending on the value of `{count}`:\n\n* 0: \"No apples\"\n* 1: \"One apple\"\n* 2+: \"{count} apples\"\n\n\n### Handling Gender and Selectors\n\nSimilar to pluralization, React Intl supports gendered messages.  These use a selector within the message string to choose the correct form based on a provided gender value.  The syntax varies depending on the locale and message format.\n\nExample (a common, but locale-dependent, syntax):\n\n```javascript\n\"greeting\": \"{gender, select, male {Hello, sir!} female {Hello, madam!} other {Hello!}}\"\n```\n\n\n### Using Number Formatting\n\nThe `<FormattedNumber>` component provides robust number formatting, adhering to locale-specific conventions for decimal separators, thousands separators, and currency symbols.\n\n```javascript\nimport { FormattedNumber } from 'react-intl';\n\n<FormattedNumber value={1234.56} style=\"currency\" currency=\"USD\" />\n```\n\n\n### Using Date and Time Formatting\n\nThe `<FormattedDate>` and `<FormattedTime>` components format dates and times according to locale conventions.  You can specify the desired format using the `value` (date object) and `dateStyle` or `timeStyle` props (e.g., 'short', 'medium', 'long', 'full').\n\n```javascript\nimport { FormattedDate, FormattedTime } from 'react-intl';\n\n<FormattedDate value={new Date()} />\n<FormattedTime value={new Date()} />\n```\n\nYou can also customize the formatting even more precisely using the `format` prop with ICU MessageFormat patterns.\n\n\n### Custom Formatting Functions\n\nFor highly customized formatting needs beyond what's offered by built-in components, you can create and use custom formatting functions.  These functions will receive the locale and the value to format.  You'd then integrate these custom functions within your React components, likely alongside `FormattedMessage`.  This is useful for highly specific formatting requirements not directly supported by the default formatters.\n\n\n## Internationalization Components\n\n### `FormattedDate`\n\nThe `FormattedDate` component renders a date according to the current locale. It uses the browser's built-in `Intl.DateTimeFormat` API for optimal performance and accuracy.\n\n**Props:**\n\n* `value` (required): A `Date` object representing the date to format.\n* `dateStyle`: A string specifying the date style (\"full\", \"long\", \"medium\", \"short\").  Defaults to \"medium\".\n* `timeStyle`: A string specifying the time style (\"full\", \"long\", \"medium\", \"short\").  If provided alongside `dateStyle`, combined date and time formatting is applied.\n* `format`:  An ICU MessageFormat pattern string for fine-grained control over the date/time formatting. Overrides `dateStyle` and `timeStyle`.\n\n\n**Example:**\n\n```javascript\nimport { FormattedDate } from 'react-intl';\n\n<FormattedDate value={new Date()} />  {/* Uses default 'medium' style */}\n<FormattedDate value={new Date()} dateStyle=\"long\" />\n<FormattedDate value={new Date()} dateStyle=\"short\" timeStyle=\"short\" />\n<FormattedDate value={new Date()} format=\"yyyy-MM-dd HH:mm:ss\" />\n```\n\n\n### `FormattedNumber`\n\nThe `FormattedNumber` component formats numbers according to the current locale's number formatting conventions, including decimal separators, grouping separators, and currency symbols.\n\n**Props:**\n\n* `value` (required): A number to format.\n* `style`: A string specifying the formatting style (\"decimal\", \"currency\", \"percent\"). Defaults to \"decimal\".\n* `currency`: A string specifying the currency code (e.g., \"USD\", \"EUR\") if `style` is \"currency\".\n* `currencyDisplay`:  A string specifying how to display the currency (\"symbol\", \"code\", \"name\"). Defaults to \"symbol\".\n* `minimumFractionDigits`, `maximumFractionDigits`, etc.:  Options for fine-tuning number formatting as per the `Intl.NumberFormat` API\n\n\n**Example:**\n\n```javascript\nimport { FormattedNumber } from 'react-intl';\n\n<FormattedNumber value={1234.56} />        {/* Decimal style */}\n<FormattedNumber value={1234.56} style=\"currency\" currency=\"USD\" /> {/* USD currency style */}\n<FormattedNumber value={0.75} style=\"percent\" />   {/* Percent style */}\n```\n\n\n### `FormattedTime`\n\nSimilar to `FormattedDate`, `FormattedTime` formats time values according to the current locale.\n\n**Props:**\n\n* `value` (required): A `Date` object.\n* `timeStyle`: A string specifying the time style (\"full\", \"long\", \"medium\", \"short\"). Defaults to \"medium\".\n* `format`: An ICU MessageFormat pattern string for precise time formatting. Overrides `timeStyle`.\n\n\n**Example:**\n\n```javascript\nimport { FormattedTime } from 'react-intl';\n\n<FormattedTime value={new Date()} />      {/* Uses default 'medium' style */}\n<FormattedTime value={new Date()} timeStyle=\"short\" />\n<FormattedTime value={new Date()} format=\"HH:mm:ss\" />\n```\n\n\n### `FormattedRelative`\n\n`FormattedRelative` displays a relative time representation (e.g., \"a few seconds ago\", \"2 hours ago\").  It's ideal for displaying timestamps in a user-friendly manner.\n\n**Props:**\n\n* `value` (required): A `Date` object representing the reference time.\n* `updateInterval`: (Optional) The update interval in milliseconds for automatically updating the relative time display.\n\n\n**Example:**\n\n```javascript\nimport { FormattedRelative } from 'react-intl';\n\n<FormattedRelative value={new Date(Date.now() - 3600000)} /> {/* One hour ago */}\n```\n\n\n### `FormattedPlural`\n\n`FormattedPlural` is used for displaying messages that vary depending on the quantity of items, handling plural forms correctly for the current locale.\n\n**Props:**\n\n* `value` (required): A number representing the quantity.\n* `one`, `two`, `few`, `many`, `other`:  Message strings for different plural categories (defined by the locale).  At least `other` must be specified.\n\n\n**Example (Illustrative, Actual plural rules depend on locale):**\n\n```javascript\nimport { FormattedPlural } from 'react-intl';\n\n<FormattedPlural value={2} one=\"One item\" other=\"{value} items\" />\n```\n\n\n### `FormattedList`\n\n`FormattedList` renders a list of items, applying locale-appropriate separators and conjunctions.\n\n**Props:**\n\n* `type`:  A string specifying the list type (\"unit\", \"unit-conjunction\", \"disjunction\").\n* `values`: An array of values to display.\n* `element`: The type of element to render, defaults to `<ul>`.  Can be set to e.g., `<ol>` for ordered lists.\n\n\n**Example:**\n\n```javascript\nimport { FormattedList } from 'react-intl';\n\n<FormattedList values={['apple', 'banana', 'orange']} />\n```\n\n\nNote:  The exact behavior and available options for these components might be subject to minor changes across different versions of React Intl. Always refer to the latest documentation for the most up-to-date information.\n\n\n## Working with Locale Data\n\n### Loading Locale Data\n\nReact Intl relies on locale data to perform accurate formatting and translation.  This data typically includes translations for messages, as well as rules for number, date, and time formatting.  You load this data in your application using different methods:\n\n* **Static JSON Files:** The most common approach is to create separate JSON files for each supported locale.  These files contain key-value pairs mapping message IDs to their translated text. You then load these files based on the detected or selected locale.\n\n  ```javascript\n  // messages.en.json\n  {\n    \"greeting\": \"Hello!\",\n    \"farewell\": \"Goodbye!\"\n  }\n\n  // messages.es.json\n  {\n    \"greeting\": \"¡Hola!\",\n    \"farewell\": \"¡Adiós!\"\n  }\n\n  // In your component:\n  import messagesEn from './messages.en.json';\n  import messagesEs from './messages.es.json';\n\n  const messages = locale === 'es' ? messagesEs : messagesEn;\n  ```\n\n* **Dynamic Loading:** For larger applications or when dealing with many locales, it might be more efficient to load locale data dynamically on demand.  This prevents loading unnecessary data initially. You could use `import()` to dynamically load the JSON files based on the selected locale.\n\n\n* **External APIs:** For very large scale applications, consider retrieving locale data from a centralized API, perhaps a Content Delivery Network (CDN) or a dedicated translation service.\n\n\n### Defining Custom Locales\n\nWhile React Intl supports a vast number of standard locales, you might need to define custom locales for less common languages or specific formatting requirements. This involves creating a custom locale object that conforms to the `Intl` API's specifications.  This is generally more complex and requires a deep understanding of locale data structures.\n\n\n### Locale Detection and Switching\n\nHandling locale detection and switching is crucial for a good user experience.  Common strategies include:\n\n* **Browser Locale:** Detect the user's preferred locale using the browser's `navigator.language` or `navigator.userLanguage` property.\n\n* **URL Parameters:** Allow users to explicitly specify the locale via a URL parameter (e.g., `example.com/?locale=es`).\n\n* **User Settings:** Provide a mechanism within your application for users to select their preferred locale and store this preference (e.g., using local storage or cookies).\n\n* **Combination:** Combine methods for robust locale determination, giving priority to explicit user selection over inferred browser locale.\n\n  ```javascript\n  const getLocale = () => {\n    const urlLocale = new URLSearchParams(window.location.search).get('locale');\n    return urlLocale || navigator.language || 'en';\n  };\n\n  // Update the locale state when necessary (e.g., using useState hook)\n  ```\n\n  You then use this locale to update the `IntlProvider` to reflect the user’s choice.\n\n\n### Using Different Number/Date/Time Systems\n\nReact Intl relies on the browser's built-in `Intl` API, which respects the locale's inherent number, date, and time formatting rules.  This means if a locale uses different number systems (like Arabic numerals versus Devanagari numerals) or different calendar systems (Gregorian vs. Islamic), React Intl will handle this automatically.  You don't need to explicitly configure this; it's determined by the locale you provide.  However, ensure your message catalogs and JSON files accurately reflect the conventions for the locale to avoid mismatches.\n\n\n## Advanced Usage\n\n### Using React Intl with Redux\n\nIntegrating React Intl with Redux involves managing the application's locale and messages within the Redux store.  This allows for centralized state management and easy sharing of locale information across different parts of the application.\n\n1. **Store Locale:**  Create a slice of your Redux store to hold the current locale.  Actions can be dispatched to change this locale.\n\n2. **Provide `<IntlProvider>`:** Wrap your main app component with the `<IntlProvider>`, passing the locale from the Redux store via a selector. You'll likely use `connect` from `react-redux` to connect your component to the store.\n\n3. **Dispatch Locale Changes:**  Dispatch actions to update the locale in the store whenever the user changes their preference.\n\nExample (conceptual):\n\n```javascript\n// Redux actions\nexport const setLocale = (locale) => ({ type: 'SET_LOCALE', locale });\n\n// Redux reducer\nconst reducer = (state = { locale: 'en' }, action) => {\n  switch (action.type) {\n    case 'SET_LOCALE':\n      return { ...state, locale: action.locale };\n    default:\n      return state;\n  }\n};\n\n// Connected component\nconst MyComponent = connect(state => ({ locale: state.locale }))(MyComponent);\n```\n\n\n### Internationalization of UI Components\n\nWhen internationalizing UI components, consider these best practices:\n\n* **Separate Messages:** Keep translation messages separate from component logic. This promotes maintainability and allows for easy updates.\n\n* **Component-Specific Messages:** Create message catalogs specific to each component, organizing your translations logically.\n\n* **Prop-Based Localization:** Pass locale and messages as props to your components.  Avoid hardcoding locale-specific values within components.\n\n* **Test Thoroughly:** Test your components with different locales to ensure consistent functionality and accurate translations.\n\n\n### Testing React Intl applications\n\nTesting React Intl applications requires careful consideration of how to manage the locale context during testing.\n\n* **Static Context:** Use the `IntlProvider` during testing with a static locale to ensure predictable behavior.\n\n* **Shallow Rendering:**  For unit tests, shallow rendering often suffices, especially when focusing on the component's logic separate from the formatting handled by React Intl components.\n\n* **Snapshot Testing:** Use snapshot testing with caution, since changes in formatting based on locale could lead to frequent snapshot updates.\n\n* **Integration Tests:**  For integration tests, you'll likely need a full rendering environment to test the interactions between React Intl and other parts of the application.\n\nExample using enzyme and a mocked `IntlProvider`:\n\n```javascript\nimport { shallow } from 'enzyme';\nimport { IntlProvider } from 'react-intl';\nimport MyComponent from './MyComponent';\n\nit('renders correctly', () => {\n  const wrapper = shallow(\n    <IntlProvider locale=\"en\">\n      <MyComponent />\n    </IntlProvider>\n  );\n  // assertions here\n});\n```\n\n\n### Performance Optimization\n\nFor optimal performance, consider:\n\n* **Lazy Loading:**  Load locale data dynamically only when needed.\n\n* **Code Splitting:**  Split your application into smaller chunks to avoid loading unnecessary code.\n\n* **Message Caching:** Cache translated messages to avoid repeated lookups.  React Intl has built-in mechanisms to handle this to some extent.\n\n* **Minimize Component Rerenders:**  Use techniques like `React.memo` or `useMemo` to prevent unnecessary rerenders of components that do not require updates.\n\n\n### Handling Complex Data Structures\n\nFor complex data structures needing translation, you need to design a mechanism for translating nested objects or arrays.  Recursive functions or custom helper functions can traverse and translate deeply nested data.  This often requires restructuring your data to use keys and IDs that map to your translation strings.\n\n\n### Extending React Intl with Custom Components\n\nReact Intl provides extensibility to create custom components for specific formatting needs. You can build custom components to handle complex formatting scenarios not directly addressed by the built-in components.  This involves utilizing the `Intl` APIs and constructing your own components that integrate with the React Intl context.  You might create components for specialized date formatting, custom number display, or even creating custom message formatters that handle complex data.\n\n\n## Contributing and Community\n\n### Contributing to the Project\n\nContributions to React Intl are welcome!  Before contributing, please take the time to review the project's contribution guidelines. These guidelines outline the process for submitting pull requests, writing tests, and adhering to the project's coding style.  Key aspects typically covered include:\n\n* **Issue Reporting:**  When reporting issues, provide clear and concise descriptions, including steps to reproduce the problem, expected behavior, actual behavior, and relevant versions of React Intl and other dependencies.\n\n* **Pull Requests:**  Ensure your pull requests are well-documented and include thorough testing.  Follow the project's coding style and conventions.  Address any feedback promptly and iteratively.\n\n* **Code Style:** Adhere to the project's code style guide to maintain consistency and readability.\n\n* **Testing:**  Write comprehensive tests to ensure that your changes do not introduce regressions or break existing functionality.  The project likely uses a testing framework (e.g., Jest) and follows a test-driven development (TDD) or test-first approach.\n\n* **Documentation:**  Update documentation to reflect any changes you've made.\n\n\n### Community Support and Resources\n\nThe React Intl community provides various avenues for support and collaboration:\n\n* **Issue Tracker:** The project's issue tracker is a primary resource for reporting bugs, requesting features, and discussing technical questions.\n\n* **Discussion Forums:**  The project might have dedicated discussion forums or use a broader platform (e.g., a forum on a site like Stack Overflow or a community forum dedicated to React) where you can ask questions and connect with other users.\n\n* **Online Chat:**  A real-time chat channel (e.g., Discord, Slack) might exist, facilitating quicker communication and discussions among users and contributors.\n\n* **Official Documentation:**  The official documentation (likely hosted on a site like GitHub Pages or a similar platform) provides comprehensive information on using React Intl, including tutorials, API references, and examples.\n\n* **Examples and Tutorials:** The project likely includes a variety of examples and tutorials in the form of code snippets, code repositories, and blog posts showcasing practical applications of React Intl in different contexts.\n\n\nEngaging with the community is highly encouraged to get assistance, share your knowledge, and contribute to the ongoing development and improvement of React Intl.  Check the project's repository for links to community resources and communication channels.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["../../styles.css"],"html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"},"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"},"../../footer.html"],"output-file":"react-intl.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"license":"MIT","author-meta":"Muthukrishnan","title":"React-Intl - Documentation","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}