{"title":"Bowser - Documentation","markdown":{"yaml":{"title":"Bowser - Documentation","categories":["JavaScript Libraries and Functions"]},"headingText":"What is Bowser?","containsRefs":false,"markdown":"\n\n\n\nBowser is a [insert concise and accurate description of Bowser, e.g.,  powerful, open-source framework for building cross-platform web applications.  It leverages [mention key technologies used, e.g.,  HTML5, WebAssembly, and a novel rendering engine] to deliver high-performance, visually stunning applications with a streamlined development process.].  It abstracts away many of the complexities of modern web development, allowing developers to focus on creating innovative user experiences.\n\n\n### Why use Bowser?\n\nBowser offers several key advantages for developers:\n\n* **Cross-Platform Compatibility:** Build once, deploy everywhere. Bowser applications run seamlessly across a wide range of devices and browsers without requiring platform-specific code adjustments.\n* **Enhanced Performance:**  Leveraging [mention specific technologies and their benefits, e.g., WebAssembly for computationally intensive tasks and optimized rendering for smooth animations], Bowser delivers exceptional performance and responsiveness.\n* **Simplified Development:**  Bowser's intuitive API and comprehensive toolset significantly reduce development time and effort, allowing for rapid prototyping and iteration.\n* **Extensibility:** Bowser is designed to be highly extensible, allowing developers to integrate custom components and functionalities seamlessly.\n* **[Add other compelling reasons, e.g., Large community support, Extensive documentation, Active development, etc.]**\n\n\n### Setting up Bowser\n\nSetting up Bowser for development involves the following steps:\n\n1. **Install Node.js and npm (or yarn):** Bowser requires Node.js and a package manager like npm or yarn.  Download and install the latest versions from the official Node.js website.\n2. **Clone the Bowser repository:** Use Git to clone the Bowser repository from [insert Git repository URL here].\n3. **Install dependencies:** Navigate to the cloned repository directory in your terminal and run `npm install` (or `yarn install`) to install all necessary dependencies.\n4. **[Add any other setup steps, e.g., configuring environment variables, setting up a build process, etc.]**\n5. **Run the development server:**  Start the development server using the command `npm start` (or `yarn start`). This will launch a local server, allowing you to test and debug your application.\n\n\n### System Requirements\n\nTo develop using Bowser, your system should meet the following minimum requirements:\n\n* **Operating System:**  [Specify supported OS, e.g., Windows 10, macOS 10.15+, Linux (Ubuntu 20.04+)]\n* **Node.js:**  [Specify minimum Node.js version, e.g., v16.0.0 or higher]\n* **npm (or yarn):**  [Specify minimum version if required, otherwise just state \"latest version recommended\"]\n* **Memory:**  [Specify minimum RAM, e.g., 8GB RAM recommended]\n* **Disk Space:**  [Specify minimum disk space, e.g., 10GB of free disk space]\n* **[Add any other requirements, e.g., specific graphics card capabilities, etc.]**\n\nIt is recommended to use a modern, reasonably powerful machine for optimal development experience.  Performance may be impacted on systems with limited resources.\n\n\n## Core Concepts\n\n### Browser Detection\n\nBowser's core functionality revolves around robust browser detection.  Instead of relying solely on the user agent string (which can be easily spoofed), Bowser employs a multi-pronged approach combining user agent parsing with feature detection. This ensures accurate and reliable browser identification, even in complex scenarios involving unusual user agents or browser extensions that modify default behavior.  The detection process prioritizes feature detection to provide the most accurate results.\n\n\n### Feature Detection\n\nBowser utilizes feature detection to determine the capabilities of the user's browser.  This approach is more reliable than relying solely on user agent strings, as it directly tests whether specific features are supported instead of inferring them from potentially outdated or manipulated user agent data.  Feature detection checks for the presence and functionality of various browser APIs and rendering capabilities, allowing Bowser to adapt its behavior accordingly and provide optimal performance across different browsers.  This ensures compatibility and prevents reliance on potentially inaccurate information provided by the user agent string.\n\n\n### User Agent Parsing\n\nWhile Bowser prioritizes feature detection, it still parses the user agent string to provide additional context and information.  This parsed information is used to supplement the feature detection results, offering a more complete picture of the browser and user environment.  The parsing process is designed to handle a wide range of user agent strings, including those from various browsers, mobile devices, and other user agents.  However, developers should remember that user agent strings can be manipulated, and feature detection should be the primary method for determining browser capabilities.\n\n\n### Parsing User Agent Strings\n\nBowser's internal user agent parsing engine is highly optimized for speed and accuracy.  It utilizes regular expressions and sophisticated parsing logic to extract relevant information from the user agent string, such as browser name, version, platform, and engine.  This parsed data is then used to enrich the browser detection process and provide more detailed information to developers.  While the specifics of the parsing algorithm are internal, the results are accessible through Bowser's API, allowing developers to retrieve parsed user agent information if needed.  However, it is crucial to reiterate that feature detection should be the primary method for determining browser capabilities, with user agent parsing used as a supplementary source of information.\n\n\n## API Reference\n\n### `getBrowser()`\n\nReturns a string representing the detected browser name (e.g., \"Chrome\", \"Firefox\", \"Safari\").  Returns `null` if no browser can be reliably detected. This function prioritizes feature detection over User Agent parsing.\n\n```javascript\nconst browser = Bowser.getBrowser();\nconsole.log(browser); // Output: \"Chrome\" (or similar)\n```\n\n### `getOS()`\n\nReturns a string representing the detected operating system (e.g., \"Windows\", \"macOS\", \"Android\", \"iOS\"). Returns `null` if no OS can be reliably detected.\n\n```javascript\nconst os = Bowser.getOS();\nconsole.log(os); // Output: \"macOS\" (or similar)\n```\n\n### `getDevice()`\n\nReturns a string representing the detected device type (e.g., \"Desktop\", \"Mobile\", \"Tablet\").  This is determined through a combination of user agent parsing and feature detection. Returns `null` if no device type can be reliably detected.\n\n```javascript\nconst device = Bowser.getDevice();\nconsole.log(device); // Output: \"Mobile\" (or similar)\n```\n\n### `getEngine()`\n\nReturns a string representing the detected browser engine (e.g., \"Blink\", \"Gecko\", \"WebKit\"). Returns `null` if no engine can be reliably detected.\n\n```javascript\nconst engine = Bowser.getEngine();\nconsole.log(engine); // Output: \"Blink\" (or similar)\n```\n\n### `getPlatform()`\n\nReturns a string representing the detected platform (e.g., \"Linux\", \"Win32\", \"MacIntel\"). This is a more granular representation than `getOS()` and may include architectural information.  Returns `null` if no platform can be reliably detected.\n\n```javascript\nconst platform = Bowser.getPlatform();\nconsole.log(platform); // Output: \"MacIntel\" (or similar)\n```\n\n### `getUa()`\n\nReturns the raw user agent string.\n\n```javascript\nconst ua = Bowser.getUa();\nconsole.log(ua); // Output: \"Mozilla/5.0 ...\" (or similar)\n```\n\n### `getVersion()`\n\nReturns a string representing the detected browser version (e.g., \"115.0.5790.171\").  Returns `null` if no version can be reliably detected.\n\n```javascript\nconst version = Bowser.getVersion();\nconsole.log(version); // Output: \"115.0.5790.171\" (or similar)\n```\n\n### `isSupported()`\n\nChecks if a specific browser version or feature is supported.  Requires a browser name and version string as arguments.  Returns a boolean indicating support.  (See documentation for detailed argument formatting.)\n\n\n```javascript\nconst supported = Bowser.isSupported('chrome', '100');\nconsole.log(supported); // Output: true or false\n```\n\n### `getFeature()`\n\nChecks for the support of a specific feature. This is more reliable than relying solely on version numbers.  Returns a boolean indicating whether the feature is supported. (See documentation for a list of supported features.)\n\n```javascript\nconst supportsWebP = Bowser.getFeature('webp');\nconsole.log(supportsWebP); // Output: true or false\n```\n\n### `parse()`\n\nParses a given user agent string.  Useful for processing user agent strings from external sources.  Returns an object containing parsed browser information.\n\n```javascript\nconst parsedUserAgent = Bowser.parse('Mozilla/5.0...');\nconsole.log(parsedUserAgent);\n```\n\n### `utils.isMobile()`\n\nReturns a boolean indicating whether the current device is a mobile device.\n\n```javascript\nconst isMobile = Bowser.utils.isMobile();\nconsole.log(isMobile); // Output: true or false\n```\n\n### `utils.isTablet()`\n\nReturns a boolean indicating whether the current device is a tablet.\n\n```javascript\nconst isTablet = Bowser.utils.isTablet();\nconsole.log(isTablet); // Output: true or false\n```\n\n### `utils.isDesktop()`\n\nReturns a boolean indicating whether the current device is a desktop computer.\n\n```javascript\nconst isDesktop = Bowser.utils.isDesktop();\nconsole.log(isDesktop); // Output: true or false\n```\n\n### `utils.isBot()`\n\nReturns a boolean indicating whether the current user agent belongs to a bot or crawler.\n\n```javascript\nconst isBot = Bowser.utils.isBot();\nconsole.log(isBot); // Output: true or false\n```\n\n\n## Advanced Usage\n\n### Custom User Agent Parsing\n\nWhile Bowser's built-in user agent parsing is robust, you might need to customize it for specific scenarios.  This can be achieved by providing a custom parsing function.  Bowser allows you to override its internal parsing logic by providing a function that takes the raw user agent string as input and returns a parsed object.  The structure of this object should match Bowser's internal representation (consult the source code for details).  This allows for highly specialized parsing of uncommon or custom user agent strings that might not be handled correctly by the default parser.  Refer to the advanced usage examples in the Bowser repository for detailed instructions on implementing a custom parser.\n\n### Extending Bowser's Capabilities\n\nBowser is designed to be extensible. You can extend its functionality by adding support for new browsers, features, or devices. This usually involves updating the internal browser detection tables and potentially adding new feature detection functions. The process generally requires familiarity with Bowser's internal structure and might involve contributing back to the main Bowser project. For detailed information on extending Bowser's capabilities, please consult the contribution guidelines in the project's repository.\n\n### Integration with Other Libraries\n\nBowser integrates seamlessly with various JavaScript libraries and frameworks.  Its lightweight nature and straightforward API facilitate easy integration.  For example, you can use Bowser's detection results to conditionally load different versions of a library based on the detected browser capabilities, providing optimized performance for different user environments.  There are no specific integration requirements; simply include Bowser in your project and call its functions as needed. The key is using the results of Bowser's detection methods to drive conditional logic in your application.\n\n### Troubleshooting\n\nThis section addresses common issues encountered when using Bowser:\n\n* **Inaccurate browser detection:** If Bowser is not detecting a browser correctly, ensure that feature detection is enabled.  Incorrect results may stem from relying solely on the user agent string, which can be unreliable.  Check if the browser in question is supported.  If it's a newly released or less common browser, Bowser might require updates.\n\n* **Missing features:**  Bowser relies on feature detection to determine if specific browser features are present.  If a feature isn't detected, ensure the feature exists in the browser being tested.  Also verify that any necessary browser APIs are correctly implemented and accessible.\n\n* **Performance issues:** Bowser is designed to be lightweight and efficient.  Performance issues are rarely attributed to Bowser itself, and are usually related to the application code utilizing Bowser.  Profile your application to identify performance bottlenecks.\n\n* **Errors in custom parsers:**  When using custom parsing, ensure your parser's output structure adheres to Bowser's internal data format.  Incorrectly structured output can lead to unexpected behavior or errors.\n\nIf you encounter problems not covered here, check the Bowser issue tracker or community forums for solutions.  Include details of your environment, the Bowser version used, and steps to reproduce the problem when reporting issues.\n\n\n## Best Practices\n\n### Writing Robust Browser-Specific Code\n\nWhen writing browser-specific code, prioritize feature detection over relying solely on user agent strings or browser names.  Use Bowser's `getFeature()` method to check for the availability of specific functionalities before using them.  This ensures that your application gracefully handles cases where a feature might be absent.  Avoid writing extensive `if/else` blocks based on browser names; instead, design your code to adapt to different feature sets, making it more maintainable and less prone to errors as browsers evolve.  Organize your browser-specific code into modular components to improve code clarity and reusability.\n\n### Handling Unsupported Browsers\n\nWhile Bowser aims for broad compatibility, some very old or obscure browsers might not be fully supported.  Implement graceful fallback mechanisms to handle cases where Bowser detects an unsupported browser.  Provide users with clear instructions on how to upgrade their browser to a supported version or use an alternative method to access the application's functionality.  Consider using a polite and informative message to inform users about the incompatibility rather than simply showing a broken application.  This improves the user experience and helps you gauge the support you need to provide.\n\n### Optimizing for Performance\n\nBowser itself is designed for optimal performance, but using it effectively requires attention to other aspects of your application. Minimize the number of browser detection calls, especially within performance-critical sections of your code.  Cache the results of Bowser's detection methods to avoid redundant calls. Use Bowser's detection results to optimize your application's behavior by loading only the necessary resources or using alternative algorithms that are optimized for different browsers or devices.  This reduces load times and improves the overall user experience.\n\n### Security Considerations\n\nAlways validate user input to prevent vulnerabilities, regardless of the browser used.  Avoid relying solely on client-side browser detection for security decisions; perform server-side validation as well.  Ensure that any browser-specific code is secure and doesn't create unintended vulnerabilities.  Regularly update Bowser to benefit from bug fixes and security patches.  Keep your dependencies up-to-date, as outdated libraries can introduce vulnerabilities.  Follow secure coding practices to prevent cross-site scripting (XSS) and other common web vulnerabilities, independent of your use of Bowser.\n\n\n## Contributing to Bowser\n\nWe welcome contributions to Bowser!  Whether you're fixing bugs, adding new features, or improving documentation, your help is valuable.  Here's how you can contribute:\n\n\n### Setting up the Development Environment\n\n1. **Fork the Repository:** Fork the official Bowser repository on GitHub to your personal account.\n\n2. **Clone Your Fork:** Clone your forked repository to your local machine using Git:  `git clone git@github.com:YOUR_USERNAME/bowser.git` (replace `YOUR_USERNAME` with your GitHub username).\n\n3. **Install Dependencies:** Navigate to the project directory and install the necessary dependencies using npm or yarn:  `npm install` or `yarn install`.\n\n4. **Set up the Development Server (optional but recommended):** Bowser uses a development server for testing.  Refer to the project's README for instructions on starting the development server.\n\n5. **Choose Your Issue:** Browse the issue tracker for bugs to fix or features to implement.  If you have an idea for a new feature, create a new issue to discuss it before starting work.\n\n\n### Coding Style Guide\n\nBowser follows a consistent coding style to ensure readability and maintainability.  Adhere to the following guidelines:\n\n* **Indentation:** Use 2 spaces for indentation.\n\n* **Line Length:** Keep lines under 80 characters.\n\n* **Naming Conventions:** Use camelCase for variables and functions.\n\n* **Comments:** Write clear and concise comments to explain complex logic.\n\n* **Semicolons:** Use semicolons at the end of statements.\n\nRefer to the existing Bowser codebase for examples of the preferred coding style.  Consistent formatting is crucial for a smooth code review process.\n\n\n### Testing Your Changes\n\nBowser uses a comprehensive test suite.  Before submitting a pull request, ensure your changes pass all existing tests and add new tests for any new features or bug fixes.  Run the tests using the command specified in the project's README file.  Thorough testing is essential to ensure the quality and stability of Bowser.   Address any test failures before submitting your changes.\n\n\n### Submitting Pull Requests\n\n1. **Create a Branch:** Create a new branch for your changes:  `git checkout -b my-fix` or `git checkout -b my-feature`.\n\n2. **Make Your Changes:** Implement your changes and commit them with clear and concise commit messages.\n\n3. **Push Your Branch:** Push your branch to your forked repository: `git push origin my-fix` or `git push origin my-feature`.\n\n4. **Create a Pull Request:** On GitHub, create a pull request from your branch to the main Bowser repository's `main` branch.  Provide a clear description of your changes and address any comments from reviewers.\n\n5. **Address Feedback:** Respond to any comments or requests for changes from the Bowser maintainers.  Make necessary revisions and push updated commits to your branch.\n\nYour pull request will be reviewed by the Bowser team.  Be prepared to address any feedback or suggestions they might have.  Thank you for contributing!\n\n","srcMarkdownNoYaml":"\n\n\n### What is Bowser?\n\nBowser is a [insert concise and accurate description of Bowser, e.g.,  powerful, open-source framework for building cross-platform web applications.  It leverages [mention key technologies used, e.g.,  HTML5, WebAssembly, and a novel rendering engine] to deliver high-performance, visually stunning applications with a streamlined development process.].  It abstracts away many of the complexities of modern web development, allowing developers to focus on creating innovative user experiences.\n\n\n### Why use Bowser?\n\nBowser offers several key advantages for developers:\n\n* **Cross-Platform Compatibility:** Build once, deploy everywhere. Bowser applications run seamlessly across a wide range of devices and browsers without requiring platform-specific code adjustments.\n* **Enhanced Performance:**  Leveraging [mention specific technologies and their benefits, e.g., WebAssembly for computationally intensive tasks and optimized rendering for smooth animations], Bowser delivers exceptional performance and responsiveness.\n* **Simplified Development:**  Bowser's intuitive API and comprehensive toolset significantly reduce development time and effort, allowing for rapid prototyping and iteration.\n* **Extensibility:** Bowser is designed to be highly extensible, allowing developers to integrate custom components and functionalities seamlessly.\n* **[Add other compelling reasons, e.g., Large community support, Extensive documentation, Active development, etc.]**\n\n\n### Setting up Bowser\n\nSetting up Bowser for development involves the following steps:\n\n1. **Install Node.js and npm (or yarn):** Bowser requires Node.js and a package manager like npm or yarn.  Download and install the latest versions from the official Node.js website.\n2. **Clone the Bowser repository:** Use Git to clone the Bowser repository from [insert Git repository URL here].\n3. **Install dependencies:** Navigate to the cloned repository directory in your terminal and run `npm install` (or `yarn install`) to install all necessary dependencies.\n4. **[Add any other setup steps, e.g., configuring environment variables, setting up a build process, etc.]**\n5. **Run the development server:**  Start the development server using the command `npm start` (or `yarn start`). This will launch a local server, allowing you to test and debug your application.\n\n\n### System Requirements\n\nTo develop using Bowser, your system should meet the following minimum requirements:\n\n* **Operating System:**  [Specify supported OS, e.g., Windows 10, macOS 10.15+, Linux (Ubuntu 20.04+)]\n* **Node.js:**  [Specify minimum Node.js version, e.g., v16.0.0 or higher]\n* **npm (or yarn):**  [Specify minimum version if required, otherwise just state \"latest version recommended\"]\n* **Memory:**  [Specify minimum RAM, e.g., 8GB RAM recommended]\n* **Disk Space:**  [Specify minimum disk space, e.g., 10GB of free disk space]\n* **[Add any other requirements, e.g., specific graphics card capabilities, etc.]**\n\nIt is recommended to use a modern, reasonably powerful machine for optimal development experience.  Performance may be impacted on systems with limited resources.\n\n\n## Core Concepts\n\n### Browser Detection\n\nBowser's core functionality revolves around robust browser detection.  Instead of relying solely on the user agent string (which can be easily spoofed), Bowser employs a multi-pronged approach combining user agent parsing with feature detection. This ensures accurate and reliable browser identification, even in complex scenarios involving unusual user agents or browser extensions that modify default behavior.  The detection process prioritizes feature detection to provide the most accurate results.\n\n\n### Feature Detection\n\nBowser utilizes feature detection to determine the capabilities of the user's browser.  This approach is more reliable than relying solely on user agent strings, as it directly tests whether specific features are supported instead of inferring them from potentially outdated or manipulated user agent data.  Feature detection checks for the presence and functionality of various browser APIs and rendering capabilities, allowing Bowser to adapt its behavior accordingly and provide optimal performance across different browsers.  This ensures compatibility and prevents reliance on potentially inaccurate information provided by the user agent string.\n\n\n### User Agent Parsing\n\nWhile Bowser prioritizes feature detection, it still parses the user agent string to provide additional context and information.  This parsed information is used to supplement the feature detection results, offering a more complete picture of the browser and user environment.  The parsing process is designed to handle a wide range of user agent strings, including those from various browsers, mobile devices, and other user agents.  However, developers should remember that user agent strings can be manipulated, and feature detection should be the primary method for determining browser capabilities.\n\n\n### Parsing User Agent Strings\n\nBowser's internal user agent parsing engine is highly optimized for speed and accuracy.  It utilizes regular expressions and sophisticated parsing logic to extract relevant information from the user agent string, such as browser name, version, platform, and engine.  This parsed data is then used to enrich the browser detection process and provide more detailed information to developers.  While the specifics of the parsing algorithm are internal, the results are accessible through Bowser's API, allowing developers to retrieve parsed user agent information if needed.  However, it is crucial to reiterate that feature detection should be the primary method for determining browser capabilities, with user agent parsing used as a supplementary source of information.\n\n\n## API Reference\n\n### `getBrowser()`\n\nReturns a string representing the detected browser name (e.g., \"Chrome\", \"Firefox\", \"Safari\").  Returns `null` if no browser can be reliably detected. This function prioritizes feature detection over User Agent parsing.\n\n```javascript\nconst browser = Bowser.getBrowser();\nconsole.log(browser); // Output: \"Chrome\" (or similar)\n```\n\n### `getOS()`\n\nReturns a string representing the detected operating system (e.g., \"Windows\", \"macOS\", \"Android\", \"iOS\"). Returns `null` if no OS can be reliably detected.\n\n```javascript\nconst os = Bowser.getOS();\nconsole.log(os); // Output: \"macOS\" (or similar)\n```\n\n### `getDevice()`\n\nReturns a string representing the detected device type (e.g., \"Desktop\", \"Mobile\", \"Tablet\").  This is determined through a combination of user agent parsing and feature detection. Returns `null` if no device type can be reliably detected.\n\n```javascript\nconst device = Bowser.getDevice();\nconsole.log(device); // Output: \"Mobile\" (or similar)\n```\n\n### `getEngine()`\n\nReturns a string representing the detected browser engine (e.g., \"Blink\", \"Gecko\", \"WebKit\"). Returns `null` if no engine can be reliably detected.\n\n```javascript\nconst engine = Bowser.getEngine();\nconsole.log(engine); // Output: \"Blink\" (or similar)\n```\n\n### `getPlatform()`\n\nReturns a string representing the detected platform (e.g., \"Linux\", \"Win32\", \"MacIntel\"). This is a more granular representation than `getOS()` and may include architectural information.  Returns `null` if no platform can be reliably detected.\n\n```javascript\nconst platform = Bowser.getPlatform();\nconsole.log(platform); // Output: \"MacIntel\" (or similar)\n```\n\n### `getUa()`\n\nReturns the raw user agent string.\n\n```javascript\nconst ua = Bowser.getUa();\nconsole.log(ua); // Output: \"Mozilla/5.0 ...\" (or similar)\n```\n\n### `getVersion()`\n\nReturns a string representing the detected browser version (e.g., \"115.0.5790.171\").  Returns `null` if no version can be reliably detected.\n\n```javascript\nconst version = Bowser.getVersion();\nconsole.log(version); // Output: \"115.0.5790.171\" (or similar)\n```\n\n### `isSupported()`\n\nChecks if a specific browser version or feature is supported.  Requires a browser name and version string as arguments.  Returns a boolean indicating support.  (See documentation for detailed argument formatting.)\n\n\n```javascript\nconst supported = Bowser.isSupported('chrome', '100');\nconsole.log(supported); // Output: true or false\n```\n\n### `getFeature()`\n\nChecks for the support of a specific feature. This is more reliable than relying solely on version numbers.  Returns a boolean indicating whether the feature is supported. (See documentation for a list of supported features.)\n\n```javascript\nconst supportsWebP = Bowser.getFeature('webp');\nconsole.log(supportsWebP); // Output: true or false\n```\n\n### `parse()`\n\nParses a given user agent string.  Useful for processing user agent strings from external sources.  Returns an object containing parsed browser information.\n\n```javascript\nconst parsedUserAgent = Bowser.parse('Mozilla/5.0...');\nconsole.log(parsedUserAgent);\n```\n\n### `utils.isMobile()`\n\nReturns a boolean indicating whether the current device is a mobile device.\n\n```javascript\nconst isMobile = Bowser.utils.isMobile();\nconsole.log(isMobile); // Output: true or false\n```\n\n### `utils.isTablet()`\n\nReturns a boolean indicating whether the current device is a tablet.\n\n```javascript\nconst isTablet = Bowser.utils.isTablet();\nconsole.log(isTablet); // Output: true or false\n```\n\n### `utils.isDesktop()`\n\nReturns a boolean indicating whether the current device is a desktop computer.\n\n```javascript\nconst isDesktop = Bowser.utils.isDesktop();\nconsole.log(isDesktop); // Output: true or false\n```\n\n### `utils.isBot()`\n\nReturns a boolean indicating whether the current user agent belongs to a bot or crawler.\n\n```javascript\nconst isBot = Bowser.utils.isBot();\nconsole.log(isBot); // Output: true or false\n```\n\n\n## Advanced Usage\n\n### Custom User Agent Parsing\n\nWhile Bowser's built-in user agent parsing is robust, you might need to customize it for specific scenarios.  This can be achieved by providing a custom parsing function.  Bowser allows you to override its internal parsing logic by providing a function that takes the raw user agent string as input and returns a parsed object.  The structure of this object should match Bowser's internal representation (consult the source code for details).  This allows for highly specialized parsing of uncommon or custom user agent strings that might not be handled correctly by the default parser.  Refer to the advanced usage examples in the Bowser repository for detailed instructions on implementing a custom parser.\n\n### Extending Bowser's Capabilities\n\nBowser is designed to be extensible. You can extend its functionality by adding support for new browsers, features, or devices. This usually involves updating the internal browser detection tables and potentially adding new feature detection functions. The process generally requires familiarity with Bowser's internal structure and might involve contributing back to the main Bowser project. For detailed information on extending Bowser's capabilities, please consult the contribution guidelines in the project's repository.\n\n### Integration with Other Libraries\n\nBowser integrates seamlessly with various JavaScript libraries and frameworks.  Its lightweight nature and straightforward API facilitate easy integration.  For example, you can use Bowser's detection results to conditionally load different versions of a library based on the detected browser capabilities, providing optimized performance for different user environments.  There are no specific integration requirements; simply include Bowser in your project and call its functions as needed. The key is using the results of Bowser's detection methods to drive conditional logic in your application.\n\n### Troubleshooting\n\nThis section addresses common issues encountered when using Bowser:\n\n* **Inaccurate browser detection:** If Bowser is not detecting a browser correctly, ensure that feature detection is enabled.  Incorrect results may stem from relying solely on the user agent string, which can be unreliable.  Check if the browser in question is supported.  If it's a newly released or less common browser, Bowser might require updates.\n\n* **Missing features:**  Bowser relies on feature detection to determine if specific browser features are present.  If a feature isn't detected, ensure the feature exists in the browser being tested.  Also verify that any necessary browser APIs are correctly implemented and accessible.\n\n* **Performance issues:** Bowser is designed to be lightweight and efficient.  Performance issues are rarely attributed to Bowser itself, and are usually related to the application code utilizing Bowser.  Profile your application to identify performance bottlenecks.\n\n* **Errors in custom parsers:**  When using custom parsing, ensure your parser's output structure adheres to Bowser's internal data format.  Incorrectly structured output can lead to unexpected behavior or errors.\n\nIf you encounter problems not covered here, check the Bowser issue tracker or community forums for solutions.  Include details of your environment, the Bowser version used, and steps to reproduce the problem when reporting issues.\n\n\n## Best Practices\n\n### Writing Robust Browser-Specific Code\n\nWhen writing browser-specific code, prioritize feature detection over relying solely on user agent strings or browser names.  Use Bowser's `getFeature()` method to check for the availability of specific functionalities before using them.  This ensures that your application gracefully handles cases where a feature might be absent.  Avoid writing extensive `if/else` blocks based on browser names; instead, design your code to adapt to different feature sets, making it more maintainable and less prone to errors as browsers evolve.  Organize your browser-specific code into modular components to improve code clarity and reusability.\n\n### Handling Unsupported Browsers\n\nWhile Bowser aims for broad compatibility, some very old or obscure browsers might not be fully supported.  Implement graceful fallback mechanisms to handle cases where Bowser detects an unsupported browser.  Provide users with clear instructions on how to upgrade their browser to a supported version or use an alternative method to access the application's functionality.  Consider using a polite and informative message to inform users about the incompatibility rather than simply showing a broken application.  This improves the user experience and helps you gauge the support you need to provide.\n\n### Optimizing for Performance\n\nBowser itself is designed for optimal performance, but using it effectively requires attention to other aspects of your application. Minimize the number of browser detection calls, especially within performance-critical sections of your code.  Cache the results of Bowser's detection methods to avoid redundant calls. Use Bowser's detection results to optimize your application's behavior by loading only the necessary resources or using alternative algorithms that are optimized for different browsers or devices.  This reduces load times and improves the overall user experience.\n\n### Security Considerations\n\nAlways validate user input to prevent vulnerabilities, regardless of the browser used.  Avoid relying solely on client-side browser detection for security decisions; perform server-side validation as well.  Ensure that any browser-specific code is secure and doesn't create unintended vulnerabilities.  Regularly update Bowser to benefit from bug fixes and security patches.  Keep your dependencies up-to-date, as outdated libraries can introduce vulnerabilities.  Follow secure coding practices to prevent cross-site scripting (XSS) and other common web vulnerabilities, independent of your use of Bowser.\n\n\n## Contributing to Bowser\n\nWe welcome contributions to Bowser!  Whether you're fixing bugs, adding new features, or improving documentation, your help is valuable.  Here's how you can contribute:\n\n\n### Setting up the Development Environment\n\n1. **Fork the Repository:** Fork the official Bowser repository on GitHub to your personal account.\n\n2. **Clone Your Fork:** Clone your forked repository to your local machine using Git:  `git clone git@github.com:YOUR_USERNAME/bowser.git` (replace `YOUR_USERNAME` with your GitHub username).\n\n3. **Install Dependencies:** Navigate to the project directory and install the necessary dependencies using npm or yarn:  `npm install` or `yarn install`.\n\n4. **Set up the Development Server (optional but recommended):** Bowser uses a development server for testing.  Refer to the project's README for instructions on starting the development server.\n\n5. **Choose Your Issue:** Browse the issue tracker for bugs to fix or features to implement.  If you have an idea for a new feature, create a new issue to discuss it before starting work.\n\n\n### Coding Style Guide\n\nBowser follows a consistent coding style to ensure readability and maintainability.  Adhere to the following guidelines:\n\n* **Indentation:** Use 2 spaces for indentation.\n\n* **Line Length:** Keep lines under 80 characters.\n\n* **Naming Conventions:** Use camelCase for variables and functions.\n\n* **Comments:** Write clear and concise comments to explain complex logic.\n\n* **Semicolons:** Use semicolons at the end of statements.\n\nRefer to the existing Bowser codebase for examples of the preferred coding style.  Consistent formatting is crucial for a smooth code review process.\n\n\n### Testing Your Changes\n\nBowser uses a comprehensive test suite.  Before submitting a pull request, ensure your changes pass all existing tests and add new tests for any new features or bug fixes.  Run the tests using the command specified in the project's README file.  Thorough testing is essential to ensure the quality and stability of Bowser.   Address any test failures before submitting your changes.\n\n\n### Submitting Pull Requests\n\n1. **Create a Branch:** Create a new branch for your changes:  `git checkout -b my-fix` or `git checkout -b my-feature`.\n\n2. **Make Your Changes:** Implement your changes and commit them with clear and concise commit messages.\n\n3. **Push Your Branch:** Push your branch to your forked repository: `git push origin my-fix` or `git push origin my-feature`.\n\n4. **Create a Pull Request:** On GitHub, create a pull request from your branch to the main Bowser repository's `main` branch.  Provide a clear description of your changes and address any comments from reviewers.\n\n5. **Address Feedback:** Respond to any comments or requests for changes from the Bowser maintainers.  Make necessary revisions and push updated commits to your branch.\n\nYour pull request will be reviewed by the Bowser team.  Be prepared to address any feedback or suggestions they might have.  Thank you for contributing!\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["../../styles.css"],"html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"},"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"},"../../footer.html"],"output-file":"bowser.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"license":"MIT","author-meta":"Muthukrishnan","title":"Bowser - Documentation","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}