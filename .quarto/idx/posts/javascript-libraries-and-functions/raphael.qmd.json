{"title":"Raphael - A Developer's Handbook","markdown":{"yaml":{"title":"Raphael - A Developer's Handbook","categories":["JavaScript Libraries and Functions"]},"headingText":"Introduction to Raphael.js","containsRefs":false,"markdown":"\n\n### What is Raphael.js?\n\nRaphael.js is a small JavaScript library that allows you to create vector graphics on the fly in any browser that supports SVG, VML, or Canvas.  It provides a simple and consistent interface for creating and manipulating various vector shapes, including paths, ellipses, rectangles, text, and images.  This simplifies the process of adding interactive and dynamic vector graphics to your web applications without the complexities of directly working with SVG or other vector formats.  Raphael.js handles the browser-specific rendering details, allowing you to focus on the design and functionality of your graphics.\n\n\n### Setting up Raphael.js\n\nRaphael.js can be included in your project in a few ways:\n\n* **Download:** Download the minified `raphael.min.js` file from the official Raphael.js website and place it in your project's JavaScript directory.\n* **CDN:** Include the library via a CDN such as jsDelivr:  `<script src=\"https://cdn.jsdelivr.net/npm/raphael@2.3.0/raphael.min.js\"></script>`.  Remember to replace `2.3.0` with the desired version number if needed.  Check the official website for the latest version.\n* **NPM/Yarn:** If you are using a package manager like npm or Yarn, you can install Raphael.js using the command `npm install raphael` or `yarn add raphael`.  Then, import it into your project as needed (the specific import syntax depends on your module bundler).\n\n\nOnce included,  you can use the `Raphael` object in your JavaScript code.\n\n\n### Browser Compatibility\n\nRaphael.js aims for broad browser compatibility. While it primarily leverages SVG for rendering, it falls back to VML for older Internet Explorer versions and Canvas as a last resort.  However, for optimal performance and feature support, using modern browsers with SVG support is recommended.  Consult the official Raphael.js documentation or release notes for the most up-to-date browser compatibility information.\n\n\n### Basic Example\n\nThis example creates a simple red circle with a radius of 50 pixels at position (50,50) on the page:\n\n```javascript\n// Create a canvas that's 300 pixels wide by 200 pixels tall\nvar paper = Raphael(\"canvas\", 300, 200); // Replace \"canvas\" with your canvas element ID\n\n// Create a circle shape\nvar circle = paper.circle(50, 50, 50);\n\n// Set the circle's fill color to red\ncircle.attr({fill: \"red\"});\n```\n\nRemember to include the Raphael.js library and create a `<div>` element with the ID \"canvas\" in your HTML file:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<title>Raphael.js Example</title>\n</head>\n<body>\n<div id=\"canvas\"></div>\n<script src=\"raphael.min.js\"></script>  <!-- Or CDN link -->\n<script>\n  // JavaScript code from the example above goes here\n</script>\n</body>\n</html>\n```  This will display a red circle on your page.  This basic example provides a starting point for exploring the numerous functionalities offered by Raphael.js.\n\n\n## Creating Shapes\n\n### Creating Circles\n\nRaphael.js provides the `circle()` method to create circles.  It takes three arguments: the x-coordinate of the center, the y-coordinate of the center, and the radius.  The returned object is a Raphael element representing the circle, which can be further manipulated using attribute methods.\n\n```javascript\n// Create a paper object (replace \"canvas\" with your canvas element ID)\nvar paper = Raphael(\"canvas\", 500, 300);\n\n// Create a circle with center at (50, 50) and radius 25\nvar myCircle = paper.circle(50, 50, 25);\n\n// Set attributes (optional):\nmyCircle.attr({\n  fill: \"blue\",       // Fill color\n  stroke: \"red\",     // Stroke color\n  \"stroke-width\": 3   // Stroke width\n});\n```\n\n\n### Creating Rectangles\n\nThe `rect()` method creates rectangles. It takes four arguments: the x-coordinate of the top-left corner, the y-coordinate of the top-left corner, the width, and the height.\n\n```javascript\n// Create a rectangle with top-left corner at (150, 50), width 100, height 50\nvar myRect = paper.rect(150, 50, 100, 50);\nmyRect.attr({\n  fill: \"green\",\n  stroke: \"black\",\n  \"stroke-width\": 2\n});\n```\n\n### Creating Ellipses\n\nEllipses are created using the `ellipse()` method. It requires four arguments: the x-coordinate of the center, the y-coordinate of the center, the radius on the x-axis, and the radius on the y-axis.\n\n```javascript\n// Create an ellipse with center at (300, 50), x-radius 50, y-radius 25\nvar myEllipse = paper.ellipse(300, 50, 50, 25);\nmyEllipse.attr({\n  fill: \"yellow\",\n  stroke: \"purple\",\n  \"stroke-width\": 1\n});\n```\n\n\n### Creating Paths\n\nPaths offer the most flexibility for creating complex shapes.  The `path()` method accepts a string describing the path using SVG path syntax.  This syntax uses commands like `M` (moveto), `L` (lineto), `C` (curveto), `Z` (closepath), etc.\n\n```javascript\n// Create a star shape using path commands\nvar myPath = paper.path(\"M100,150 L120,100 L180,100 L200,150 L160,190 L120,190 Z\");\nmyPath.attr({fill: \"orange\"});\n```\n\n\n### Creating Images\n\nRaphael.js allows you to add images to the canvas using the `image()` method.  It requires five arguments: the URL of the image, the x-coordinate, the y-coordinate, the width, and the height.\n\n```javascript\n// Add an image (replace with your image URL)\nvar myImage = paper.image(\"myimage.jpg\", 200, 150, 50, 50);\n```\n\n\n### Creating Text\n\nThe `text()` method creates text elements.  It accepts three arguments: the x-coordinate, the y-coordinate, and the text string.\n\n```javascript\n// Add text at (100, 250)\nvar myText = paper.text(100, 250, \"Hello, Raphael!\");\nmyText.attr({\n  \"font-size\": 20,\n  \"font-family\": \"Arial\",\n  \"fill\": \"black\"\n});\n```\n\nRemember that in all these examples, you need to have a `Raphael` paper object created first, typically by using `Raphael(containerID, width, height)`, where `containerID` is the ID of a `<div>` or other suitable HTML element.  The width and height values specify the dimensions of the drawing canvas.\n\n\n## Manipulating Shapes\n\n### Translation\n\nTranslation moves a shape along the x and y axes.  Raphael.js uses the `translate()` method for this.  It takes two arguments: the horizontal displacement (dx) and the vertical displacement (dy).\n\n```javascript\nvar paper = Raphael(\"canvas\", 500, 300);\nvar rect = paper.rect(50, 50, 100, 50);\n\n// Translate the rectangle 50 pixels to the right and 20 pixels down\nrect.translate(50, 20);\n```\n\n### Scaling\n\nScaling changes the size of a shape. The `scale()` method takes two arguments: the horizontal scaling factor (sx) and the vertical scaling factor (sy).  A value of 1 means no scaling, values greater than 1 enlarge the shape, and values less than 1 reduce its size.  An optional third argument specifies the x and y coordinates of the scaling center (defaults to the shape's center).\n\n```javascript\nvar circle = paper.circle(150, 150, 30);\n// Scale the circle to twice its size, centered at its current center.\ncircle.scale(2, 2);\n\n// Scale the circle to half its size, with the scaling origin at 200,150.\ncircle.scale(0.5, 0.5, 200,150);\n```\n\n### Rotation\n\nRotation turns a shape around a given point. The `rotate()` method takes one argument: the angle of rotation in degrees (clockwise). An optional second and third argument specify the x and y coordinates of the rotation center (defaults to the shape's center).\n\n\n```javascript\nvar ellipse = paper.ellipse(300, 150, 40, 20);\n// Rotate the ellipse 45 degrees counter-clockwise around its center\nellipse.rotate(45);\n\n//Rotate the ellipse 30 degrees clockwise around the point (350, 180)\nellipse.rotate(-30, 350, 180);\n```\n\n\n### Transformations\n\nRaphael.js also provides a `transform()` method that allows combining multiple transformations (translate, scale, rotate) using a single string.  The string uses a space-separated list of transformations in the form `[command][x][y][z]`, where the command is `t` for translate, `s` for scale, `r` for rotate, and `m` for matrix transformation.\n\n```javascript\nvar path = paper.path(\"M10,10 L100,100\");\n\n// Apply multiple transformations: translate, then rotate\npath.transform(\"t10,20r30\");\n\n//Applying matrix transform.  Note that matrix transformation requires 6 arguments.\npath.transform(\"m1,0,0,1,10,10\"); //This translates the path 10 pixels to the right and 10 pixels down.\n```\n\n\n### Attributes\n\nAttributes control various aspects of a shape's appearance, such as fill color, stroke color, stroke width, opacity, etc.  These are set using the `attr()` method.  You can set multiple attributes at once using an object as an argument.\n\n```javascript\nvar square = paper.rect(10, 10, 40, 40);\n\n//Set attributes\nsquare.attr({\n    \"fill\": \"#f00\", //red fill\n    \"stroke\": \"#000\", //black stroke\n    \"stroke-width\": 5,\n    \"opacity\": 0.5\n});\n\n//Get a specific attribute\nlet fillColor = square.attr(\"fill\"); //Gets the fill color\nconsole.log(fillColor);\n\n\n```\n\n### Animation\n\nRaphael.js provides powerful animation capabilities using the `animate()` method. This method allows you to smoothly change a shape's attributes over time. It takes two arguments: an object containing the target attribute values and the animation duration in milliseconds.  An optional third argument specifies an easing function (e.g., '>', '<', '<>', 'backIn', etc.).\n\n```javascript\nvar circle = paper.circle(100, 100, 20);\n\n// Animate the circle to a new position and size over 1000 milliseconds\ncircle.animate({cx: 200, cy: 200, r: 40}, 1000, \">\");\n\n\n// Example with a callback function:\ncircle.animate({cx: 100, cy: 100, r: 20}, 1000, function(){\n    console.log(\"Animation complete!\");\n});\n```\n\nRemember to consult the Raphael.js documentation for a complete list of attributes and easing functions available.  The `animate` function allows chaining animations but subsequent animations overwrite previous animations. To queue animations, use the `animateWith` function instead.\n\n\n## Working with Paths\n\n### Path String Syntax\n\nPaths in Raphael.js are defined using a string following the SVG path syntax. This string consists of a series of commands and their corresponding coordinates.  Each command is a single letter, followed by numerical parameters separated by commas.\n\nHere are some common commands:\n\n* **`M x y` (Moveto):** Moves the \"pen\" to the specified coordinates (x, y) without drawing.  This typically starts a new subpath.\n* **`L x y` (Lineto):** Draws a straight line from the current point to the specified coordinates (x, y).\n* **`H x` (Horizontal lineto):** Draws a horizontal line to the specified x-coordinate.\n* **`V y` (Vertical lineto):** Draws a vertical line to the specified y-coordinate.\n* **`C x1 y1 x2 y2 x y` (Curveto):** Draws a Bézier curve with control points (x1, y1) and (x2, y2), and ending at (x, y).\n* **`S x2 y2 x y` (Smooth curveto):** Draws a Bézier curve similar to `C`, but the first control point is automatically reflected from the previous curve's control point.\n* **`Q x1 y1 x y` (Quadratic Bézier curveto):** Draws a quadratic Bézier curve with a single control point (x1, y1) and ending at (x, y).\n* **`T x y` (Smooth quadratic Bézier curveto):** Similar to `Q`, but the control point is reflected from the previous curve's control point.\n* **`A rx ry x-axis-rotation large-arc-flag sweep-flag x y` (Elliptical arc):** Draws an elliptical arc. This command has many parameters, consult SVG documentation for details.\n* **`Z` (Closepath):** Closes the current subpath by drawing a straight line back to the starting point of the subpath.\n\nCommands are case-insensitive, but it's best practice to use uppercase for consistency.  Multiple commands can be chained together in a single string. For example:  `\"M10 10 L 100 100 L 100 200 Z\"` creates a closed right-angled triangle.\n\n\n### Path Manipulation\n\nOnce a path is created using `paper.path(pathString)`, you can manipulate it in several ways:\n\n* **`path.attr({path: newPathString})`:**  This is the most common method to modify the path's shape.  You provide a new path string to redefine the path entirely.\n\n* **`path.getSubpath(from, to)`:** This extracts a portion of the path as a new path string.  `from` and `to` specify the start and end indices of the segment to be extracted.\n\n\n* **`path.getTotalLength()`:** Returns the total length of the path. Useful for creating animations along the path.\n\n* **`path.getPointAtLength(length)`:** Returns an object `{x, y, alpha}` representing the point at the specified length along the path.  This is essential for animations or finding coordinates along the path.\n\n\n### Creating Complex Shapes with Paths\n\nPaths are essential for creating complex shapes that cannot be easily represented with simple primitives like rectangles or circles.  By combining various commands, you can generate intricate designs.\n\n```javascript\nvar paper = Raphael(\"canvas\", 500, 300);\n\n// Example: Creating a star shape\nvar star = paper.path(\"M150,100 L180,160 L240,160 L180,220 L210,280 L150,230 L90,280 L120,220 L60,160 L120,160 Z\");\nstar.attr({fill: \"gold\"});\n\n\n//Example: Creating a curved shape\nvar curvedShape = paper.path(\"M 50,50 C 50,150 200,150 200,50 L 200,100 C 200, 200, 100,200, 100,100 L100,50 Z\");\ncurvedShape.attr({fill: \"lightblue\", stroke: \"darkblue\"});\n\n\n```\n\nRemember that complex paths can become difficult to manage manually. Consider using tools or libraries that help you generate SVG path strings for more intricate shapes if needed.  The examples above illustrate the power and flexibility of paths in constructing diverse and elaborate vector graphics.\n\n\n## Color and Styles\n\n### Fill and Stroke\n\nIn Raphael.js, the `fill` attribute determines the color or pattern used to fill a shape's interior, while the `stroke` attribute sets the color and style of the shape's outline (border).  Both are specified using the `attr()` method.  If `fill` is omitted, the shape is not filled; if `stroke` is omitted, it has no outline.\n\n```javascript\nvar paper = Raphael(\"canvas\", 300, 200);\nvar rect = paper.rect(10, 10, 100, 50);\n\nrect.attr({\n  fill: \"blue\", //Solid blue fill\n  stroke: \"red\",  //red stroke\n  \"stroke-width\": 5 //Stroke width of 5 pixels\n});\n\nvar circle = paper.circle(150, 100, 40);\ncircle.attr({stroke: \"green\"}); //Only a green stroke, no fill\n\n```\n\n### Color Definitions\n\nColors can be specified in several ways:\n\n* **Named colors:**  Use standard HTML color names (e.g., \"red\", \"green\", \"blue\", \"yellow\", etc.).\n* **Hexadecimal notation:** Use hex codes (e.g., \"#FF0000\" for red, \"#00FF00\" for green, \"#0000FF\" for blue).\n* **RGB notation:** Use RGB values (e.g., \"rgb(255, 0, 0)\" for red).\n* **RGBA notation:** Use RGBA values, including alpha (opacity) channel (e.g., \"rgba(255, 0, 0, 0.5)\" for semi-transparent red).\n\n\n### Gradient Fills\n\nRaphael.js supports linear and radial gradients for fills.  These are defined using the `attr()` method with a specific format for the `fill` attribute.\n\n**Linear Gradient:**\n\n```javascript\nvar rect = paper.rect(10, 150, 100, 50);\nrect.attr({\n  fill: \"90-#000-#fff\" // Linear gradient from black to white, angle 90 degrees\n});\n\n\n//More detailed linear gradient.  Note that gradient stops can be specified with an offset.\nvar rect2 = paper.rect(120, 150, 100, 50);\nrect2.attr({fill: \"l(0,0)0:#ff0000:10#00ff00:20#0000ff\"}); // linear gradient with specified stops\n```\n\n**Radial Gradient:**\n\n```javascript\nvar circle = paper.circle(200, 100, 40);\ncircle.attr({\n    fill: \"r(0.5,0.5,0.3)#f00-#00f\" // radial gradient from red to blue\n});\n```\n\nThe syntax for gradients might vary slightly depending on the Raphael.js version. Check the official documentation for your version.\n\n\n### Stroke Styles\n\nBesides `stroke` color, you can control the stroke style with these attributes:\n\n* **`\"stroke-width\"`:** Specifies the width of the stroke in pixels.\n* **`\"stroke-linecap\"`:** Defines the shape of the stroke ends (\"butt\", \"round\", \"square\").\n* **`\"stroke-linejoin\"`:** Specifies the shape at the corner where two lines meet (\"miter\", \"round\", \"bevel\").\n* **`\"stroke-dasharray\"`:** Creates dashed or dotted lines.  The value is a comma-separated list of dash and gap lengths (e.g., \"5,5\" for a 5-pixel dash followed by a 5-pixel gap).\n\n\n```javascript\nvar path = paper.path(\"M10,10 L100,10 L100,100 L10,100 Z\");\npath.attr({\n  \"stroke-width\": 10,\n  \"stroke-linecap\": \"round\",\n  \"stroke-linejoin\": \"round\",\n  \"stroke-dasharray\": \"10,5\"\n});\n```\n\n### Opacity\n\nOpacity controls the transparency of both fill and stroke.  It's set using the `\"opacity\"` attribute, with a value between 0 (fully transparent) and 1 (fully opaque).\n\n```javascript\nvar ellipse = paper.ellipse(150, 175, 30, 20);\nellipse.attr({\n  fill: \"rgba(0,0,255,0.5)\", //Blue with 50% opacity\n  \"opacity\": 0.7 //Overall opacity affecting both stroke and fill\n});\n```\n\nNote that the opacity applied directly to the fill attribute via RGBA and the overall opacity applied via the `opacity` attribute will interact.  The resulting opacity will be the product of the two.\n\n\n## Text and Typography\n\n### Text Attributes\n\nRaphael.js provides several attributes to control the appearance of text elements. These attributes are set using the `attr()` method, similar to other shape attributes. Key attributes include:\n\n* **`text`:** The actual text string displayed.\n* **`font`:** A shorthand for setting font family, size, style (e.g., \"12px Arial\", \"bold 16px Times New Roman\").\n* **`font-family`:** Specifies the font family (e.g., \"Arial\", \"Times New Roman\", \"Helvetica\").\n* **`font-size`:** Sets the font size in pixels (e.g., \"12px\", \"16px\").\n* **`font-weight`:** Sets the font weight (e.g., \"normal\", \"bold\", \"bolder\").\n* **`font-style`:** Sets the font style (e.g., \"normal\", \"italic\", \"oblique\").\n* **`fill`:** Sets the text color (same as shape fill).\n* **`x` and `y`:**  Coordinates of the text anchor point.  Note this is different from the bounding box.\n* **`text-anchor`:**  Controls text alignment within the bounding box (\"start\", \"middle\", \"end\").\n\n\n```javascript\nvar paper = Raphael(\"canvas\", 300, 200);\nvar text = paper.text(100, 50, \"Sample Text\");\ntext.attr({\n  \"font-family\": \"Times New Roman\",\n  \"font-size\": 20,\n  \"font-weight\": \"bold\",\n  \"fill\": \"blue\",\n  \"text-anchor\": \"middle\"\n});\n```\n\n\n### Font Families\n\nRaphael.js uses browser-available fonts.  If a specified font is not available, the browser will substitute a default font.  To ensure consistent rendering across different systems, it's a good practice to provide fallback fonts. You can list multiple font families separated by commas in the `font-family` attribute (e.g., `\"font-family\": \"Arial, Helvetica, sans-serif\"`).\n\n\n### Font Sizes\n\nFont size is specified in pixels using the `font-size` attribute.  The value should be a numerical value followed by \"px\".  Larger values result in larger text.\n\n\n### Text Alignment\n\nText alignment is controlled using the `text-anchor` attribute.  The three possible values are:\n\n* **`\"start\"`:** Aligns the text to the left.\n* **`\"middle\"`:** Centers the text horizontally.\n* **`\"end\"`:** Aligns the text to the right.\n\nThe anchor point (defined by `x` and `y`) is relative to the alignment.  For example, with `\"text-anchor\": \"middle\"`, the `x` coordinate positions the center of the text.\n\n\n### Text Wrapping\n\nRaphael.js itself doesn't directly support text wrapping.  To achieve text wrapping, you will typically need to use a combination of techniques:\n\n1. **Measure Text Width:**  Use `text.getBBox().width` to get the width of the rendered text. This requires the text element to be already rendered on the page.\n\n2. **Split the Text:** Divide the text into multiple lines using JavaScript based on your desired line width.\n\n3. **Create Multiple Text Elements:** Create multiple `paper.text()` elements, placing each line at the appropriate vertical position, and setting the `x` and `y` coordinates accordingly.\n\nThis approach allows you to manually break the text into lines, offering full control over the text layout, but involves more manual coding.  Consider external libraries if more sophisticated text wrapping is required.\n\n\n\n\n## Event Handling\n\n### Attaching Event Handlers\n\nRaphael.js allows you to attach event handlers to shapes using the standard DOM event model.  The most common way is to use the `on()` method.  This method takes two arguments: the event type (e.g., \"click\", \"mouseover\", \"mouseout\", \"mousedown\", \"mouseup\", \"mousemove\", \"dblclick\", \"touchstart\", \"touchmove\", \"touchend\") and a callback function.\n\n\n```javascript\nvar paper = Raphael(\"canvas\", 300, 200);\nvar rect = paper.rect(50, 50, 100, 50);\n\nrect.on(\"click\", function() {\n  console.log(\"Rectangle clicked!\");\n  this.attr({ fill: \"red\" }); //Change the fill on click\n});\n\nrect.on(\"mouseover\", function() {\n  this.attr({ fill: \"yellow\" }); //Change fill on mouseover\n});\n\nrect.on(\"mouseout\", function(){\n    this.attr({fill: \"blue\"}); //Change fill back to blue when mouse leaves\n});\n\n```\n\nThe callback function receives an event object as an argument, providing information about the event.  The `this` keyword inside the callback function refers to the Raphael element (the shape) that triggered the event.\n\n\n### Event Types\n\nRaphael.js supports a wide range of standard DOM events. Some of the most commonly used events include:\n\n* **`click`:** Triggered when the user clicks on the shape.\n* **`dblclick`:** Triggered when the user double-clicks on the shape.\n* **`mousedown`:** Triggered when the user presses a mouse button while the pointer is over the shape.\n* **`mouseup`:** Triggered when the user releases a mouse button while the pointer is over the shape.\n* **`mouseover`:** Triggered when the mouse pointer enters the area of the shape.\n* **`mouseout`:** Triggered when the mouse pointer leaves the area of the shape.\n* **`mousemove`:** Triggered repeatedly as the mouse pointer moves over the shape.\n* **`touchstart`, `touchmove`, `touchend`:** Touch events for mobile devices.\n\n\n\n### Event Propagation\n\nEvent propagation refers to the order in which events are handled when nested elements are involved.  In Raphael.js, event propagation follows the standard DOM event model:\n\n* **Capturing Phase:** The event travels down the DOM tree from the window to the target element.  Event listeners attached in the capturing phase are triggered first.  Raphael doesn't directly expose capturing phase event listeners.\n\n* **Target Phase:**  The event reaches the target element (the shape that triggered the event).  Event listeners attached directly to the target element are triggered.\n\n* **Bubbling Phase:** The event travels back up the DOM tree from the target element to the window.  Event listeners attached to ancestor elements are triggered.\n\nBy default, Raphael events bubble up the DOM tree.  You can prevent event bubbling using the `event.stopPropagation()` method within your event handler.\n\n```javascript\nvar paper = Raphael(\"canvas\", 300, 200);\nvar rect1 = paper.rect(50, 50, 100, 50);\nvar rect2 = paper.rect(70, 70, 50, 50); //Nested rect inside rect1\n\n\nrect1.on(\"click\", function(event){\n    console.log(\"rect1 clicked!\");\n});\n\nrect2.on(\"click\", function(event){\n    console.log(\"rect2 clicked!\");\n    event.stopPropagation(); //Prevents event from bubbling to rect1\n});\n```\n\nIn this example, clicking on `rect2` will only log \"rect2 clicked!\", because `event.stopPropagation()` prevents the event from bubbling up to `rect1`.  Clicking on the area of `rect1` that is *not* covered by `rect2` will log both \"rect1 clicked!\" and \"rect2 clicked!\".\n\n\n## Advanced Techniques\n\n### Creating Custom Shapes\n\nWhile Raphael.js provides basic shapes, you can create custom shapes using paths or by combining multiple shapes into more complex structures. For truly custom shapes, consider creating your own shape-drawing functions that generate path strings based on parameters you define.  This allows you to reuse your custom shape creation logic throughout your application.\n\n\n```javascript\n// Example: Function to create a rounded rectangle\nfunction createRoundedRect(x, y, width, height, cornerRadius) {\n  var pathStr = \"M\" + x + \",\" + (y + cornerRadius) + \n               \" L\" + (x + width - cornerRadius) + \",\" + y +\n               \" Q\" + (x + width) + \",\" + y + \" \" + (x + width) + \",\" + (y + cornerRadius) +\n               \" L\" + (x + width) + \",\" + (y + height - cornerRadius) +\n               \" Q\" + (x + width) + \",\" + (y + height) + \" \" + (x + width - cornerRadius) + \",\" + (y + height) +\n               \" L\" + (x + cornerRadius) + \",\" + (y + height) +\n               \" Q\" + x + \",\" + (y + height) + \" \" + x + \",\" + (y + height - cornerRadius) +\n               \" L\" + x + \",\" + (y + cornerRadius) + \" Z\";\n  return paper.path(pathStr);\n}\n\nvar paper = Raphael(\"canvas\", 300, 200);\nvar myRoundedRect = createRoundedRect(50, 50, 100, 50, 10); //Creates a rounded rectangle with 10px corner radius\nmyRoundedRect.attr({fill: \"lightgreen\"});\n```\n\n\n\n### Working with Groups\n\nRaphael.js allows grouping shapes together using the `paper.set()` method.  Grouping is useful for applying transformations or events to multiple shapes simultaneously.\n\n```javascript\nvar paper = Raphael(\"canvas\", 300, 200);\nvar circle = paper.circle(50, 50, 20);\nvar rect = paper.rect(70, 70, 40, 40);\n\nvar group = paper.set(circle, rect); // Group the circle and rectangle\n\n//Apply transformation to the entire group\ngroup.translate(100, 0);\n\n// Apply an event handler to the group\ngroup.on(\"click\", function(){\n    this.attr({fill: \"orange\"});\n});\n```\n\nRemember that events on a group will bubble up to the individual elements. If you need finer-grained control over event handling on the group's elements consider using event delegation.\n\n\n\n### Using Raphael with Other Libraries\n\nRaphael.js can be integrated with other JavaScript libraries. Common use cases involve using it alongside animation libraries (like GreenSock/GSAP) for more sophisticated animations, or with UI frameworks for creating interactive components.\n\n\n### Performance Optimization\n\nFor complex graphics, performance optimization is crucial.  Consider these strategies:\n\n* **Minimize DOM manipulations:**  Batch attribute changes using `attr()` instead of changing attributes individually in multiple calls.\n* **Use caching:**  Pre-calculate values or create reusable elements to avoid repeated calculations.\n* **Reduce the number of elements:**  Combine elements where possible to reduce the number of elements the browser has to render.\n* **Optimize path complexity:** Use simpler path definitions whenever feasible.  Overly complex paths can impact performance.\n* **Use transformations effectively:** Transformations are generally more performant than repeatedly changing individual element coordinates.\n* **Consider using a canvas fallback:** If performance is critical, consider utilizing Canvas for specific parts of your drawing if your target browser supports it.\n\n\n### Debugging\n\nDebugging Raphael.js applications often involves standard JavaScript debugging techniques.  Use your browser's developer tools (console, debugger) to inspect variables, set breakpoints, and step through your code.  Pay close attention to error messages in the console, as they often provide valuable clues to identify issues.  Remember to check the Raphael.js documentation and community forums for troubleshooting assistance, as many common problems and their solutions are already documented.\n\n\n## Common Use Cases\n\n### Creating Charts\n\nRaphael.js is well-suited for creating various types of charts, including bar charts, pie charts, line charts, and scatter plots.  While Raphael.js itself doesn't provide built-in charting functions, its ability to create and manipulate vector graphics makes it a good foundation for building custom charting components.  You'll typically need to handle data processing, scaling, and visual representation yourself.\n\nFor example, to create a bar chart, you'd:\n\n1. **Process Data:** Extract relevant data from your dataset.\n2. **Calculate Dimensions:** Determine the dimensions of each bar based on the data and available space on the canvas.\n3. **Create Rectangles:** Use `paper.rect()` to create rectangles representing the bars, positioning them according to the calculated dimensions.\n4. **Style the Chart:** Apply colors, labels, axes, and other visual elements using `attr()`.\n\n\nThe complexity will increase with the type of chart you are implementing.   Consider using a dedicated charting library (built on top of or alongside Raphael.js) for more advanced charting needs and features such as tooltips and legends that handle complexities such as responsive design and data interaction efficiently.\n\n\n\n### Creating Interactive Diagrams\n\nRaphael.js enables the creation of interactive diagrams, allowing users to interact with elements.  This often involves combining shape creation with event handling.  For example, you could create a flowchart where clicking on a shape triggers an action or opens a detail view, or a network diagram where hovering over nodes highlights connections.\n\n\n```javascript\nvar paper = Raphael(\"canvas\", 500, 300);\nvar rect = paper.rect(50, 50, 100, 50);\nrect.attr({fill: \"lightblue\"});\n\nrect.on(\"click\", function() {\n    //Action to be performed on click\n    alert(\"Rectangle clicked!\");\n});\n\n//Example of highlighting on mouseover\nrect.on(\"mouseover\", function() {\n  this.attr({ stroke: \"red\", \"stroke-width\": 3 });\n});\n\nrect.on(\"mouseout\", function() {\n  this.attr({ stroke: \"black\", \"stroke-width\": 1 });\n});\n\n```\n\nMore complex interactive diagrams would involve carefully managing state and updating the visual elements based on user interactions.\n\n\n### Creating Animations\n\nRaphael.js's `animate()` method is powerful for creating smooth animations.  You can animate various attributes, including position, size, color, opacity, and even path data.  This allows you to create visually appealing effects such as transitions, transformations, and dynamic updates.\n\n```javascript\nvar circle = paper.circle(100, 100, 30);\ncircle.attr({fill: \"blue\"});\n\n//Animate the circle's radius and color over 2 seconds\ncircle.animate({r: 50, fill: \"red\"}, 2000, \"bounce\"); // \"bounce\" is an easing function\n\n//Animate the circle's position\nsetTimeout(function(){\n    circle.animate({cx: 250, cy: 100}, 1000);\n},2000);\n```\n\nCombining animations with event handling enables creating dynamic and responsive visuals, enhancing the user experience. Remember to consider performance when implementing many animations simultaneously.  More complex animations might require a more advanced animation library in conjunction with Raphael.js.\n\n\n## Reference\n\nThis section provides a concise overview of the key components of the Raphael.js API.  For the most complete and up-to-date information, always refer to the official Raphael.js documentation.  The API may change slightly between versions.\n\n### API Reference\n\nThe core of the Raphael.js API revolves around the `Raphael` object, which is created when you initialize the library.  This object provides methods for creating shapes, manipulating attributes, and handling events.  The structure is generally as follows:\n\n1. **Paper Object Creation:**  `var paper = Raphael(\"containerID\", width, height);`  This creates a drawing surface within the HTML element with the specified ID.\n\n2. **Shape Creation:** The `paper` object provides methods for creating various shapes (e.g., `paper.circle()`, `paper.rect()`, `paper.path()`, `paper.ellipse()`, `paper.text()`, `paper.image()`).  These methods return a Raphael element object.\n\n3. **Element Manipulation:**  Raphael elements have methods for manipulating attributes (`attr()`), applying transformations (`translate()`, `scale()`, `rotate()`, `transform()`), and attaching event handlers (`on()`).\n\n4. **Animation:** The `animate()` method allows for smooth changes to element attributes over time.\n\n5. **Sets:**  `paper.set()` creates a collection of elements, enabling batch operations.\n\n\n### Global Functions\n\nRaphael.js doesn't have many globally accessible functions besides the main `Raphael` function itself used for initialization.  Most functionality is accessed through the `paper` object and element methods.\n\n\n### Element Methods\n\nRaphael elements (returned by shape creation methods) have a rich set of methods for manipulation:\n\n* **`attr(attrName, attrValue)` or `attr({attrName: attrValue, ...})`:** Gets or sets element attributes.\n\n* **`animate(params, duration, easing, callback)`:** Animates element attributes.\n\n* **`on(eventName, handler)`:** Attaches an event handler to the element.\n\n* **`translate(dx, dy)`:** Moves the element horizontally and vertically.\n\n* **`scale(sx, sy, [cx, cy])`:** Scales the element along the x and y axes.\n\n* **`rotate(angle, [cx, cy])`:** Rotates the element.\n\n* **`transform(transformString)`:** Applies a transformation string.\n\n* **`getBBox()`:** Returns the bounding box of the element.\n\n* **`toFront()`:** Brings the element to the front of the z-order.\n\n* **`toBack()`:** Sends the element to the back of the z-order.\n\n* **`remove()`:** Removes the element from the canvas.\n\n* **`hide()`:** Hides the element.\n\n* **`show()`:** Shows the element.\n\n\nThis is not an exhaustive list.  Consult the official Raphael.js documentation for a complete API reference, including details on parameters, return values, and supported attributes for each method.  Remember that specific methods and attributes might have changed slightly across versions.\n\n","srcMarkdownNoYaml":"\n## Introduction to Raphael.js\n\n### What is Raphael.js?\n\nRaphael.js is a small JavaScript library that allows you to create vector graphics on the fly in any browser that supports SVG, VML, or Canvas.  It provides a simple and consistent interface for creating and manipulating various vector shapes, including paths, ellipses, rectangles, text, and images.  This simplifies the process of adding interactive and dynamic vector graphics to your web applications without the complexities of directly working with SVG or other vector formats.  Raphael.js handles the browser-specific rendering details, allowing you to focus on the design and functionality of your graphics.\n\n\n### Setting up Raphael.js\n\nRaphael.js can be included in your project in a few ways:\n\n* **Download:** Download the minified `raphael.min.js` file from the official Raphael.js website and place it in your project's JavaScript directory.\n* **CDN:** Include the library via a CDN such as jsDelivr:  `<script src=\"https://cdn.jsdelivr.net/npm/raphael@2.3.0/raphael.min.js\"></script>`.  Remember to replace `2.3.0` with the desired version number if needed.  Check the official website for the latest version.\n* **NPM/Yarn:** If you are using a package manager like npm or Yarn, you can install Raphael.js using the command `npm install raphael` or `yarn add raphael`.  Then, import it into your project as needed (the specific import syntax depends on your module bundler).\n\n\nOnce included,  you can use the `Raphael` object in your JavaScript code.\n\n\n### Browser Compatibility\n\nRaphael.js aims for broad browser compatibility. While it primarily leverages SVG for rendering, it falls back to VML for older Internet Explorer versions and Canvas as a last resort.  However, for optimal performance and feature support, using modern browsers with SVG support is recommended.  Consult the official Raphael.js documentation or release notes for the most up-to-date browser compatibility information.\n\n\n### Basic Example\n\nThis example creates a simple red circle with a radius of 50 pixels at position (50,50) on the page:\n\n```javascript\n// Create a canvas that's 300 pixels wide by 200 pixels tall\nvar paper = Raphael(\"canvas\", 300, 200); // Replace \"canvas\" with your canvas element ID\n\n// Create a circle shape\nvar circle = paper.circle(50, 50, 50);\n\n// Set the circle's fill color to red\ncircle.attr({fill: \"red\"});\n```\n\nRemember to include the Raphael.js library and create a `<div>` element with the ID \"canvas\" in your HTML file:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<title>Raphael.js Example</title>\n</head>\n<body>\n<div id=\"canvas\"></div>\n<script src=\"raphael.min.js\"></script>  <!-- Or CDN link -->\n<script>\n  // JavaScript code from the example above goes here\n</script>\n</body>\n</html>\n```  This will display a red circle on your page.  This basic example provides a starting point for exploring the numerous functionalities offered by Raphael.js.\n\n\n## Creating Shapes\n\n### Creating Circles\n\nRaphael.js provides the `circle()` method to create circles.  It takes three arguments: the x-coordinate of the center, the y-coordinate of the center, and the radius.  The returned object is a Raphael element representing the circle, which can be further manipulated using attribute methods.\n\n```javascript\n// Create a paper object (replace \"canvas\" with your canvas element ID)\nvar paper = Raphael(\"canvas\", 500, 300);\n\n// Create a circle with center at (50, 50) and radius 25\nvar myCircle = paper.circle(50, 50, 25);\n\n// Set attributes (optional):\nmyCircle.attr({\n  fill: \"blue\",       // Fill color\n  stroke: \"red\",     // Stroke color\n  \"stroke-width\": 3   // Stroke width\n});\n```\n\n\n### Creating Rectangles\n\nThe `rect()` method creates rectangles. It takes four arguments: the x-coordinate of the top-left corner, the y-coordinate of the top-left corner, the width, and the height.\n\n```javascript\n// Create a rectangle with top-left corner at (150, 50), width 100, height 50\nvar myRect = paper.rect(150, 50, 100, 50);\nmyRect.attr({\n  fill: \"green\",\n  stroke: \"black\",\n  \"stroke-width\": 2\n});\n```\n\n### Creating Ellipses\n\nEllipses are created using the `ellipse()` method. It requires four arguments: the x-coordinate of the center, the y-coordinate of the center, the radius on the x-axis, and the radius on the y-axis.\n\n```javascript\n// Create an ellipse with center at (300, 50), x-radius 50, y-radius 25\nvar myEllipse = paper.ellipse(300, 50, 50, 25);\nmyEllipse.attr({\n  fill: \"yellow\",\n  stroke: \"purple\",\n  \"stroke-width\": 1\n});\n```\n\n\n### Creating Paths\n\nPaths offer the most flexibility for creating complex shapes.  The `path()` method accepts a string describing the path using SVG path syntax.  This syntax uses commands like `M` (moveto), `L` (lineto), `C` (curveto), `Z` (closepath), etc.\n\n```javascript\n// Create a star shape using path commands\nvar myPath = paper.path(\"M100,150 L120,100 L180,100 L200,150 L160,190 L120,190 Z\");\nmyPath.attr({fill: \"orange\"});\n```\n\n\n### Creating Images\n\nRaphael.js allows you to add images to the canvas using the `image()` method.  It requires five arguments: the URL of the image, the x-coordinate, the y-coordinate, the width, and the height.\n\n```javascript\n// Add an image (replace with your image URL)\nvar myImage = paper.image(\"myimage.jpg\", 200, 150, 50, 50);\n```\n\n\n### Creating Text\n\nThe `text()` method creates text elements.  It accepts three arguments: the x-coordinate, the y-coordinate, and the text string.\n\n```javascript\n// Add text at (100, 250)\nvar myText = paper.text(100, 250, \"Hello, Raphael!\");\nmyText.attr({\n  \"font-size\": 20,\n  \"font-family\": \"Arial\",\n  \"fill\": \"black\"\n});\n```\n\nRemember that in all these examples, you need to have a `Raphael` paper object created first, typically by using `Raphael(containerID, width, height)`, where `containerID` is the ID of a `<div>` or other suitable HTML element.  The width and height values specify the dimensions of the drawing canvas.\n\n\n## Manipulating Shapes\n\n### Translation\n\nTranslation moves a shape along the x and y axes.  Raphael.js uses the `translate()` method for this.  It takes two arguments: the horizontal displacement (dx) and the vertical displacement (dy).\n\n```javascript\nvar paper = Raphael(\"canvas\", 500, 300);\nvar rect = paper.rect(50, 50, 100, 50);\n\n// Translate the rectangle 50 pixels to the right and 20 pixels down\nrect.translate(50, 20);\n```\n\n### Scaling\n\nScaling changes the size of a shape. The `scale()` method takes two arguments: the horizontal scaling factor (sx) and the vertical scaling factor (sy).  A value of 1 means no scaling, values greater than 1 enlarge the shape, and values less than 1 reduce its size.  An optional third argument specifies the x and y coordinates of the scaling center (defaults to the shape's center).\n\n```javascript\nvar circle = paper.circle(150, 150, 30);\n// Scale the circle to twice its size, centered at its current center.\ncircle.scale(2, 2);\n\n// Scale the circle to half its size, with the scaling origin at 200,150.\ncircle.scale(0.5, 0.5, 200,150);\n```\n\n### Rotation\n\nRotation turns a shape around a given point. The `rotate()` method takes one argument: the angle of rotation in degrees (clockwise). An optional second and third argument specify the x and y coordinates of the rotation center (defaults to the shape's center).\n\n\n```javascript\nvar ellipse = paper.ellipse(300, 150, 40, 20);\n// Rotate the ellipse 45 degrees counter-clockwise around its center\nellipse.rotate(45);\n\n//Rotate the ellipse 30 degrees clockwise around the point (350, 180)\nellipse.rotate(-30, 350, 180);\n```\n\n\n### Transformations\n\nRaphael.js also provides a `transform()` method that allows combining multiple transformations (translate, scale, rotate) using a single string.  The string uses a space-separated list of transformations in the form `[command][x][y][z]`, where the command is `t` for translate, `s` for scale, `r` for rotate, and `m` for matrix transformation.\n\n```javascript\nvar path = paper.path(\"M10,10 L100,100\");\n\n// Apply multiple transformations: translate, then rotate\npath.transform(\"t10,20r30\");\n\n//Applying matrix transform.  Note that matrix transformation requires 6 arguments.\npath.transform(\"m1,0,0,1,10,10\"); //This translates the path 10 pixels to the right and 10 pixels down.\n```\n\n\n### Attributes\n\nAttributes control various aspects of a shape's appearance, such as fill color, stroke color, stroke width, opacity, etc.  These are set using the `attr()` method.  You can set multiple attributes at once using an object as an argument.\n\n```javascript\nvar square = paper.rect(10, 10, 40, 40);\n\n//Set attributes\nsquare.attr({\n    \"fill\": \"#f00\", //red fill\n    \"stroke\": \"#000\", //black stroke\n    \"stroke-width\": 5,\n    \"opacity\": 0.5\n});\n\n//Get a specific attribute\nlet fillColor = square.attr(\"fill\"); //Gets the fill color\nconsole.log(fillColor);\n\n\n```\n\n### Animation\n\nRaphael.js provides powerful animation capabilities using the `animate()` method. This method allows you to smoothly change a shape's attributes over time. It takes two arguments: an object containing the target attribute values and the animation duration in milliseconds.  An optional third argument specifies an easing function (e.g., '>', '<', '<>', 'backIn', etc.).\n\n```javascript\nvar circle = paper.circle(100, 100, 20);\n\n// Animate the circle to a new position and size over 1000 milliseconds\ncircle.animate({cx: 200, cy: 200, r: 40}, 1000, \">\");\n\n\n// Example with a callback function:\ncircle.animate({cx: 100, cy: 100, r: 20}, 1000, function(){\n    console.log(\"Animation complete!\");\n});\n```\n\nRemember to consult the Raphael.js documentation for a complete list of attributes and easing functions available.  The `animate` function allows chaining animations but subsequent animations overwrite previous animations. To queue animations, use the `animateWith` function instead.\n\n\n## Working with Paths\n\n### Path String Syntax\n\nPaths in Raphael.js are defined using a string following the SVG path syntax. This string consists of a series of commands and their corresponding coordinates.  Each command is a single letter, followed by numerical parameters separated by commas.\n\nHere are some common commands:\n\n* **`M x y` (Moveto):** Moves the \"pen\" to the specified coordinates (x, y) without drawing.  This typically starts a new subpath.\n* **`L x y` (Lineto):** Draws a straight line from the current point to the specified coordinates (x, y).\n* **`H x` (Horizontal lineto):** Draws a horizontal line to the specified x-coordinate.\n* **`V y` (Vertical lineto):** Draws a vertical line to the specified y-coordinate.\n* **`C x1 y1 x2 y2 x y` (Curveto):** Draws a Bézier curve with control points (x1, y1) and (x2, y2), and ending at (x, y).\n* **`S x2 y2 x y` (Smooth curveto):** Draws a Bézier curve similar to `C`, but the first control point is automatically reflected from the previous curve's control point.\n* **`Q x1 y1 x y` (Quadratic Bézier curveto):** Draws a quadratic Bézier curve with a single control point (x1, y1) and ending at (x, y).\n* **`T x y` (Smooth quadratic Bézier curveto):** Similar to `Q`, but the control point is reflected from the previous curve's control point.\n* **`A rx ry x-axis-rotation large-arc-flag sweep-flag x y` (Elliptical arc):** Draws an elliptical arc. This command has many parameters, consult SVG documentation for details.\n* **`Z` (Closepath):** Closes the current subpath by drawing a straight line back to the starting point of the subpath.\n\nCommands are case-insensitive, but it's best practice to use uppercase for consistency.  Multiple commands can be chained together in a single string. For example:  `\"M10 10 L 100 100 L 100 200 Z\"` creates a closed right-angled triangle.\n\n\n### Path Manipulation\n\nOnce a path is created using `paper.path(pathString)`, you can manipulate it in several ways:\n\n* **`path.attr({path: newPathString})`:**  This is the most common method to modify the path's shape.  You provide a new path string to redefine the path entirely.\n\n* **`path.getSubpath(from, to)`:** This extracts a portion of the path as a new path string.  `from` and `to` specify the start and end indices of the segment to be extracted.\n\n\n* **`path.getTotalLength()`:** Returns the total length of the path. Useful for creating animations along the path.\n\n* **`path.getPointAtLength(length)`:** Returns an object `{x, y, alpha}` representing the point at the specified length along the path.  This is essential for animations or finding coordinates along the path.\n\n\n### Creating Complex Shapes with Paths\n\nPaths are essential for creating complex shapes that cannot be easily represented with simple primitives like rectangles or circles.  By combining various commands, you can generate intricate designs.\n\n```javascript\nvar paper = Raphael(\"canvas\", 500, 300);\n\n// Example: Creating a star shape\nvar star = paper.path(\"M150,100 L180,160 L240,160 L180,220 L210,280 L150,230 L90,280 L120,220 L60,160 L120,160 Z\");\nstar.attr({fill: \"gold\"});\n\n\n//Example: Creating a curved shape\nvar curvedShape = paper.path(\"M 50,50 C 50,150 200,150 200,50 L 200,100 C 200, 200, 100,200, 100,100 L100,50 Z\");\ncurvedShape.attr({fill: \"lightblue\", stroke: \"darkblue\"});\n\n\n```\n\nRemember that complex paths can become difficult to manage manually. Consider using tools or libraries that help you generate SVG path strings for more intricate shapes if needed.  The examples above illustrate the power and flexibility of paths in constructing diverse and elaborate vector graphics.\n\n\n## Color and Styles\n\n### Fill and Stroke\n\nIn Raphael.js, the `fill` attribute determines the color or pattern used to fill a shape's interior, while the `stroke` attribute sets the color and style of the shape's outline (border).  Both are specified using the `attr()` method.  If `fill` is omitted, the shape is not filled; if `stroke` is omitted, it has no outline.\n\n```javascript\nvar paper = Raphael(\"canvas\", 300, 200);\nvar rect = paper.rect(10, 10, 100, 50);\n\nrect.attr({\n  fill: \"blue\", //Solid blue fill\n  stroke: \"red\",  //red stroke\n  \"stroke-width\": 5 //Stroke width of 5 pixels\n});\n\nvar circle = paper.circle(150, 100, 40);\ncircle.attr({stroke: \"green\"}); //Only a green stroke, no fill\n\n```\n\n### Color Definitions\n\nColors can be specified in several ways:\n\n* **Named colors:**  Use standard HTML color names (e.g., \"red\", \"green\", \"blue\", \"yellow\", etc.).\n* **Hexadecimal notation:** Use hex codes (e.g., \"#FF0000\" for red, \"#00FF00\" for green, \"#0000FF\" for blue).\n* **RGB notation:** Use RGB values (e.g., \"rgb(255, 0, 0)\" for red).\n* **RGBA notation:** Use RGBA values, including alpha (opacity) channel (e.g., \"rgba(255, 0, 0, 0.5)\" for semi-transparent red).\n\n\n### Gradient Fills\n\nRaphael.js supports linear and radial gradients for fills.  These are defined using the `attr()` method with a specific format for the `fill` attribute.\n\n**Linear Gradient:**\n\n```javascript\nvar rect = paper.rect(10, 150, 100, 50);\nrect.attr({\n  fill: \"90-#000-#fff\" // Linear gradient from black to white, angle 90 degrees\n});\n\n\n//More detailed linear gradient.  Note that gradient stops can be specified with an offset.\nvar rect2 = paper.rect(120, 150, 100, 50);\nrect2.attr({fill: \"l(0,0)0:#ff0000:10#00ff00:20#0000ff\"}); // linear gradient with specified stops\n```\n\n**Radial Gradient:**\n\n```javascript\nvar circle = paper.circle(200, 100, 40);\ncircle.attr({\n    fill: \"r(0.5,0.5,0.3)#f00-#00f\" // radial gradient from red to blue\n});\n```\n\nThe syntax for gradients might vary slightly depending on the Raphael.js version. Check the official documentation for your version.\n\n\n### Stroke Styles\n\nBesides `stroke` color, you can control the stroke style with these attributes:\n\n* **`\"stroke-width\"`:** Specifies the width of the stroke in pixels.\n* **`\"stroke-linecap\"`:** Defines the shape of the stroke ends (\"butt\", \"round\", \"square\").\n* **`\"stroke-linejoin\"`:** Specifies the shape at the corner where two lines meet (\"miter\", \"round\", \"bevel\").\n* **`\"stroke-dasharray\"`:** Creates dashed or dotted lines.  The value is a comma-separated list of dash and gap lengths (e.g., \"5,5\" for a 5-pixel dash followed by a 5-pixel gap).\n\n\n```javascript\nvar path = paper.path(\"M10,10 L100,10 L100,100 L10,100 Z\");\npath.attr({\n  \"stroke-width\": 10,\n  \"stroke-linecap\": \"round\",\n  \"stroke-linejoin\": \"round\",\n  \"stroke-dasharray\": \"10,5\"\n});\n```\n\n### Opacity\n\nOpacity controls the transparency of both fill and stroke.  It's set using the `\"opacity\"` attribute, with a value between 0 (fully transparent) and 1 (fully opaque).\n\n```javascript\nvar ellipse = paper.ellipse(150, 175, 30, 20);\nellipse.attr({\n  fill: \"rgba(0,0,255,0.5)\", //Blue with 50% opacity\n  \"opacity\": 0.7 //Overall opacity affecting both stroke and fill\n});\n```\n\nNote that the opacity applied directly to the fill attribute via RGBA and the overall opacity applied via the `opacity` attribute will interact.  The resulting opacity will be the product of the two.\n\n\n## Text and Typography\n\n### Text Attributes\n\nRaphael.js provides several attributes to control the appearance of text elements. These attributes are set using the `attr()` method, similar to other shape attributes. Key attributes include:\n\n* **`text`:** The actual text string displayed.\n* **`font`:** A shorthand for setting font family, size, style (e.g., \"12px Arial\", \"bold 16px Times New Roman\").\n* **`font-family`:** Specifies the font family (e.g., \"Arial\", \"Times New Roman\", \"Helvetica\").\n* **`font-size`:** Sets the font size in pixels (e.g., \"12px\", \"16px\").\n* **`font-weight`:** Sets the font weight (e.g., \"normal\", \"bold\", \"bolder\").\n* **`font-style`:** Sets the font style (e.g., \"normal\", \"italic\", \"oblique\").\n* **`fill`:** Sets the text color (same as shape fill).\n* **`x` and `y`:**  Coordinates of the text anchor point.  Note this is different from the bounding box.\n* **`text-anchor`:**  Controls text alignment within the bounding box (\"start\", \"middle\", \"end\").\n\n\n```javascript\nvar paper = Raphael(\"canvas\", 300, 200);\nvar text = paper.text(100, 50, \"Sample Text\");\ntext.attr({\n  \"font-family\": \"Times New Roman\",\n  \"font-size\": 20,\n  \"font-weight\": \"bold\",\n  \"fill\": \"blue\",\n  \"text-anchor\": \"middle\"\n});\n```\n\n\n### Font Families\n\nRaphael.js uses browser-available fonts.  If a specified font is not available, the browser will substitute a default font.  To ensure consistent rendering across different systems, it's a good practice to provide fallback fonts. You can list multiple font families separated by commas in the `font-family` attribute (e.g., `\"font-family\": \"Arial, Helvetica, sans-serif\"`).\n\n\n### Font Sizes\n\nFont size is specified in pixels using the `font-size` attribute.  The value should be a numerical value followed by \"px\".  Larger values result in larger text.\n\n\n### Text Alignment\n\nText alignment is controlled using the `text-anchor` attribute.  The three possible values are:\n\n* **`\"start\"`:** Aligns the text to the left.\n* **`\"middle\"`:** Centers the text horizontally.\n* **`\"end\"`:** Aligns the text to the right.\n\nThe anchor point (defined by `x` and `y`) is relative to the alignment.  For example, with `\"text-anchor\": \"middle\"`, the `x` coordinate positions the center of the text.\n\n\n### Text Wrapping\n\nRaphael.js itself doesn't directly support text wrapping.  To achieve text wrapping, you will typically need to use a combination of techniques:\n\n1. **Measure Text Width:**  Use `text.getBBox().width` to get the width of the rendered text. This requires the text element to be already rendered on the page.\n\n2. **Split the Text:** Divide the text into multiple lines using JavaScript based on your desired line width.\n\n3. **Create Multiple Text Elements:** Create multiple `paper.text()` elements, placing each line at the appropriate vertical position, and setting the `x` and `y` coordinates accordingly.\n\nThis approach allows you to manually break the text into lines, offering full control over the text layout, but involves more manual coding.  Consider external libraries if more sophisticated text wrapping is required.\n\n\n\n\n## Event Handling\n\n### Attaching Event Handlers\n\nRaphael.js allows you to attach event handlers to shapes using the standard DOM event model.  The most common way is to use the `on()` method.  This method takes two arguments: the event type (e.g., \"click\", \"mouseover\", \"mouseout\", \"mousedown\", \"mouseup\", \"mousemove\", \"dblclick\", \"touchstart\", \"touchmove\", \"touchend\") and a callback function.\n\n\n```javascript\nvar paper = Raphael(\"canvas\", 300, 200);\nvar rect = paper.rect(50, 50, 100, 50);\n\nrect.on(\"click\", function() {\n  console.log(\"Rectangle clicked!\");\n  this.attr({ fill: \"red\" }); //Change the fill on click\n});\n\nrect.on(\"mouseover\", function() {\n  this.attr({ fill: \"yellow\" }); //Change fill on mouseover\n});\n\nrect.on(\"mouseout\", function(){\n    this.attr({fill: \"blue\"}); //Change fill back to blue when mouse leaves\n});\n\n```\n\nThe callback function receives an event object as an argument, providing information about the event.  The `this` keyword inside the callback function refers to the Raphael element (the shape) that triggered the event.\n\n\n### Event Types\n\nRaphael.js supports a wide range of standard DOM events. Some of the most commonly used events include:\n\n* **`click`:** Triggered when the user clicks on the shape.\n* **`dblclick`:** Triggered when the user double-clicks on the shape.\n* **`mousedown`:** Triggered when the user presses a mouse button while the pointer is over the shape.\n* **`mouseup`:** Triggered when the user releases a mouse button while the pointer is over the shape.\n* **`mouseover`:** Triggered when the mouse pointer enters the area of the shape.\n* **`mouseout`:** Triggered when the mouse pointer leaves the area of the shape.\n* **`mousemove`:** Triggered repeatedly as the mouse pointer moves over the shape.\n* **`touchstart`, `touchmove`, `touchend`:** Touch events for mobile devices.\n\n\n\n### Event Propagation\n\nEvent propagation refers to the order in which events are handled when nested elements are involved.  In Raphael.js, event propagation follows the standard DOM event model:\n\n* **Capturing Phase:** The event travels down the DOM tree from the window to the target element.  Event listeners attached in the capturing phase are triggered first.  Raphael doesn't directly expose capturing phase event listeners.\n\n* **Target Phase:**  The event reaches the target element (the shape that triggered the event).  Event listeners attached directly to the target element are triggered.\n\n* **Bubbling Phase:** The event travels back up the DOM tree from the target element to the window.  Event listeners attached to ancestor elements are triggered.\n\nBy default, Raphael events bubble up the DOM tree.  You can prevent event bubbling using the `event.stopPropagation()` method within your event handler.\n\n```javascript\nvar paper = Raphael(\"canvas\", 300, 200);\nvar rect1 = paper.rect(50, 50, 100, 50);\nvar rect2 = paper.rect(70, 70, 50, 50); //Nested rect inside rect1\n\n\nrect1.on(\"click\", function(event){\n    console.log(\"rect1 clicked!\");\n});\n\nrect2.on(\"click\", function(event){\n    console.log(\"rect2 clicked!\");\n    event.stopPropagation(); //Prevents event from bubbling to rect1\n});\n```\n\nIn this example, clicking on `rect2` will only log \"rect2 clicked!\", because `event.stopPropagation()` prevents the event from bubbling up to `rect1`.  Clicking on the area of `rect1` that is *not* covered by `rect2` will log both \"rect1 clicked!\" and \"rect2 clicked!\".\n\n\n## Advanced Techniques\n\n### Creating Custom Shapes\n\nWhile Raphael.js provides basic shapes, you can create custom shapes using paths or by combining multiple shapes into more complex structures. For truly custom shapes, consider creating your own shape-drawing functions that generate path strings based on parameters you define.  This allows you to reuse your custom shape creation logic throughout your application.\n\n\n```javascript\n// Example: Function to create a rounded rectangle\nfunction createRoundedRect(x, y, width, height, cornerRadius) {\n  var pathStr = \"M\" + x + \",\" + (y + cornerRadius) + \n               \" L\" + (x + width - cornerRadius) + \",\" + y +\n               \" Q\" + (x + width) + \",\" + y + \" \" + (x + width) + \",\" + (y + cornerRadius) +\n               \" L\" + (x + width) + \",\" + (y + height - cornerRadius) +\n               \" Q\" + (x + width) + \",\" + (y + height) + \" \" + (x + width - cornerRadius) + \",\" + (y + height) +\n               \" L\" + (x + cornerRadius) + \",\" + (y + height) +\n               \" Q\" + x + \",\" + (y + height) + \" \" + x + \",\" + (y + height - cornerRadius) +\n               \" L\" + x + \",\" + (y + cornerRadius) + \" Z\";\n  return paper.path(pathStr);\n}\n\nvar paper = Raphael(\"canvas\", 300, 200);\nvar myRoundedRect = createRoundedRect(50, 50, 100, 50, 10); //Creates a rounded rectangle with 10px corner radius\nmyRoundedRect.attr({fill: \"lightgreen\"});\n```\n\n\n\n### Working with Groups\n\nRaphael.js allows grouping shapes together using the `paper.set()` method.  Grouping is useful for applying transformations or events to multiple shapes simultaneously.\n\n```javascript\nvar paper = Raphael(\"canvas\", 300, 200);\nvar circle = paper.circle(50, 50, 20);\nvar rect = paper.rect(70, 70, 40, 40);\n\nvar group = paper.set(circle, rect); // Group the circle and rectangle\n\n//Apply transformation to the entire group\ngroup.translate(100, 0);\n\n// Apply an event handler to the group\ngroup.on(\"click\", function(){\n    this.attr({fill: \"orange\"});\n});\n```\n\nRemember that events on a group will bubble up to the individual elements. If you need finer-grained control over event handling on the group's elements consider using event delegation.\n\n\n\n### Using Raphael with Other Libraries\n\nRaphael.js can be integrated with other JavaScript libraries. Common use cases involve using it alongside animation libraries (like GreenSock/GSAP) for more sophisticated animations, or with UI frameworks for creating interactive components.\n\n\n### Performance Optimization\n\nFor complex graphics, performance optimization is crucial.  Consider these strategies:\n\n* **Minimize DOM manipulations:**  Batch attribute changes using `attr()` instead of changing attributes individually in multiple calls.\n* **Use caching:**  Pre-calculate values or create reusable elements to avoid repeated calculations.\n* **Reduce the number of elements:**  Combine elements where possible to reduce the number of elements the browser has to render.\n* **Optimize path complexity:** Use simpler path definitions whenever feasible.  Overly complex paths can impact performance.\n* **Use transformations effectively:** Transformations are generally more performant than repeatedly changing individual element coordinates.\n* **Consider using a canvas fallback:** If performance is critical, consider utilizing Canvas for specific parts of your drawing if your target browser supports it.\n\n\n### Debugging\n\nDebugging Raphael.js applications often involves standard JavaScript debugging techniques.  Use your browser's developer tools (console, debugger) to inspect variables, set breakpoints, and step through your code.  Pay close attention to error messages in the console, as they often provide valuable clues to identify issues.  Remember to check the Raphael.js documentation and community forums for troubleshooting assistance, as many common problems and their solutions are already documented.\n\n\n## Common Use Cases\n\n### Creating Charts\n\nRaphael.js is well-suited for creating various types of charts, including bar charts, pie charts, line charts, and scatter plots.  While Raphael.js itself doesn't provide built-in charting functions, its ability to create and manipulate vector graphics makes it a good foundation for building custom charting components.  You'll typically need to handle data processing, scaling, and visual representation yourself.\n\nFor example, to create a bar chart, you'd:\n\n1. **Process Data:** Extract relevant data from your dataset.\n2. **Calculate Dimensions:** Determine the dimensions of each bar based on the data and available space on the canvas.\n3. **Create Rectangles:** Use `paper.rect()` to create rectangles representing the bars, positioning them according to the calculated dimensions.\n4. **Style the Chart:** Apply colors, labels, axes, and other visual elements using `attr()`.\n\n\nThe complexity will increase with the type of chart you are implementing.   Consider using a dedicated charting library (built on top of or alongside Raphael.js) for more advanced charting needs and features such as tooltips and legends that handle complexities such as responsive design and data interaction efficiently.\n\n\n\n### Creating Interactive Diagrams\n\nRaphael.js enables the creation of interactive diagrams, allowing users to interact with elements.  This often involves combining shape creation with event handling.  For example, you could create a flowchart where clicking on a shape triggers an action or opens a detail view, or a network diagram where hovering over nodes highlights connections.\n\n\n```javascript\nvar paper = Raphael(\"canvas\", 500, 300);\nvar rect = paper.rect(50, 50, 100, 50);\nrect.attr({fill: \"lightblue\"});\n\nrect.on(\"click\", function() {\n    //Action to be performed on click\n    alert(\"Rectangle clicked!\");\n});\n\n//Example of highlighting on mouseover\nrect.on(\"mouseover\", function() {\n  this.attr({ stroke: \"red\", \"stroke-width\": 3 });\n});\n\nrect.on(\"mouseout\", function() {\n  this.attr({ stroke: \"black\", \"stroke-width\": 1 });\n});\n\n```\n\nMore complex interactive diagrams would involve carefully managing state and updating the visual elements based on user interactions.\n\n\n### Creating Animations\n\nRaphael.js's `animate()` method is powerful for creating smooth animations.  You can animate various attributes, including position, size, color, opacity, and even path data.  This allows you to create visually appealing effects such as transitions, transformations, and dynamic updates.\n\n```javascript\nvar circle = paper.circle(100, 100, 30);\ncircle.attr({fill: \"blue\"});\n\n//Animate the circle's radius and color over 2 seconds\ncircle.animate({r: 50, fill: \"red\"}, 2000, \"bounce\"); // \"bounce\" is an easing function\n\n//Animate the circle's position\nsetTimeout(function(){\n    circle.animate({cx: 250, cy: 100}, 1000);\n},2000);\n```\n\nCombining animations with event handling enables creating dynamic and responsive visuals, enhancing the user experience. Remember to consider performance when implementing many animations simultaneously.  More complex animations might require a more advanced animation library in conjunction with Raphael.js.\n\n\n## Reference\n\nThis section provides a concise overview of the key components of the Raphael.js API.  For the most complete and up-to-date information, always refer to the official Raphael.js documentation.  The API may change slightly between versions.\n\n### API Reference\n\nThe core of the Raphael.js API revolves around the `Raphael` object, which is created when you initialize the library.  This object provides methods for creating shapes, manipulating attributes, and handling events.  The structure is generally as follows:\n\n1. **Paper Object Creation:**  `var paper = Raphael(\"containerID\", width, height);`  This creates a drawing surface within the HTML element with the specified ID.\n\n2. **Shape Creation:** The `paper` object provides methods for creating various shapes (e.g., `paper.circle()`, `paper.rect()`, `paper.path()`, `paper.ellipse()`, `paper.text()`, `paper.image()`).  These methods return a Raphael element object.\n\n3. **Element Manipulation:**  Raphael elements have methods for manipulating attributes (`attr()`), applying transformations (`translate()`, `scale()`, `rotate()`, `transform()`), and attaching event handlers (`on()`).\n\n4. **Animation:** The `animate()` method allows for smooth changes to element attributes over time.\n\n5. **Sets:**  `paper.set()` creates a collection of elements, enabling batch operations.\n\n\n### Global Functions\n\nRaphael.js doesn't have many globally accessible functions besides the main `Raphael` function itself used for initialization.  Most functionality is accessed through the `paper` object and element methods.\n\n\n### Element Methods\n\nRaphael elements (returned by shape creation methods) have a rich set of methods for manipulation:\n\n* **`attr(attrName, attrValue)` or `attr({attrName: attrValue, ...})`:** Gets or sets element attributes.\n\n* **`animate(params, duration, easing, callback)`:** Animates element attributes.\n\n* **`on(eventName, handler)`:** Attaches an event handler to the element.\n\n* **`translate(dx, dy)`:** Moves the element horizontally and vertically.\n\n* **`scale(sx, sy, [cx, cy])`:** Scales the element along the x and y axes.\n\n* **`rotate(angle, [cx, cy])`:** Rotates the element.\n\n* **`transform(transformString)`:** Applies a transformation string.\n\n* **`getBBox()`:** Returns the bounding box of the element.\n\n* **`toFront()`:** Brings the element to the front of the z-order.\n\n* **`toBack()`:** Sends the element to the back of the z-order.\n\n* **`remove()`:** Removes the element from the canvas.\n\n* **`hide()`:** Hides the element.\n\n* **`show()`:** Shows the element.\n\n\nThis is not an exhaustive list.  Consult the official Raphael.js documentation for a complete API reference, including details on parameters, return values, and supported attributes for each method.  Remember that specific methods and attributes might have changed slightly across versions.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"}],"output-file":"raphael.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"title":"Raphael - A Developer's Handbook","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}