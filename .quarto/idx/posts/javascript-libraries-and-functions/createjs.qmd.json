{"title":"CreateJS - Documentation","markdown":{"yaml":{"title":"CreateJS - Documentation","categories":["JavaScript Libraries and Functions"]},"headingText":"What is CreateJS?","containsRefs":false,"markdown":"\n\n\n\nCreateJS is a suite of modular libraries and tools that simplify HTML5 canvas development.  It provides a consistent, easy-to-use API for working with shapes, text, images, video, and more, abstracting away many of the complexities of the underlying Canvas API.  The libraries are designed to be lightweight, performant, and cross-browser compatible, making them suitable for a wide range of projects, from simple animations to complex interactive applications.  CreateJS includes several key libraries: EaselJS (for display and animation), TweenJS (for animation), SoundJS (for audio playback), and PreloadJS (for asset loading).\n\n### Why Use CreateJS?\n\nCreateJS offers several compelling reasons for choosing it as your HTML5 canvas framework:\n\n* **Simplified API:**  CreateJS significantly simplifies the often-complex Canvas API, making it easier to learn and use, especially for developers with experience in other animation frameworks.\n* **Modular Design:** The modular structure allows you to include only the libraries you need, reducing the overall size of your project.  This makes CreateJS suitable for both small and large-scale projects.\n* **Cross-browser Compatibility:** CreateJS handles the cross-browser inconsistencies of the Canvas API, ensuring consistent performance across different browsers and devices.\n* **Performance:**  CreateJS is designed for optimal performance, making it suitable for creating demanding animations and interactive experiences.\n* **Ease of Use:** The intuitive API and well-documented examples make it easy to get started with CreateJS and build sophisticated applications quickly.\n* **Mature and Supported:** CreateJS is a mature library with a large and active community, ensuring ongoing support and development.\n\n\n### Setting up your Development Environment\n\nSetting up your development environment for CreateJS is straightforward. You primarily need:\n\n1. **A Text Editor or IDE:** Choose your preferred code editor (e.g., VS Code, Sublime Text, Atom) or an Integrated Development Environment (IDE) like WebStorm.\n\n2. **A Web Browser:**  Modern browsers (Chrome, Firefox, Safari, Edge) all support the HTML5 Canvas API and will work with CreateJS.\n\n3. **The CreateJS Libraries:** Download the CreateJS libraries from the official CreateJS website or use a CDN (Content Delivery Network) to include them in your project.  CDNs provide quick access and avoid the need for local downloads.  An example using a CDN is shown below:\n\n```html\n<script src=\"https://code.createjs.com/1.0.0/createjs.min.js\"></script>\n```\nRemember to replace `1.0.0` with the desired CreateJS version.\n\n\n4. **An HTML File:** Create an HTML file to structure your project. This file will include the CreateJS libraries and your JavaScript code.\n\n5. **A JavaScript File (Optional):** For larger projects, it's recommended to keep your CreateJS code in a separate JavaScript file for better organization and maintainability.\n\n\n### CreateJS Libraries and Modules\n\nCreateJS consists of several core libraries, each focusing on a specific aspect of canvas development:\n\n* **EaselJS:** This is the core library for managing the display list, creating and manipulating shapes, text, bitmaps, and containers.  It handles drawing, transformations, and event handling.\n\n* **TweenJS:** This library provides powerful and flexible tweening capabilities, allowing you to animate properties of EaselJS objects smoothly over time.  You can control timing, easing functions, and multiple chained tweens.\n\n* **SoundJS:**  This library simplifies audio playback and management.  It provides cross-browser compatibility and handles loading, playing, and controlling audio files.\n\n* **PreloadJS:** This library manages the loading of assets such as images, sounds, and other files, providing progress events and error handling to ensure smooth loading of your application's resources.\n\nEach library is self-contained and can be used independently, or in combination with the others to create complex and interactive applications.  Understanding the functionality of each library is crucial for effective CreateJS development.\n\n\n## EaselJS: Displaying Graphics\n\n### Stage, Shapes, and Containers\n\nEaselJS uses a `Stage` object as the root of the display list. The stage represents the canvas element where everything is drawn.  All display objects, including shapes, bitmaps, text, and containers, are added to the stage.  Containers are crucial for organizing and managing complex scenes; they act as invisible holders for other display objects, allowing you to group and manipulate them together.\n\nShapes are created using classes like `Shape`, `Circle`, `Rectangle`, and `Ellipse`. You define their properties (like color, fill, stroke) and add them to the stage or a container.  For complex shapes, you can use the `graphics` API to draw paths.\n\nExample of creating a simple circle and adding it to the stage:\n\n```javascript\nlet stage = new createjs.Stage(\"myCanvas\"); // \"myCanvas\" is the ID of your canvas element\nlet circle = new createjs.Shape();\ncircle.graphics.beginFill(\"red\").drawCircle(50, 50, 30);\nstage.addChild(circle);\nstage.update();\n```\n\n\n### Working with Bitmaps\n\nEaselJS allows you to easily display images using the `Bitmap` class. You create a `Bitmap` object by providing an image URL or an existing HTMLImageElement.  Once added to the stage, bitmaps can be scaled, rotated, and repositioned like other display objects.  For optimal performance, preload images using PreloadJS before adding them to the stage.\n\nExample of loading and displaying a bitmap:\n\n```javascript\nlet image = new Image();\nimage.onload = function() {\n  let bitmap = new createjs.Bitmap(image);\n  stage.addChild(bitmap);\n  stage.update();\n};\nimage.src = \"myImage.png\";\n```\n\n### Text and Typography\n\nEaselJS provides the `Text` class for rendering text on the canvas. You can control font size, family, color, and alignment.  You can also use rich text with HTML-like formatting, though this may affect rendering performance for large amounts of text.  For improved performance with multiple lines of text, consider using a `TextField` instead.\n\nExample of creating and adding text:\n\n```javascript\nlet text = new createjs.Text(\"Hello, world!\", \"20px Arial\", \"#000000\");\ntext.x = 100;\ntext.y = 100;\nstage.addChild(text);\nstage.update();\n```\n\n\n### Event Handling\n\nEaselJS makes event handling straightforward.  You can add event listeners to display objects to respond to mouse events (click, mouseover, mouseout, etc.) and stage events.  The `addEventListener` method is used to attach listeners.\n\nExample of adding a click event listener to a shape:\n\n```javascript\ncircle.addEventListener(\"click\", function(event) {\n  console.log(\"Circle clicked!\");\n});\n```\n\n\n### Animation Fundamentals\n\nAnimation in EaselJS is typically achieved by repeatedly updating the properties (position, rotation, scale) of display objects within a `tick` event handler.  The `Ticker` class provides a consistent update loop. You modify the object's properties in each tick, creating the illusion of movement.\n\nExample of basic animation using the Ticker:\n\n```javascript\ncreatejs.Ticker.addEventListener(\"tick\", handleTick);\nfunction handleTick(event) {\n  circle.x += 2; // Move the circle 2 pixels to the right each frame.\n  stage.update(event);\n}\n```\n\n### Tweens and Timers\n\nTweenJS offers a powerful and efficient way to create smooth animations. It handles transitions between property values over a specified duration, using various easing functions.  Timers provide a simple way to execute functions at specified intervals.\n\nExample of a simple tween:\n\n```javascript\ncreatejs.Tween.get(circle).to({x: 300, y: 200}, 1000, createjs.Ease.linear); // Move circle over 1 second.\n\n```\n\n### Display Lists and Optimization\n\nThe EaselJS display list is a hierarchical structure of display objects.  Efficient organization is crucial for performance, especially in complex scenes.  Minimize the number of objects on the stage, group related objects into containers, and use caching strategically to improve rendering speeds.  Avoid excessive use of rich text and unnecessary updates to improve performance further.  Understanding the display list structure and using optimization techniques is essential for creating high-performance applications.\n\n\n## TweenJS: Animation and Transitions\n\n### Basic Tweening\n\nTweenJS simplifies the creation of animations by providing methods to smoothly transition the properties of objects over time.  The core function is `createjs.Tween.get()`, which takes a target object and allows you to define the properties to animate, their target values, and the duration of the animation.\n\nA basic example of tweening an object's `x` and `y` properties:\n\n```javascript\nlet circle = new createjs.Shape();\n// ... (add circle to stage) ...\n\ncreatejs.Tween.get(circle)\n  .to({ x: 200, y: 100 }, 1000); // Move to (200, 100) over 1000 milliseconds (1 second)\n```\n\nThis code will smoothly animate the `circle`'s position from its current location to (200, 100) over one second.  You can specify multiple properties within the `to()` method.\n\n\n### Easing Functions\n\nEasing functions control the speed and timing of the animation.  TweenJS provides a range of built-in easing functions (e.g., `createjs.Ease.linear`, `createjs.Ease.quadIn`, `createjs.Ease.cubicOut`, etc.), each creating a different animation curve.  These control the rate of change of the animated property over time, affecting the perceived smoothness and character of the animation.\n\nExample using a different easing function:\n\n```javascript\ncreatejs.Tween.get(circle)\n  .to({ x: 200, y: 100 }, 1000, createjs.Ease.backOut); // Uses a bounce-back effect.\n```\n\n\n### Chaining Tweens\n\nTweens can be chained together to create complex animations with multiple stages.  Each `.to()` call adds a new tween segment to the animation sequence.  You can define different properties and durations for each segment.\n\nExample of chaining tweens:\n\n```javascript\ncreatejs.Tween.get(circle)\n  .to({ x: 200, y: 100 }, 1000, createjs.Ease.quadOut)\n  .to({ x: 400, y: 200, alpha: 0 }, 500, createjs.Ease.sineIn); // Fade out while moving\n```\n\nThis code moves the circle to (200, 100) using a quadratic easing, then to (400, 200) while fading it out using a sine easing.\n\n\n### Complex Animations\n\nTweenJS is capable of animating various properties beyond simple position.  You can animate alpha (opacity), scale, rotation, color, and even custom properties.  For more complex animations involving multiple objects or coordinated movements, you may need to use callbacks or event listeners to synchronize actions.  Consider structuring your code efficiently, perhaps by grouping animations using containers, for better organization.\n\nExample animating multiple properties:\n\n```javascript\ncreatejs.Tween.get(circle)\n  .to({ x: 200, y: 100, scaleX: 2, scaleY: 2, alpha: 0.5 }, 1000);\n```\n\n\n### TweenJS Events\n\nTweenJS provides events that allow you to execute functions at specific points in an animation's lifecycle (e.g., `change`, `complete`).  This allows for precise control and the triggering of other actions based on animation progress.  Event listeners are added using `addEventListener()`.\n\nExample of using a `complete` event:\n\n```javascript\ncreatejs.Tween.get(circle)\n  .to({ x: 200, y: 100 }, 1000)\n  .addEventListener(\"change\", function(event) {\n    console.log(\"Tween is changing\");\n  })\n  .addEventListener(\"complete\", function(event) {\n    console.log(\"Tween is complete\");\n    // Perform additional actions here\n  });\n```\nThe `change` event fires during the animation, and the `complete` event fires when the animation concludes.  Other useful events include `paused` and `resume`.\n\n\n## SoundJS: Audio Integration\n\n### Playing Sounds\n\nSoundJS simplifies the process of playing audio files in your CreateJS applications.  The core class is `createjs.Sound`.  Before playing sounds, you must register them using `createjs.Sound.registerSound()`, which takes a path to the sound file.  Once registered, sounds can be played using `createjs.Sound.play()`.\n\nExample of playing a sound:\n\n```javascript\n// Preload the sound (recommended for better performance)\ncreatejs.Sound.registerSound(\"./mySound.mp3\", \"mySound\");\n\n// Play the sound\ncreatejs.Sound.play(\"mySound\");\n```\n\nEnsure that the sound file exists at the specified path and that it's in a supported format (MP3, Ogg, WAV are commonly supported).\n\n\n### Sound Effects and Music\n\nSoundJS can handle both short sound effects and longer music tracks.  The distinction is primarily in how you manage their playback and potential looping.  Short sound effects are typically played once, while music tracks may loop continuously or play for a specific duration.\n\nExample of playing a looping music track:\n\n```javascript\ncreatejs.Sound.registerSound(\"./myMusic.mp3\", \"myMusic\");\nlet instance = createjs.Sound.play(\"myMusic\", {loop: -1}); // -1 loops indefinitely\n```\n\nYou can stop the music using `instance.stop();` where `instance` is the reference to the sound instance obtained from `createjs.Sound.play()`.\n\n\n### Sound Playback Control\n\nSoundJS provides various methods to control sound playback:\n\n* **`pause()`:** Pauses the currently playing sound.\n* **`resume()`:** Resumes a paused sound.\n* **`stop()`:** Stops the sound and resets its position.\n* **`setVolume()`:** Adjusts the volume of a playing sound.\n* **`setPosition()`:** Sets the playback position (in milliseconds).\n* **`getVolume()`:** Retrieves the current volume.\n* **`getPosition()`:** Retrieves the current playback position.\n\nThese methods operate on the sound instance returned by `createjs.Sound.play()`.\n\n\n### Audio Sprites\n\nAudio sprites are a technique for storing multiple sounds within a single audio file.  SoundJS supports audio sprites by specifying the start and end times of each sound within the file. This is useful for optimizing loading times and reducing the number of individual audio files.\n\nExample using an audio sprite:\n\n```javascript\n// Preload the sprite sheet.\ncreatejs.Sound.registerSound(\"./soundSprite.mp3\", \"soundSprite\");\nlet soundManifest = [\n    {id: \"sound1\", src: \"soundSprite.mp3\", data:{offset:0, duration: 1000}}, // 1-second sound\n    {id: \"sound2\", src: \"soundSprite.mp3\", data:{offset:1000, duration: 500}}   // 0.5-second sound\n];\ncreatejs.Sound.registerManifest(soundManifest);\n//Play the audio sprites\ncreatejs.Sound.play(\"sound1\");\ncreatejs.Sound.play(\"sound2\");\n\n```\n\nNote: `offset` is in milliseconds.\n\n\n### Handling Errors and Events\n\nSoundJS provides mechanisms for handling errors and events during audio playback:\n\n* **Error Handling:** SoundJS can throw errors if a sound file fails to load or if there's a problem during playback. Implement `try...catch` blocks to handle potential exceptions.\n\n* **Event Handling:**  Events such as `complete` (sound finished playing) or `interrupt` (sound interrupted by another) can be listened for using `addEventListener()`.\n\nExample of adding an event listener:\n\n```javascript\nlet instance = createjs.Sound.play(\"mySound\");\ninstance.addEventListener(\"complete\", handleSoundComplete);\n\nfunction handleSoundComplete(event) {\n  console.log(\"Sound finished playing!\");\n}\n```\n\nProper error and event handling ensures robust audio management in your application. Remember to handle potential issues gracefully to improve the user experience.\n\n\n## PreloadJS: Asset Management\n\n### Loading Images, Sounds, and Other Assets\n\nPreloadJS is a powerful library for managing the loading of assets in your CreateJS applications.  It handles the asynchronous loading of various asset types (images, sounds, text files, JSON data, etc.), providing a structured and efficient way to manage the loading process.  The core class is `createjs.LoadQueue`.  You create a `LoadQueue` instance and add files to it using the `loadManifest()` method, which takes an array of file specifications.\n\nExample of loading images:\n\n```javascript\nlet queue = new createjs.LoadQueue(true); // true enables file progress events\nqueue.loadManifest([\n    {id: \"image1\", src: \"image1.jpg\"},\n    {id: \"image2\", src: \"image2.png\"}\n]);\n\nqueue.on(\"complete\", handleComplete, this);\n\nfunction handleComplete() {\n    let image1 = queue.getResult(\"image1\");\n    let bitmap1 = new createjs.Bitmap(image1);\n    // ... add bitmap to stage ...\n}\n\n```\n\nThis code creates a `LoadQueue`, loads two images, and uses an event listener to execute `handleComplete()` after the loading is finished, where `queue.getResult(\"image1\")` retrieves the loaded image.\n\n\n### Progress Monitoring\n\nPreloadJS provides progress events that allow you to monitor the loading status of your assets.  The `progress` event fires periodically, giving you the percentage of completed loading.  The `complete` event indicates that all assets have been loaded successfully.\n\nExample of monitoring progress:\n\n```javascript\nqueue.on(\"progress\", handleProgress, this);\nqueue.on(\"complete\", handleComplete, this);\n\nfunction handleProgress(event) {\n    console.log(\"Loading progress: \" + Math.round(event.progress * 100) + \"%\");\n}\n\nfunction handleComplete() {\n    console.log(\"All assets loaded!\");\n}\n```\n\nThis code adds event listeners to track both progress and completion.\n\n\n### Error Handling\n\nPreloadJS provides mechanisms for handling errors during asset loading.  The `error` event fires when an asset fails to load.  The event object provides information about the failed asset.\n\nExample of handling errors:\n\n```javascript\nqueue.on(\"error\", handleError, this);\n\nfunction handleError(event) {\n    console.error(\"Error loading asset:\", event.item);\n}\n```\n\nThis code adds an error handler to gracefully manage asset loading failures.\n\n\n### Manifest Files and Configuration\n\nFor larger projects, it's often beneficial to use manifest files (typically JSON files) to define the assets to be loaded.  Manifest files provide a centralized and organized way to specify asset paths, IDs, and other metadata.  PreloadJS can load assets directly from a manifest file.\n\nExample manifest file (`manifest.json`):\n\n```json\n[\n    {id: \"image1\", src: \"image1.jpg\"},\n    {id: \"sound1\", src: \"sound1.mp3\"},\n    {id: \"data1\", src: \"data1.json\"}\n]\n```\n\nExample loading from a manifest:\n\n```javascript\nlet queue = new createjs.LoadQueue(true);\nqueue.loadManifest(\"./manifest.json\");\n// ... add event listeners ...\n```\n\n\n### Advanced Loading Techniques\n\nPreloadJS offers advanced features for optimizing asset loading:\n\n* **Prioritization:** You can prioritize the loading of certain assets by specifying a `priority` property in the manifest.  Higher priority assets are loaded first.\n* **File Types:** PreloadJS supports a wide range of file types, including those requiring special handling (e.g., spritesheets).\n* **Plugins:** Custom plugins can be used to extend PreloadJS to support additional file types or loading methods.\n* **Cross-Origin Loading:** Configuring the `crossOrigin` property allows you to load assets from different domains.\n* **Caching:** PreloadJS allows you to utilize browser caching effectively for repeat loading of assets.\n\nBy understanding these advanced techniques, you can optimize your asset loading strategy to enhance the performance of your CreateJS applications. Remember to always test and profile your asset loading procedures to ensure optimal efficiency for your target audience and devices.\n\n\n## Utility Libraries\n\n### Ticker and Tick Events\n\nThe CreateJS `Ticker` is a core utility class providing a consistent and high-performance mechanism for executing code at regular intervals, forming the basis for animation and other time-based events. The `Ticker` dispatches \"tick\" events, which are crucial for updating the display and performing animations in EaselJS and other CreateJS libraries.  It's designed to be highly efficient and cross-browser compatible, handling inconsistencies in browser timing mechanisms.\n\nThe `Ticker` can be used in different modes:\n\n* **`Ticker.framerate = 60;`:** Sets a target frames-per-second (fps) rate. The `Ticker` will attempt to maintain this rate, but performance limitations may cause the actual frame rate to vary.\n\n* **Time-based updates:**  The `Ticker`'s `time` property provides the elapsed time in milliseconds since the last tick, allowing for time-based animations and physics calculations.  This approach is generally preferred for smoother and more consistent results.\n\n* **Event listeners:**  You add listeners to the `Ticker` to execute code on each tick.  The `tick` event provides an object with details such as the current time and delta time.\n\nExample using the `Ticker` for animation:\n\n```javascript\ncreatejs.Ticker.addEventListener(\"tick\", handleTick);\n\nfunction handleTick(event) {\n  // Update game state based on the time elapsed since the last tick (event.delta)\n  myObject.x += 5; // Example: move an object 5 pixels\n  stage.update(event); // Update the display\n}\n```\n\nThe `stage.update(event)` call is crucial to refresh the canvas display after each update.\n\n\n### EventDispatcher\n\nThe `createjs.EventDispatcher` class is a fundamental utility for managing events throughout CreateJS.  Many CreateJS objects (including the `Stage`, `DisplayObject`, `LoadQueue`, and `SoundInstance` classes) inherit from `EventDispatcher`, providing a consistent event handling mechanism. This promotes modularity and provides a clean pattern for managing interactions.\n\nKey functionalities include:\n\n* **`addEventListener(type, listener, [scope], [once])`:** Attaches an event listener to the dispatcher.  `type` specifies the event type (e.g., \"tick\", \"complete\", \"click\"); `listener` is the function to execute; `scope` (optional) specifies the `this` context for the listener; `once` (optional, boolean) removes the listener after it's executed once.\n\n* **`removeEventListener(type, listener, [scope])`:** Removes an event listener.\n\n* **`dispatchEvent(event)`:** Dispatches an event.   This is frequently used internally by CreateJS objects but can also be utilized to create custom events.\n\n* **`hasEventListener(type)`:** Checks if there are any listeners for a specific event type.\n\nExample using `EventDispatcher`:\n\n```javascript\nlet myObject = new createjs.EventDispatcher();\n\nmyObject.addEventListener(\"myCustomEvent\", handleMyEvent);\n\nfunction handleMyEvent(event) {\n  console.log(\"My custom event triggered!\", event);\n}\n\nmyObject.dispatchEvent({type: \"myCustomEvent\", data: \"some data\"});\n```\n\nThis example shows creating a custom event and attaching a listener to handle it.  The `EventDispatcher` provides a structured and powerful way to manage events within and between different CreateJS components.  Understanding its use is crucial for building more complex and interactive applications.\n\n\n## Advanced Topics\n\n### Performance Optimization\n\nOptimizing performance is crucial for creating smooth and responsive CreateJS applications, especially when dealing with complex scenes or animations.  Key strategies include:\n\n* **Minimize Display Objects:**  Reduce the number of objects on the stage. Group similar objects into containers to decrease the number of individual objects that need to be rendered.\n\n* **Caching:** Use `cache()` on display objects to improve rendering speed.  Caching creates a bitmap representation of the object, improving drawing performance.  However, be mindful that frequently updating cached objects can negate the performance benefits.\n\n* **Update Only When Necessary:** Avoid unnecessary updates to the stage using `stage.update()`.  Only update when the display needs to be refreshed.  This is particularly important for animations, where frequent updates can impact performance.\n\n* **Efficient Animation Techniques:** Use TweenJS for smooth animations and avoid excessive calculations within the `tick` handler.  Consider using techniques like object pooling to reuse objects instead of constantly creating and destroying them.\n\n* **Reduce Rich Text Use:** Rich text can impact performance; consider using plain text whenever possible for large amounts of text.\n\n* **Image Optimization:** Optimize images for web use (e.g., using appropriate formats and compression).  Preload images using PreloadJS to prevent visual hiccups.\n\n* **Profiling:** Use browser developer tools to profile your application and identify performance bottlenecks.  This allows you to focus your optimization efforts on the most impactful areas.\n\n\n### Debugging and Troubleshooting\n\nDebugging CreateJS applications often involves standard JavaScript debugging techniques, but specific CreateJS considerations include:\n\n* **Browser Developer Tools:** Use your browser's developer tools (Console, Network, and Profiler) to inspect the application's behavior, identify errors, and profile performance.\n\n* **Logging:** Use `console.log()` strategically to track variable values and the execution flow of your code.\n\n* **Inspecting the Stage:** Use the browser's developer tools to inspect the stage and its children to understand the structure of your display list. This can help identify unexpected object positions or hierarchies.\n\n* **Error Handling:**  Implement proper error handling in your code to catch and address potential issues during asset loading, animation, or event handling.\n\n\n### Integrating with Other Libraries\n\nCreateJS is designed to work well with other JavaScript libraries.  Common integration points include:\n\n* **Game Engines:** Integrate CreateJS with game engines like Phaser or PixiJS for enhanced functionality.\n\n* **Physics Engines:** Use physics engines like Matter.js or Box2D for realistic physics simulations in your applications.\n\n* **UI Libraries:** Integrate UI libraries for building richer user interfaces.\n\nRemember to consider potential conflicts between libraries and ensure proper initialization and compatibility.\n\n\n### Creating Interactive Applications\n\nCreateJS provides a strong foundation for building interactive applications.  Effective strategies include:\n\n* **Event Handling:**  Utilize the `EventDispatcher` effectively to manage user interactions (mouse clicks, keyboard presses, touch events).\n\n* **State Management:**  Implement a clear state management system to track the application's status and respond to user input accordingly.  Consider using state machines or similar design patterns.\n\n* **User Interface (UI) Design:**  Design a well-structured and intuitive user interface for improved usability.\n\n* **Game Loop/Animation Loop:**  Use the `Ticker` to manage the application's main loop, updating game state and rendering the display.\n\n\n### Working with External Data Sources\n\nFetching and using external data (from JSON APIs, databases, etc.) involves:\n\n* **Data Fetching:** Use `fetch`, XMLHttpRequest, or libraries like jQuery or Axios to retrieve data from external sources.\n\n* **Data Parsing:** Parse the received data (often JSON) into usable formats using JavaScript's `JSON.parse()`.\n\n* **Data Integration:** Integrate the parsed data into your CreateJS application, updating objects, animations, or other components.\n\n\n### Accessibility Considerations\n\nAccessibility is crucial for inclusive application design.  Consider these points:\n\n* **Keyboard Navigation:** Ensure that users can navigate and interact with the application using only the keyboard.\n\n* **Screen Readers:** Use semantic HTML and ARIA attributes to provide screen reader support.\n\n* **Alternative Text:**  Provide alternative text (`alt` attributes) for images to describe their content for users who cannot see them.\n\n* **Color Contrast:**  Maintain sufficient color contrast between text and background colors for readability.\n\n\n### Best Practices\n\n* **Modular Design:**  Break down your code into smaller, reusable modules.\n\n* **Code Comments:**  Write clear and concise comments to explain your code's functionality.\n\n* **Version Control:**  Use a version control system (like Git) to manage your code changes.\n\n* **Testing:**  Write unit tests to verify the functionality of individual components.\n\n* **Consistent Code Style:**  Follow a consistent code style to improve readability and maintainability.\n\n* **Performance Monitoring:** Regularly monitor the performance of your application and optimize as needed.  Keep abreast of performance optimization techniques relevant to CreateJS and the technologies you integrate it with.\n\n\n\n\n## Examples and Tutorials\n\nThis section provides a starting point for exploring the capabilities of CreateJS through various examples and tutorials.  More extensive examples and tutorials can be found on the official CreateJS website and community resources.\n\n### Simple Animations\n\nSimple animations are a great way to start learning CreateJS.  These examples focus on basic animation principles using EaselJS and TweenJS.  They often involve animating the position, scale, rotation, or alpha (opacity) of simple shapes or bitmaps.\n\n**Example:** A bouncing ball animation can be created by using TweenJS to repeatedly change the ball's vertical position, applying an easing function to simulate the bounce.  This would involve setting up a `Ticker` event listener to update the ball's position in each tick and using `createjs.Tween.get()` to control the animation's timing and easing.\n\n\n### Interactive Games\n\nInteractive games showcase the capabilities of CreateJS for creating engaging user experiences.  These examples usually demonstrate the use of event handling, collision detection, and game logic.\n\n**Example:** A simple \"Breakout\" clone could be developed using EaselJS to render the bricks, paddle, and ball.  TweenJS would handle the ball's movement, and event listeners would respond to mouse or touch input for paddle control.  Collision detection would be implemented to handle ball-brick and ball-paddle interactions, managing score and game state.\n\n\n### Complex Visualizations\n\nComplex visualizations demonstrate how CreateJS can handle large datasets and sophisticated graphics.  These examples highlight the importance of performance optimization techniques.\n\n**Example:** A data visualization displaying stock prices over time could use EaselJS to create a line graph.  The graph would dynamically update based on data fetched from an external source.  Efficient techniques would be employed to handle large datasets smoothly.  This might involve techniques like data chunking or using containers to manage the visual elements efficiently.  Consider the use of efficient data structures and algorithms to optimize the update process.\n\n\n### Case Studies\n\nCase studies offer in-depth looks at real-world applications built with CreateJS.  These provide insight into architectural decisions, problem-solving approaches, and best practices.\n\n**Example:** A case study could analyze the implementation of a web-based interactive map using CreateJS.  The study would discuss how assets were managed (e.g., using PreloadJS), how map interactions were handled, and strategies employed for optimizing performance when displaying large maps. It might highlight challenges encountered and the solutions implemented. It could also include performance benchmarks and user feedback.\n\n\nThese examples and tutorials are intended as starting points.  Experimenting with different techniques and expanding on these basic concepts will help you master CreateJS and build sophisticated applications.  Remember to refer to the official CreateJS documentation and community resources for more detailed information and inspiration.\n\n\n## Appendix\n\n### Glossary of Terms\n\nThis glossary defines key terms used throughout the CreateJS documentation.\n\n* **Bitmap:** A visual representation of an image file (e.g., PNG, JPG) displayed on the canvas.\n* **Container:** An invisible display object that acts as a holder for other display objects, allowing for grouping and hierarchical organization.\n* **Display List:** The hierarchical structure of display objects within the `Stage`.  Efficient organization of the display list is crucial for performance.\n* **Display Object:**  Any visual element (shape, bitmap, text, container) that can be added to the stage and manipulated.\n* **Easing Function:** A function that controls the speed and timing of an animation, creating different animation curves.\n* **Event Dispatcher:** A class that manages the dispatching and handling of events.\n* **Frame Rate:** The number of frames rendered per second in an animation.\n* **Manifest:** A file (often JSON) that lists assets to be loaded using PreloadJS.\n* **Stage:** The root of the display list; represents the canvas element where everything is drawn.\n* **Tick:** A single frame in the animation loop; the `Ticker` dispatches `tick` events.\n* **Tween:** An animation that smoothly transitions the properties of an object over time, usually managed using TweenJS.\n\n\n### API Reference\n\nA comprehensive API reference provides detailed information about all classes, methods, and properties within the CreateJS libraries.  This reference typically includes:\n\n* **Class descriptions:**  Detailed explanations of each class's purpose and functionality.\n* **Method descriptions:**  Descriptions of each method's parameters, return values, and usage examples.\n* **Property descriptions:** Descriptions of each property's data type, purpose, and usage.\n* **Inheritance diagrams:** Visual representations of the class hierarchy.\n* **Code examples:**  Illustrative code snippets demonstrating the use of each class and method.\n\nThe location of the complete API reference will vary depending on the version of CreateJS and the preferred method of access (e.g., online documentation, locally downloaded files).\n\n\n### Troubleshooting Common Issues\n\nThis section addresses frequently encountered problems and provides solutions. Common issues may include:\n\n* **Canvas not rendering:** Check that your canvas element is correctly added to the HTML and that you are referencing it properly in your JavaScript code.  Ensure that your script is loading correctly and that there are no JavaScript errors preventing execution.\n\n* **Assets not loading:**  Verify that the asset paths specified in your manifest or `loadManifest()` calls are correct and that the assets exist at the specified locations. Use the browser's developer tools to inspect network requests and check for any errors.\n\n* **Animations not working:**  Ensure that the `Ticker` is properly configured and that the `stage.update()` method is called in each `tick` event handler. Double-check that your tween configurations are correct and that the target objects are added to the stage.\n\n* **Event listeners not firing:** Ensure event listeners are added correctly using `addEventListener()`, with the proper event type and callback function.  Check the event bubbling and capturing phases to make sure the event is reaching your listener.\n\n* **Performance problems:**  Optimize your code using techniques discussed in the \"Performance Optimization\" section.  Use the browser's developer tools to profile your application to pinpoint performance bottlenecks.\n\n\n### Community Resources and Support\n\nThe CreateJS community offers various resources for support and collaboration:\n\n* **Official CreateJS Website:** The official website provides up-to-date documentation, examples, and release notes.\n\n* **Online Forums and Communities:** Search for CreateJS forums and online communities where developers discuss issues, share solutions, and assist each other.\n\n* **GitHub Repository:** The CreateJS GitHub repository contains the source code and issue tracker.  You can report bugs, suggest features, and contribute to the project's development.\n\n* **Stack Overflow:** Search Stack Overflow for answers to frequently asked questions.  When asking for help, provide detailed information about your issue, including relevant code snippets.\n\nEngaging with the community is a valuable way to resolve issues, learn best practices, and stay informed about updates and developments in CreateJS.\n\n","srcMarkdownNoYaml":"\n\n\n### What is CreateJS?\n\nCreateJS is a suite of modular libraries and tools that simplify HTML5 canvas development.  It provides a consistent, easy-to-use API for working with shapes, text, images, video, and more, abstracting away many of the complexities of the underlying Canvas API.  The libraries are designed to be lightweight, performant, and cross-browser compatible, making them suitable for a wide range of projects, from simple animations to complex interactive applications.  CreateJS includes several key libraries: EaselJS (for display and animation), TweenJS (for animation), SoundJS (for audio playback), and PreloadJS (for asset loading).\n\n### Why Use CreateJS?\n\nCreateJS offers several compelling reasons for choosing it as your HTML5 canvas framework:\n\n* **Simplified API:**  CreateJS significantly simplifies the often-complex Canvas API, making it easier to learn and use, especially for developers with experience in other animation frameworks.\n* **Modular Design:** The modular structure allows you to include only the libraries you need, reducing the overall size of your project.  This makes CreateJS suitable for both small and large-scale projects.\n* **Cross-browser Compatibility:** CreateJS handles the cross-browser inconsistencies of the Canvas API, ensuring consistent performance across different browsers and devices.\n* **Performance:**  CreateJS is designed for optimal performance, making it suitable for creating demanding animations and interactive experiences.\n* **Ease of Use:** The intuitive API and well-documented examples make it easy to get started with CreateJS and build sophisticated applications quickly.\n* **Mature and Supported:** CreateJS is a mature library with a large and active community, ensuring ongoing support and development.\n\n\n### Setting up your Development Environment\n\nSetting up your development environment for CreateJS is straightforward. You primarily need:\n\n1. **A Text Editor or IDE:** Choose your preferred code editor (e.g., VS Code, Sublime Text, Atom) or an Integrated Development Environment (IDE) like WebStorm.\n\n2. **A Web Browser:**  Modern browsers (Chrome, Firefox, Safari, Edge) all support the HTML5 Canvas API and will work with CreateJS.\n\n3. **The CreateJS Libraries:** Download the CreateJS libraries from the official CreateJS website or use a CDN (Content Delivery Network) to include them in your project.  CDNs provide quick access and avoid the need for local downloads.  An example using a CDN is shown below:\n\n```html\n<script src=\"https://code.createjs.com/1.0.0/createjs.min.js\"></script>\n```\nRemember to replace `1.0.0` with the desired CreateJS version.\n\n\n4. **An HTML File:** Create an HTML file to structure your project. This file will include the CreateJS libraries and your JavaScript code.\n\n5. **A JavaScript File (Optional):** For larger projects, it's recommended to keep your CreateJS code in a separate JavaScript file for better organization and maintainability.\n\n\n### CreateJS Libraries and Modules\n\nCreateJS consists of several core libraries, each focusing on a specific aspect of canvas development:\n\n* **EaselJS:** This is the core library for managing the display list, creating and manipulating shapes, text, bitmaps, and containers.  It handles drawing, transformations, and event handling.\n\n* **TweenJS:** This library provides powerful and flexible tweening capabilities, allowing you to animate properties of EaselJS objects smoothly over time.  You can control timing, easing functions, and multiple chained tweens.\n\n* **SoundJS:**  This library simplifies audio playback and management.  It provides cross-browser compatibility and handles loading, playing, and controlling audio files.\n\n* **PreloadJS:** This library manages the loading of assets such as images, sounds, and other files, providing progress events and error handling to ensure smooth loading of your application's resources.\n\nEach library is self-contained and can be used independently, or in combination with the others to create complex and interactive applications.  Understanding the functionality of each library is crucial for effective CreateJS development.\n\n\n## EaselJS: Displaying Graphics\n\n### Stage, Shapes, and Containers\n\nEaselJS uses a `Stage` object as the root of the display list. The stage represents the canvas element where everything is drawn.  All display objects, including shapes, bitmaps, text, and containers, are added to the stage.  Containers are crucial for organizing and managing complex scenes; they act as invisible holders for other display objects, allowing you to group and manipulate them together.\n\nShapes are created using classes like `Shape`, `Circle`, `Rectangle`, and `Ellipse`. You define their properties (like color, fill, stroke) and add them to the stage or a container.  For complex shapes, you can use the `graphics` API to draw paths.\n\nExample of creating a simple circle and adding it to the stage:\n\n```javascript\nlet stage = new createjs.Stage(\"myCanvas\"); // \"myCanvas\" is the ID of your canvas element\nlet circle = new createjs.Shape();\ncircle.graphics.beginFill(\"red\").drawCircle(50, 50, 30);\nstage.addChild(circle);\nstage.update();\n```\n\n\n### Working with Bitmaps\n\nEaselJS allows you to easily display images using the `Bitmap` class. You create a `Bitmap` object by providing an image URL or an existing HTMLImageElement.  Once added to the stage, bitmaps can be scaled, rotated, and repositioned like other display objects.  For optimal performance, preload images using PreloadJS before adding them to the stage.\n\nExample of loading and displaying a bitmap:\n\n```javascript\nlet image = new Image();\nimage.onload = function() {\n  let bitmap = new createjs.Bitmap(image);\n  stage.addChild(bitmap);\n  stage.update();\n};\nimage.src = \"myImage.png\";\n```\n\n### Text and Typography\n\nEaselJS provides the `Text` class for rendering text on the canvas. You can control font size, family, color, and alignment.  You can also use rich text with HTML-like formatting, though this may affect rendering performance for large amounts of text.  For improved performance with multiple lines of text, consider using a `TextField` instead.\n\nExample of creating and adding text:\n\n```javascript\nlet text = new createjs.Text(\"Hello, world!\", \"20px Arial\", \"#000000\");\ntext.x = 100;\ntext.y = 100;\nstage.addChild(text);\nstage.update();\n```\n\n\n### Event Handling\n\nEaselJS makes event handling straightforward.  You can add event listeners to display objects to respond to mouse events (click, mouseover, mouseout, etc.) and stage events.  The `addEventListener` method is used to attach listeners.\n\nExample of adding a click event listener to a shape:\n\n```javascript\ncircle.addEventListener(\"click\", function(event) {\n  console.log(\"Circle clicked!\");\n});\n```\n\n\n### Animation Fundamentals\n\nAnimation in EaselJS is typically achieved by repeatedly updating the properties (position, rotation, scale) of display objects within a `tick` event handler.  The `Ticker` class provides a consistent update loop. You modify the object's properties in each tick, creating the illusion of movement.\n\nExample of basic animation using the Ticker:\n\n```javascript\ncreatejs.Ticker.addEventListener(\"tick\", handleTick);\nfunction handleTick(event) {\n  circle.x += 2; // Move the circle 2 pixels to the right each frame.\n  stage.update(event);\n}\n```\n\n### Tweens and Timers\n\nTweenJS offers a powerful and efficient way to create smooth animations. It handles transitions between property values over a specified duration, using various easing functions.  Timers provide a simple way to execute functions at specified intervals.\n\nExample of a simple tween:\n\n```javascript\ncreatejs.Tween.get(circle).to({x: 300, y: 200}, 1000, createjs.Ease.linear); // Move circle over 1 second.\n\n```\n\n### Display Lists and Optimization\n\nThe EaselJS display list is a hierarchical structure of display objects.  Efficient organization is crucial for performance, especially in complex scenes.  Minimize the number of objects on the stage, group related objects into containers, and use caching strategically to improve rendering speeds.  Avoid excessive use of rich text and unnecessary updates to improve performance further.  Understanding the display list structure and using optimization techniques is essential for creating high-performance applications.\n\n\n## TweenJS: Animation and Transitions\n\n### Basic Tweening\n\nTweenJS simplifies the creation of animations by providing methods to smoothly transition the properties of objects over time.  The core function is `createjs.Tween.get()`, which takes a target object and allows you to define the properties to animate, their target values, and the duration of the animation.\n\nA basic example of tweening an object's `x` and `y` properties:\n\n```javascript\nlet circle = new createjs.Shape();\n// ... (add circle to stage) ...\n\ncreatejs.Tween.get(circle)\n  .to({ x: 200, y: 100 }, 1000); // Move to (200, 100) over 1000 milliseconds (1 second)\n```\n\nThis code will smoothly animate the `circle`'s position from its current location to (200, 100) over one second.  You can specify multiple properties within the `to()` method.\n\n\n### Easing Functions\n\nEasing functions control the speed and timing of the animation.  TweenJS provides a range of built-in easing functions (e.g., `createjs.Ease.linear`, `createjs.Ease.quadIn`, `createjs.Ease.cubicOut`, etc.), each creating a different animation curve.  These control the rate of change of the animated property over time, affecting the perceived smoothness and character of the animation.\n\nExample using a different easing function:\n\n```javascript\ncreatejs.Tween.get(circle)\n  .to({ x: 200, y: 100 }, 1000, createjs.Ease.backOut); // Uses a bounce-back effect.\n```\n\n\n### Chaining Tweens\n\nTweens can be chained together to create complex animations with multiple stages.  Each `.to()` call adds a new tween segment to the animation sequence.  You can define different properties and durations for each segment.\n\nExample of chaining tweens:\n\n```javascript\ncreatejs.Tween.get(circle)\n  .to({ x: 200, y: 100 }, 1000, createjs.Ease.quadOut)\n  .to({ x: 400, y: 200, alpha: 0 }, 500, createjs.Ease.sineIn); // Fade out while moving\n```\n\nThis code moves the circle to (200, 100) using a quadratic easing, then to (400, 200) while fading it out using a sine easing.\n\n\n### Complex Animations\n\nTweenJS is capable of animating various properties beyond simple position.  You can animate alpha (opacity), scale, rotation, color, and even custom properties.  For more complex animations involving multiple objects or coordinated movements, you may need to use callbacks or event listeners to synchronize actions.  Consider structuring your code efficiently, perhaps by grouping animations using containers, for better organization.\n\nExample animating multiple properties:\n\n```javascript\ncreatejs.Tween.get(circle)\n  .to({ x: 200, y: 100, scaleX: 2, scaleY: 2, alpha: 0.5 }, 1000);\n```\n\n\n### TweenJS Events\n\nTweenJS provides events that allow you to execute functions at specific points in an animation's lifecycle (e.g., `change`, `complete`).  This allows for precise control and the triggering of other actions based on animation progress.  Event listeners are added using `addEventListener()`.\n\nExample of using a `complete` event:\n\n```javascript\ncreatejs.Tween.get(circle)\n  .to({ x: 200, y: 100 }, 1000)\n  .addEventListener(\"change\", function(event) {\n    console.log(\"Tween is changing\");\n  })\n  .addEventListener(\"complete\", function(event) {\n    console.log(\"Tween is complete\");\n    // Perform additional actions here\n  });\n```\nThe `change` event fires during the animation, and the `complete` event fires when the animation concludes.  Other useful events include `paused` and `resume`.\n\n\n## SoundJS: Audio Integration\n\n### Playing Sounds\n\nSoundJS simplifies the process of playing audio files in your CreateJS applications.  The core class is `createjs.Sound`.  Before playing sounds, you must register them using `createjs.Sound.registerSound()`, which takes a path to the sound file.  Once registered, sounds can be played using `createjs.Sound.play()`.\n\nExample of playing a sound:\n\n```javascript\n// Preload the sound (recommended for better performance)\ncreatejs.Sound.registerSound(\"./mySound.mp3\", \"mySound\");\n\n// Play the sound\ncreatejs.Sound.play(\"mySound\");\n```\n\nEnsure that the sound file exists at the specified path and that it's in a supported format (MP3, Ogg, WAV are commonly supported).\n\n\n### Sound Effects and Music\n\nSoundJS can handle both short sound effects and longer music tracks.  The distinction is primarily in how you manage their playback and potential looping.  Short sound effects are typically played once, while music tracks may loop continuously or play for a specific duration.\n\nExample of playing a looping music track:\n\n```javascript\ncreatejs.Sound.registerSound(\"./myMusic.mp3\", \"myMusic\");\nlet instance = createjs.Sound.play(\"myMusic\", {loop: -1}); // -1 loops indefinitely\n```\n\nYou can stop the music using `instance.stop();` where `instance` is the reference to the sound instance obtained from `createjs.Sound.play()`.\n\n\n### Sound Playback Control\n\nSoundJS provides various methods to control sound playback:\n\n* **`pause()`:** Pauses the currently playing sound.\n* **`resume()`:** Resumes a paused sound.\n* **`stop()`:** Stops the sound and resets its position.\n* **`setVolume()`:** Adjusts the volume of a playing sound.\n* **`setPosition()`:** Sets the playback position (in milliseconds).\n* **`getVolume()`:** Retrieves the current volume.\n* **`getPosition()`:** Retrieves the current playback position.\n\nThese methods operate on the sound instance returned by `createjs.Sound.play()`.\n\n\n### Audio Sprites\n\nAudio sprites are a technique for storing multiple sounds within a single audio file.  SoundJS supports audio sprites by specifying the start and end times of each sound within the file. This is useful for optimizing loading times and reducing the number of individual audio files.\n\nExample using an audio sprite:\n\n```javascript\n// Preload the sprite sheet.\ncreatejs.Sound.registerSound(\"./soundSprite.mp3\", \"soundSprite\");\nlet soundManifest = [\n    {id: \"sound1\", src: \"soundSprite.mp3\", data:{offset:0, duration: 1000}}, // 1-second sound\n    {id: \"sound2\", src: \"soundSprite.mp3\", data:{offset:1000, duration: 500}}   // 0.5-second sound\n];\ncreatejs.Sound.registerManifest(soundManifest);\n//Play the audio sprites\ncreatejs.Sound.play(\"sound1\");\ncreatejs.Sound.play(\"sound2\");\n\n```\n\nNote: `offset` is in milliseconds.\n\n\n### Handling Errors and Events\n\nSoundJS provides mechanisms for handling errors and events during audio playback:\n\n* **Error Handling:** SoundJS can throw errors if a sound file fails to load or if there's a problem during playback. Implement `try...catch` blocks to handle potential exceptions.\n\n* **Event Handling:**  Events such as `complete` (sound finished playing) or `interrupt` (sound interrupted by another) can be listened for using `addEventListener()`.\n\nExample of adding an event listener:\n\n```javascript\nlet instance = createjs.Sound.play(\"mySound\");\ninstance.addEventListener(\"complete\", handleSoundComplete);\n\nfunction handleSoundComplete(event) {\n  console.log(\"Sound finished playing!\");\n}\n```\n\nProper error and event handling ensures robust audio management in your application. Remember to handle potential issues gracefully to improve the user experience.\n\n\n## PreloadJS: Asset Management\n\n### Loading Images, Sounds, and Other Assets\n\nPreloadJS is a powerful library for managing the loading of assets in your CreateJS applications.  It handles the asynchronous loading of various asset types (images, sounds, text files, JSON data, etc.), providing a structured and efficient way to manage the loading process.  The core class is `createjs.LoadQueue`.  You create a `LoadQueue` instance and add files to it using the `loadManifest()` method, which takes an array of file specifications.\n\nExample of loading images:\n\n```javascript\nlet queue = new createjs.LoadQueue(true); // true enables file progress events\nqueue.loadManifest([\n    {id: \"image1\", src: \"image1.jpg\"},\n    {id: \"image2\", src: \"image2.png\"}\n]);\n\nqueue.on(\"complete\", handleComplete, this);\n\nfunction handleComplete() {\n    let image1 = queue.getResult(\"image1\");\n    let bitmap1 = new createjs.Bitmap(image1);\n    // ... add bitmap to stage ...\n}\n\n```\n\nThis code creates a `LoadQueue`, loads two images, and uses an event listener to execute `handleComplete()` after the loading is finished, where `queue.getResult(\"image1\")` retrieves the loaded image.\n\n\n### Progress Monitoring\n\nPreloadJS provides progress events that allow you to monitor the loading status of your assets.  The `progress` event fires periodically, giving you the percentage of completed loading.  The `complete` event indicates that all assets have been loaded successfully.\n\nExample of monitoring progress:\n\n```javascript\nqueue.on(\"progress\", handleProgress, this);\nqueue.on(\"complete\", handleComplete, this);\n\nfunction handleProgress(event) {\n    console.log(\"Loading progress: \" + Math.round(event.progress * 100) + \"%\");\n}\n\nfunction handleComplete() {\n    console.log(\"All assets loaded!\");\n}\n```\n\nThis code adds event listeners to track both progress and completion.\n\n\n### Error Handling\n\nPreloadJS provides mechanisms for handling errors during asset loading.  The `error` event fires when an asset fails to load.  The event object provides information about the failed asset.\n\nExample of handling errors:\n\n```javascript\nqueue.on(\"error\", handleError, this);\n\nfunction handleError(event) {\n    console.error(\"Error loading asset:\", event.item);\n}\n```\n\nThis code adds an error handler to gracefully manage asset loading failures.\n\n\n### Manifest Files and Configuration\n\nFor larger projects, it's often beneficial to use manifest files (typically JSON files) to define the assets to be loaded.  Manifest files provide a centralized and organized way to specify asset paths, IDs, and other metadata.  PreloadJS can load assets directly from a manifest file.\n\nExample manifest file (`manifest.json`):\n\n```json\n[\n    {id: \"image1\", src: \"image1.jpg\"},\n    {id: \"sound1\", src: \"sound1.mp3\"},\n    {id: \"data1\", src: \"data1.json\"}\n]\n```\n\nExample loading from a manifest:\n\n```javascript\nlet queue = new createjs.LoadQueue(true);\nqueue.loadManifest(\"./manifest.json\");\n// ... add event listeners ...\n```\n\n\n### Advanced Loading Techniques\n\nPreloadJS offers advanced features for optimizing asset loading:\n\n* **Prioritization:** You can prioritize the loading of certain assets by specifying a `priority` property in the manifest.  Higher priority assets are loaded first.\n* **File Types:** PreloadJS supports a wide range of file types, including those requiring special handling (e.g., spritesheets).\n* **Plugins:** Custom plugins can be used to extend PreloadJS to support additional file types or loading methods.\n* **Cross-Origin Loading:** Configuring the `crossOrigin` property allows you to load assets from different domains.\n* **Caching:** PreloadJS allows you to utilize browser caching effectively for repeat loading of assets.\n\nBy understanding these advanced techniques, you can optimize your asset loading strategy to enhance the performance of your CreateJS applications. Remember to always test and profile your asset loading procedures to ensure optimal efficiency for your target audience and devices.\n\n\n## Utility Libraries\n\n### Ticker and Tick Events\n\nThe CreateJS `Ticker` is a core utility class providing a consistent and high-performance mechanism for executing code at regular intervals, forming the basis for animation and other time-based events. The `Ticker` dispatches \"tick\" events, which are crucial for updating the display and performing animations in EaselJS and other CreateJS libraries.  It's designed to be highly efficient and cross-browser compatible, handling inconsistencies in browser timing mechanisms.\n\nThe `Ticker` can be used in different modes:\n\n* **`Ticker.framerate = 60;`:** Sets a target frames-per-second (fps) rate. The `Ticker` will attempt to maintain this rate, but performance limitations may cause the actual frame rate to vary.\n\n* **Time-based updates:**  The `Ticker`'s `time` property provides the elapsed time in milliseconds since the last tick, allowing for time-based animations and physics calculations.  This approach is generally preferred for smoother and more consistent results.\n\n* **Event listeners:**  You add listeners to the `Ticker` to execute code on each tick.  The `tick` event provides an object with details such as the current time and delta time.\n\nExample using the `Ticker` for animation:\n\n```javascript\ncreatejs.Ticker.addEventListener(\"tick\", handleTick);\n\nfunction handleTick(event) {\n  // Update game state based on the time elapsed since the last tick (event.delta)\n  myObject.x += 5; // Example: move an object 5 pixels\n  stage.update(event); // Update the display\n}\n```\n\nThe `stage.update(event)` call is crucial to refresh the canvas display after each update.\n\n\n### EventDispatcher\n\nThe `createjs.EventDispatcher` class is a fundamental utility for managing events throughout CreateJS.  Many CreateJS objects (including the `Stage`, `DisplayObject`, `LoadQueue`, and `SoundInstance` classes) inherit from `EventDispatcher`, providing a consistent event handling mechanism. This promotes modularity and provides a clean pattern for managing interactions.\n\nKey functionalities include:\n\n* **`addEventListener(type, listener, [scope], [once])`:** Attaches an event listener to the dispatcher.  `type` specifies the event type (e.g., \"tick\", \"complete\", \"click\"); `listener` is the function to execute; `scope` (optional) specifies the `this` context for the listener; `once` (optional, boolean) removes the listener after it's executed once.\n\n* **`removeEventListener(type, listener, [scope])`:** Removes an event listener.\n\n* **`dispatchEvent(event)`:** Dispatches an event.   This is frequently used internally by CreateJS objects but can also be utilized to create custom events.\n\n* **`hasEventListener(type)`:** Checks if there are any listeners for a specific event type.\n\nExample using `EventDispatcher`:\n\n```javascript\nlet myObject = new createjs.EventDispatcher();\n\nmyObject.addEventListener(\"myCustomEvent\", handleMyEvent);\n\nfunction handleMyEvent(event) {\n  console.log(\"My custom event triggered!\", event);\n}\n\nmyObject.dispatchEvent({type: \"myCustomEvent\", data: \"some data\"});\n```\n\nThis example shows creating a custom event and attaching a listener to handle it.  The `EventDispatcher` provides a structured and powerful way to manage events within and between different CreateJS components.  Understanding its use is crucial for building more complex and interactive applications.\n\n\n## Advanced Topics\n\n### Performance Optimization\n\nOptimizing performance is crucial for creating smooth and responsive CreateJS applications, especially when dealing with complex scenes or animations.  Key strategies include:\n\n* **Minimize Display Objects:**  Reduce the number of objects on the stage. Group similar objects into containers to decrease the number of individual objects that need to be rendered.\n\n* **Caching:** Use `cache()` on display objects to improve rendering speed.  Caching creates a bitmap representation of the object, improving drawing performance.  However, be mindful that frequently updating cached objects can negate the performance benefits.\n\n* **Update Only When Necessary:** Avoid unnecessary updates to the stage using `stage.update()`.  Only update when the display needs to be refreshed.  This is particularly important for animations, where frequent updates can impact performance.\n\n* **Efficient Animation Techniques:** Use TweenJS for smooth animations and avoid excessive calculations within the `tick` handler.  Consider using techniques like object pooling to reuse objects instead of constantly creating and destroying them.\n\n* **Reduce Rich Text Use:** Rich text can impact performance; consider using plain text whenever possible for large amounts of text.\n\n* **Image Optimization:** Optimize images for web use (e.g., using appropriate formats and compression).  Preload images using PreloadJS to prevent visual hiccups.\n\n* **Profiling:** Use browser developer tools to profile your application and identify performance bottlenecks.  This allows you to focus your optimization efforts on the most impactful areas.\n\n\n### Debugging and Troubleshooting\n\nDebugging CreateJS applications often involves standard JavaScript debugging techniques, but specific CreateJS considerations include:\n\n* **Browser Developer Tools:** Use your browser's developer tools (Console, Network, and Profiler) to inspect the application's behavior, identify errors, and profile performance.\n\n* **Logging:** Use `console.log()` strategically to track variable values and the execution flow of your code.\n\n* **Inspecting the Stage:** Use the browser's developer tools to inspect the stage and its children to understand the structure of your display list. This can help identify unexpected object positions or hierarchies.\n\n* **Error Handling:**  Implement proper error handling in your code to catch and address potential issues during asset loading, animation, or event handling.\n\n\n### Integrating with Other Libraries\n\nCreateJS is designed to work well with other JavaScript libraries.  Common integration points include:\n\n* **Game Engines:** Integrate CreateJS with game engines like Phaser or PixiJS for enhanced functionality.\n\n* **Physics Engines:** Use physics engines like Matter.js or Box2D for realistic physics simulations in your applications.\n\n* **UI Libraries:** Integrate UI libraries for building richer user interfaces.\n\nRemember to consider potential conflicts between libraries and ensure proper initialization and compatibility.\n\n\n### Creating Interactive Applications\n\nCreateJS provides a strong foundation for building interactive applications.  Effective strategies include:\n\n* **Event Handling:**  Utilize the `EventDispatcher` effectively to manage user interactions (mouse clicks, keyboard presses, touch events).\n\n* **State Management:**  Implement a clear state management system to track the application's status and respond to user input accordingly.  Consider using state machines or similar design patterns.\n\n* **User Interface (UI) Design:**  Design a well-structured and intuitive user interface for improved usability.\n\n* **Game Loop/Animation Loop:**  Use the `Ticker` to manage the application's main loop, updating game state and rendering the display.\n\n\n### Working with External Data Sources\n\nFetching and using external data (from JSON APIs, databases, etc.) involves:\n\n* **Data Fetching:** Use `fetch`, XMLHttpRequest, or libraries like jQuery or Axios to retrieve data from external sources.\n\n* **Data Parsing:** Parse the received data (often JSON) into usable formats using JavaScript's `JSON.parse()`.\n\n* **Data Integration:** Integrate the parsed data into your CreateJS application, updating objects, animations, or other components.\n\n\n### Accessibility Considerations\n\nAccessibility is crucial for inclusive application design.  Consider these points:\n\n* **Keyboard Navigation:** Ensure that users can navigate and interact with the application using only the keyboard.\n\n* **Screen Readers:** Use semantic HTML and ARIA attributes to provide screen reader support.\n\n* **Alternative Text:**  Provide alternative text (`alt` attributes) for images to describe their content for users who cannot see them.\n\n* **Color Contrast:**  Maintain sufficient color contrast between text and background colors for readability.\n\n\n### Best Practices\n\n* **Modular Design:**  Break down your code into smaller, reusable modules.\n\n* **Code Comments:**  Write clear and concise comments to explain your code's functionality.\n\n* **Version Control:**  Use a version control system (like Git) to manage your code changes.\n\n* **Testing:**  Write unit tests to verify the functionality of individual components.\n\n* **Consistent Code Style:**  Follow a consistent code style to improve readability and maintainability.\n\n* **Performance Monitoring:** Regularly monitor the performance of your application and optimize as needed.  Keep abreast of performance optimization techniques relevant to CreateJS and the technologies you integrate it with.\n\n\n\n\n## Examples and Tutorials\n\nThis section provides a starting point for exploring the capabilities of CreateJS through various examples and tutorials.  More extensive examples and tutorials can be found on the official CreateJS website and community resources.\n\n### Simple Animations\n\nSimple animations are a great way to start learning CreateJS.  These examples focus on basic animation principles using EaselJS and TweenJS.  They often involve animating the position, scale, rotation, or alpha (opacity) of simple shapes or bitmaps.\n\n**Example:** A bouncing ball animation can be created by using TweenJS to repeatedly change the ball's vertical position, applying an easing function to simulate the bounce.  This would involve setting up a `Ticker` event listener to update the ball's position in each tick and using `createjs.Tween.get()` to control the animation's timing and easing.\n\n\n### Interactive Games\n\nInteractive games showcase the capabilities of CreateJS for creating engaging user experiences.  These examples usually demonstrate the use of event handling, collision detection, and game logic.\n\n**Example:** A simple \"Breakout\" clone could be developed using EaselJS to render the bricks, paddle, and ball.  TweenJS would handle the ball's movement, and event listeners would respond to mouse or touch input for paddle control.  Collision detection would be implemented to handle ball-brick and ball-paddle interactions, managing score and game state.\n\n\n### Complex Visualizations\n\nComplex visualizations demonstrate how CreateJS can handle large datasets and sophisticated graphics.  These examples highlight the importance of performance optimization techniques.\n\n**Example:** A data visualization displaying stock prices over time could use EaselJS to create a line graph.  The graph would dynamically update based on data fetched from an external source.  Efficient techniques would be employed to handle large datasets smoothly.  This might involve techniques like data chunking or using containers to manage the visual elements efficiently.  Consider the use of efficient data structures and algorithms to optimize the update process.\n\n\n### Case Studies\n\nCase studies offer in-depth looks at real-world applications built with CreateJS.  These provide insight into architectural decisions, problem-solving approaches, and best practices.\n\n**Example:** A case study could analyze the implementation of a web-based interactive map using CreateJS.  The study would discuss how assets were managed (e.g., using PreloadJS), how map interactions were handled, and strategies employed for optimizing performance when displaying large maps. It might highlight challenges encountered and the solutions implemented. It could also include performance benchmarks and user feedback.\n\n\nThese examples and tutorials are intended as starting points.  Experimenting with different techniques and expanding on these basic concepts will help you master CreateJS and build sophisticated applications.  Remember to refer to the official CreateJS documentation and community resources for more detailed information and inspiration.\n\n\n## Appendix\n\n### Glossary of Terms\n\nThis glossary defines key terms used throughout the CreateJS documentation.\n\n* **Bitmap:** A visual representation of an image file (e.g., PNG, JPG) displayed on the canvas.\n* **Container:** An invisible display object that acts as a holder for other display objects, allowing for grouping and hierarchical organization.\n* **Display List:** The hierarchical structure of display objects within the `Stage`.  Efficient organization of the display list is crucial for performance.\n* **Display Object:**  Any visual element (shape, bitmap, text, container) that can be added to the stage and manipulated.\n* **Easing Function:** A function that controls the speed and timing of an animation, creating different animation curves.\n* **Event Dispatcher:** A class that manages the dispatching and handling of events.\n* **Frame Rate:** The number of frames rendered per second in an animation.\n* **Manifest:** A file (often JSON) that lists assets to be loaded using PreloadJS.\n* **Stage:** The root of the display list; represents the canvas element where everything is drawn.\n* **Tick:** A single frame in the animation loop; the `Ticker` dispatches `tick` events.\n* **Tween:** An animation that smoothly transitions the properties of an object over time, usually managed using TweenJS.\n\n\n### API Reference\n\nA comprehensive API reference provides detailed information about all classes, methods, and properties within the CreateJS libraries.  This reference typically includes:\n\n* **Class descriptions:**  Detailed explanations of each class's purpose and functionality.\n* **Method descriptions:**  Descriptions of each method's parameters, return values, and usage examples.\n* **Property descriptions:** Descriptions of each property's data type, purpose, and usage.\n* **Inheritance diagrams:** Visual representations of the class hierarchy.\n* **Code examples:**  Illustrative code snippets demonstrating the use of each class and method.\n\nThe location of the complete API reference will vary depending on the version of CreateJS and the preferred method of access (e.g., online documentation, locally downloaded files).\n\n\n### Troubleshooting Common Issues\n\nThis section addresses frequently encountered problems and provides solutions. Common issues may include:\n\n* **Canvas not rendering:** Check that your canvas element is correctly added to the HTML and that you are referencing it properly in your JavaScript code.  Ensure that your script is loading correctly and that there are no JavaScript errors preventing execution.\n\n* **Assets not loading:**  Verify that the asset paths specified in your manifest or `loadManifest()` calls are correct and that the assets exist at the specified locations. Use the browser's developer tools to inspect network requests and check for any errors.\n\n* **Animations not working:**  Ensure that the `Ticker` is properly configured and that the `stage.update()` method is called in each `tick` event handler. Double-check that your tween configurations are correct and that the target objects are added to the stage.\n\n* **Event listeners not firing:** Ensure event listeners are added correctly using `addEventListener()`, with the proper event type and callback function.  Check the event bubbling and capturing phases to make sure the event is reaching your listener.\n\n* **Performance problems:**  Optimize your code using techniques discussed in the \"Performance Optimization\" section.  Use the browser's developer tools to profile your application to pinpoint performance bottlenecks.\n\n\n### Community Resources and Support\n\nThe CreateJS community offers various resources for support and collaboration:\n\n* **Official CreateJS Website:** The official website provides up-to-date documentation, examples, and release notes.\n\n* **Online Forums and Communities:** Search for CreateJS forums and online communities where developers discuss issues, share solutions, and assist each other.\n\n* **GitHub Repository:** The CreateJS GitHub repository contains the source code and issue tracker.  You can report bugs, suggest features, and contribute to the project's development.\n\n* **Stack Overflow:** Search Stack Overflow for answers to frequently asked questions.  When asking for help, provide detailed information about your issue, including relevant code snippets.\n\nEngaging with the community is a valuable way to resolve issues, learn best practices, and stay informed about updates and developments in CreateJS.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["../../styles.css"],"html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"},"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"},"../../footer.html"],"output-file":"createjs.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"license":"MIT","author-meta":"Muthukrishnan","title":"CreateJS - Documentation","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}