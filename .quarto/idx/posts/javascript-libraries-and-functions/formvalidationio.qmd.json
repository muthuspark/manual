{"title":"Formvalidation.io - Documentation","markdown":{"yaml":{"title":"Formvalidation.io - Documentation","categories":["JavaScript Libraries and Functions"]},"headingText":"Getting Started","containsRefs":false,"markdown":"\n\n### Installation\n\nFormValidation.io can be installed via several methods.  The recommended approach is using npm or yarn for seamless integration with modern JavaScript workflows:\n\n```bash\nnpm install formvalidation\n# or\nyarn add formvalidation\n```\n\nAlternatively, you can download the library directly from the [FormValidation.io website](https://formvalidation.io/) and include it in your project using a `<script>` tag.  Remember to include the CSS file as well for styling:\n\n```html\n<link rel=\"stylesheet\" href=\"path/to/formvalidation.min.css\"/>\n<script src=\"path/to/formvalidation.min.js\"></script>\n```\n\nReplace `\"path/to/...\"` with the actual path to the downloaded files.  Ensure the script tag is placed before the closing `</body>` tag of your HTML document.  Using a CDN is also possible but less recommended for maintaining control over updates and potential caching issues.\n\n\n### Basic Usage\n\nFormValidation.io is designed to be intuitive.  After installation, initialize the library on your form element. This involves creating a `FormValidation` instance, providing it with the form's selector, and optionally, specifying configuration options (covered in the next section).  The core process consists of these steps:\n\n1. **Select the form:**  Identify your form using a CSS selector (e.g., `#myForm`, `.myForm`).\n\n2. **Create a FormValidation instance:** Use the constructor to create an instance, passing the form selector and configuration options as arguments.\n\n3. **Define Fields:**  Specify the validation rules for each field within the configuration.\n\n4. **Register Fields:**  FormValidation automatically registers fields within the form; you usually don't need to manually add them.\n\n5. **Submit the form:** When the form is submitted, FormValidation validates the fields and prevents submission if any validation fails.\n\n### First Example\n\nLet's create a simple form with a required field:\n\n```html\n<form id=\"myForm\">\n  <div class=\"mb-3\">\n    <label for=\"name\">Name:</label>\n    <input type=\"text\" class=\"form-control\" id=\"name\" name=\"name\" />\n  </div>\n  <button type=\"submit\" class=\"btn btn-primary\">Submit</button>\n</form>\n\n<script>\n  document.addEventListener('DOMContentLoaded', function() {\n    FormValidation.formValidation(\n        document.getElementById('myForm'),\n        {\n          fields: {\n            name: {\n              validators: {\n                notEmpty: {\n                  message: 'The name is required'\n                }\n              }\n            }\n          }\n        }\n    );\n  });\n</script>\n```\n\nThis code snippet initializes FormValidation on the form with id \"myForm\".  The `fields.name` section defines the validation rules for the `name` field, requiring it to be not empty.  A message will be displayed if the field is left blank.  Remember to include the FormValidation library as shown in the \"Installation\" section.\n\n\n### Configuration Options\n\nThe FormValidation constructor accepts a configuration object as its second argument.  This object allows you to customize various aspects of the validation process.  Key configuration options include:\n\n* **`fields`:** (Required) An object defining validation rules for each field in the form.  The keys are field names (usually the input's `name` attribute), and the values are objects specifying validators.  Each validator is an object with a `validator` key (specifying the validator type like `notEmpty`, `email`, `regexp`, etc.) and a `message` key for the error message.\n\n* **`plugins`:** An array of plugin instances to enhance the library's functionality (e.g., adding a feedback icon).\n\n* **`locale`:**  Specifies the language for error messages (defaults to 'en').  You'll need to include the appropriate locale file if you choose a language other than English.\n\n* **`events`:** Allows for custom event handling (e.g., to react to validation success or failure).\n\n* **`submitButtons`:**  Specifies the buttons triggering form submission (useful for forms with multiple submit buttons).  Defaults to all buttons of type `submit`.\n\nA detailed explanation of all configuration options and available validators can be found in the [FormValidation.io documentation](https://formvalidation.io/guide/introduction/).\n\n\n## Core Concepts\n\n### Declarative Validation\n\nFormValidation.io employs a declarative approach to validation.  Instead of writing imperative validation code, you define validation rules directly within the configuration object. This makes the validation logic more readable and maintainable, especially for complex forms.  Rules are specified using a JSON-like structure, making it easy to manage and update validation requirements. The declarative style promotes separation of concerns, keeping validation logic distinct from the rest of the application's code. This enhances code organization and simplifies testing.\n\n\n### Validator Types\n\nFormValidation.io provides a rich set of built-in validator types to handle various validation scenarios.  These validators cover common checks like:\n\n* **`notEmpty`:** Checks if a field is not empty.\n* **`stringLength`:**  Verifies the length of a string value.\n* **`email`:** Validates an email address format.\n* **`url`:** Checks if a value is a valid URL.\n* **`regexp`:**  Uses a regular expression for custom validation patterns.\n* **`numeric`:**  Ensures the value is a number.\n* **`date`:** Validates date formats.\n* **`identical`:** Compares two fields for equality.\n* **`different`:**  Ensures two fields have different values.\n\n\nThese validators can be combined and customized to create complex validation rules.  See the complete list and details in the [FormValidation.io documentation](https://formvalidation.io/guide/validators/).  Custom validators can also be created to extend the library's capabilities.\n\n### Rules\n\nValidation rules are defined within the `fields` configuration option.  Each field has an associated object that specifies its validators.  A rule consists of a validator type and its options (e.g., `message`, `min`, `max`). Multiple validators can be applied to a single field.  For example:\n\n```javascript\nfields: {\n  password: {\n    validators: {\n      notEmpty: {\n        message: 'The password is required'\n      },\n      stringLength: {\n        min: 8,\n        max: 20,\n        message: 'The password must be between 8 and 20 characters long'\n      }\n    }\n  }\n}\n```\n\nThis defines two rules for the `password` field: one checking for emptiness and another verifying the password length.\n\n\n### Error Handling\n\nFormValidation.io handles errors gracefully. When validation fails, error messages are automatically displayed near the corresponding fields. The library provides flexibility in customizing the error message presentation. You can adjust the message placement, styling, and even create custom error message elements.  The default behavior is to display messages below the input fields, but this can be modified using CSS or plugins.  The `message` property within each validator defines the error message to be shown.\n\n### Event Handling\n\nFormValidation.io offers several events that allow you to react to different validation stages.  You can listen for events like:\n\n* `core.form.valid`: Triggered when the form is valid.\n* `core.field.invalid`: Fired when a field is invalid.\n* `core.field.valid`: Fired when a field is valid.\n* `core.form.submit`: Fired before the form is submitted.  This event can be used to prevent submission if validation fails.\n\nThese events are useful for providing feedback to the user, performing additional actions based on validation results, or integrating with other parts of your application.  Event handling is typically done using the `on` method of the FormValidation instance.\n\n\n### Asynchronous Validation\n\nFormValidation.io supports asynchronous validation. This is crucial when performing validation checks that require external requests (e.g., checking if a username already exists). Asynchronous validators are defined similarly to synchronous ones, but they return a Promise that resolves to either true (valid) or false (invalid). For example:\n\n```javascript\nfields: {\n  username: {\n    validators: {\n      async: {\n        message: 'This username is already taken',\n        check: function(value) {\n          return new Promise(function(resolve, reject) {\n            // Perform async check (e.g., AJAX request)\n            setTimeout(function() {\n              // Simulate an async check\n              resolve(value !== 'test');\n            }, 1000);\n          });\n        }\n      }\n    }\n  }\n}\n```\n\nThis example shows an asynchronous validator that checks if a username is already taken.  Remember to handle potential errors during the asynchronous operation within the `Promise`.\n\n\n## Built-in Validators\n\n### Required\n\nThe `notEmpty` validator checks if a field has a value.  It's the most basic validator and ensures that a field isn't left blank.\n\n```javascript\nvalidators: {\n  notEmpty: {\n    message: 'This field is required'\n  }\n}\n```\n\nThis will display \"This field is required\" if the field is empty.  Note that whitespace-only values are also considered empty.\n\n\n### Length\n\nThe `stringLength` validator verifies that the length of a string falls within a specified range.  It uses the `min` and `max` options to define the minimum and maximum allowed lengths.\n\n```javascript\nvalidators: {\n  stringLength: {\n    min: 5,\n    max: 25,\n    message: 'The string must be between 5 and 25 characters long'\n  }\n}\n```\n\nThis example ensures the string length is between 5 and 25 characters.  If either `min` or `max` is omitted, only one boundary is checked.\n\n\n### Min/Max\n\nThe `numeric` validator, when combined with `min` and `max` options, checks if a numeric value falls within a specified range.  It's important to note that this validator first checks if the input is a valid number.\n\n```javascript\nvalidators: {\n  numeric: {\n    min: 10,\n    max: 100,\n    message: 'The value must be between 10 and 100'\n  }\n}\n```\n\nThis ensures the numeric input is between 10 and 100 (inclusive).  Similar to `stringLength`, omitting `min` or `max` checks only one boundary.\n\n\n### Email\n\nThe `email` validator checks if a value is a valid email address using a regular expression.\n\n```javascript\nvalidators: {\n  email: {\n    message: 'Please enter a valid email address'\n  }\n}\n```\n\nThis will validate the format of the entered email, checking for the presence of \"@\" and a valid domain.\n\n\n### URL\n\nThe `url` validator verifies if a value is a valid URL.\n\n```javascript\nvalidators: {\n  url: {\n    message: 'Please enter a valid URL'\n  }\n}\n```\n\nThis checks for a valid URL structure, including protocol (http:// or https://), domain, and potentially a path.\n\n\n### Regex\n\nThe `regexp` validator uses a regular expression to perform custom validation checks.\n\n```javascript\nvalidators: {\n  regexp: {\n    regexp: /^[a-zA-Z]+$/,\n    message: 'The value can only contain letters'\n  }\n}\n```\n\nThis example allows only alphabetic characters using a regular expression. You can use any valid regular expression to define your custom validation pattern.\n\n\n### Numeric\n\nThe `numeric` validator ensures that a value is a number.\n\n```javascript\nvalidators: {\n  numeric: {\n    message: 'The value must be a number'\n  }\n}\n```\n\nThis will check if the input can be parsed as a valid number.\n\n\n### Date\n\nThe `date` validator checks if a value is a valid date.  You can specify a format using the `format` option (refer to the documentation for supported formats).\n\n```javascript\nvalidators: {\n  date: {\n    format: 'YYYY-MM-DD',\n    message: 'Please enter a valid date in YYYY-MM-DD format'\n  }\n}\n```\n\nThis example expects the date to be in 'YYYY-MM-DD' format.\n\n\n### Alpha\n\nThe `alpha` validator checks if a value contains only alphabetic characters.\n\n```javascript\nvalidators: {\n  alpha: {\n    message: 'The value can only contain letters'\n  }\n}\n```\n\nThis only allows letters (a-z, A-Z).\n\n\n### Alphanumeric\n\nThe `alphanumeric` validator checks if a value contains only alphanumeric characters (letters and numbers).\n\n```javascript\nvalidators: {\n  alphanumeric: {\n    message: 'The value can only contain letters and numbers'\n  }\n}\n```\n\nThis allows letters and numbers (a-z, A-Z, 0-9).\n\n\n### CreditCard\n\nThe `creditCard` validator checks if a value is a valid credit card number using the Luhn algorithm.\n\n```javascript\nvalidators: {\n  creditCard: {\n    message: 'Please enter a valid credit card number'\n  }\n}\n```\n\nThis performs a basic check for credit card number validity.\n\n\n### IBAN\n\nThe `iban` validator checks if a value is a valid IBAN (International Bank Account Number).\n\n```javascript\nvalidators: {\n  iban: {\n    message: 'Please enter a valid IBAN'\n  }\n}\n```\n\nThis validator verifies the structure and checksum of the provided IBAN.  Note that country-specific IBAN validation rules are applied.\n\nRemember to consult the [FormValidation.io documentation](https://formvalidation.io/guide/validators/) for detailed information on options and usage of each validator.\n\n\n## Custom Validators\n\n### Creating Custom Validators\n\nFormValidation.io allows you to create custom validators to extend its functionality beyond the built-in ones.  A custom validator is a function that receives the field's value as input and returns a promise resolving to `true` (valid) or `false` (invalid).  It should also provide an error message.  Here's the structure:\n\n```javascript\nfunction myCustomValidator(value) {\n  // Perform your custom validation logic here\n  const isValid =  value.length >= 10; // Example: Check if length is at least 10\n  return new Promise((resolve, reject) => {\n      resolve({ valid: isValid, message: isValid ? '' : 'Value must be at least 10 characters long' });\n  });\n}\n```\n\nThis example creates a validator that checks if the input string's length is at least 10 characters.  The function returns a promise that resolves to an object containing `valid` (a boolean indicating validity) and `message` (the error message if invalid).  For synchronous validation, you can return the object directly instead of a Promise.\n\n\n### Registering Custom Validators\n\nOnce you've created a custom validator, you need to register it with FormValidation.io before using it in your form's configuration.  This is done using the `registerValidator` method:\n\n```javascript\nFormValidation.registerValidator('myCustom', myCustomValidator);\n```\n\nThis registers the `myCustomValidator` function under the name `myCustom`.  You can now use this custom validator in your `fields` configuration:\n\n```javascript\nfields: {\n  myField: {\n    validators: {\n      myCustom: {\n        message: 'Custom validation failed'\n      }\n    }\n  }\n}\n```\n\nNow, FormValidation will apply your `myCustom` validator to the `myField`.  If the validation fails, the custom message (\"Custom validation failed\") will be displayed.\n\n\n### Extending Built-in Validators\n\nInstead of creating entirely new validators, you can sometimes extend existing ones by providing custom logic within the `check` method of the validator. This can avoid redundant code and keeps your codebase more organized.\n\nLet's say we want to extend the `stringLength` validator to allow only uppercase letters:\n\n```javascript\nFormValidation.extendValidator('stringLength', {\n  validate: function(value, validator) {\n    if (!/^[A-Z]+$/.test(value)) {\n      return {\n        valid: false,\n        message: validator.message + ' and must be uppercase'\n      }\n    }\n    return validator.validate(value, validator);\n  }\n});\n```\n\nThis code snippet extends the `stringLength` validator.  The custom `validate` function first checks if the value contains only uppercase letters. If not, it returns an appropriate error message. Otherwise, it falls back to the default `stringLength` validator's validation logic.  This approach maintains the original validator's core functionality while adding specific conditions. Remember to replace `validator.message` with a suitable error message construction.  You may need to adapt this based on the validator's structure and the version of FormValidation.io you're using.\n\n\n## Advanced Usage\n\n### Working with Forms\n\nFormValidation.io seamlessly integrates with various form types and structures. While the basic usage focuses on single forms, it effectively handles complex scenarios.  You can target forms with multiple submit buttons by specifying the `submitButtons` option in the configuration.  For forms with dynamic elements, ensure you trigger revalidation using the appropriate FormValidation methods (`revalidateField`, `revalidateForm`) after updating the DOM.  Handling nested forms might require creating separate FormValidation instances for each nested form.\n\n\n### Conditional Validation\n\nConditional validation allows you to dynamically adjust validation rules based on the values of other fields.  This is achieved by using JavaScript functions within the validator options. These functions receive the entire form's data as an argument and can return modified validator configurations.\n\n```javascript\nfields: {\n  fieldA: {\n    validators: {\n      notEmpty: {\n        message: 'Field A is required',\n        enabled: function(form) {\n          return form.fieldB === 'value1'; // Validate only if fieldB is 'value1'\n        }\n      }\n    }\n  }\n}\n```\n\nIn this example, the `notEmpty` validator for `fieldA` is only enabled if the value of `fieldB` is 'value1'.\n\n\n### Dynamic Validation\n\nDynamic validation refers to adjusting validation rules during runtime.  You can achieve this by programmatically modifying the FormValidation instance's configuration using methods like `updateField`, `removeField`, and `addField`.  This is particularly useful when dealing with forms that change structure or validation requirements based on user interaction. Remember to revalidate the affected fields or the entire form after making configuration changes.\n\n\n### Field Groups\n\nFor forms containing logically grouped fields (e.g., address fields), consider using field groups. This improves organization and allows for applying common validation rules to an entire group.  Field groups can be managed similarly to individual fields, applying validators to the entire group.  The exact implementation details may depend on your specific grouping strategy in your form.\n\n\n### Nested Objects\n\nWhen dealing with forms that represent complex nested data structures, represent these structures using nested objects in your validation configuration. This allows for structured validation, ensuring that validation is applied accurately to each nested property.  Be mindful of the naming convention used for the fields to match the nested object structure.\n\n\n### Localization\n\nFormValidation.io supports internationalization through locale files.  You can specify the desired locale in the configuration (`locale` option).  FormValidation.io includes several locales; additional locales may be found in community contributions.  If a specific locale file is not included, validation messages will default to English.\n\n\n### Accessibility\n\nEnsure your forms are accessible by following accessibility best practices.  This includes using appropriate ARIA attributes, providing clear and concise error messages, and ensuring sufficient color contrast.  Proper ARIA attributes ensure screen readers can interpret the form's structure and validation states accurately.\n\n\n### Integration with Frameworks (React, Vue, Angular)\n\nFormValidation.io can be easily integrated into popular JavaScript frameworks. While there aren't framework-specific packages, the library's core functionality remains consistent across different environments.  You'll typically manage the FormValidation instance within your component's lifecycle methods (e.g., `componentDidMount`, `mounted`, `ngOnInit`), ensuring proper initialization and cleanup.  The integration involves using FormValidation's API within the component's logic, binding the form's data to your framework's state management system and handling validation results within your component's rendering.  Refer to the FormValidation.io documentation for more detailed guidance on integrating with specific frameworks.\n\n\n## Troubleshooting\n\n### Common Errors\n\nSeveral common errors arise when using FormValidation.io.  Understanding these can significantly expedite problem resolution.\n\n* **`FormValidation is not defined`:** This error typically indicates that the FormValidation library hasn't been correctly included in your project. Ensure the script tag is included in your HTML file, and the path to the library is accurate.  Check your browser's developer console for any loading errors.\n\n* **Validation not working:**  Double-check your field names in the configuration (`fields` option) to ensure they exactly match the `name` attributes of your form inputs.  Confirm that you've correctly specified the validators and their options.  If using asynchronous validators, verify the promise resolution is handled correctly.  Review the browser's developer console for any JavaScript errors.\n\n* **Incorrect error messages:** Verify the `message` property within each validator is correctly set.  If using localization, ensure the correct locale file is included and the `locale` option is set appropriately.\n\n* **Unexpected behavior with dynamic forms:** When dynamically adding or removing form elements, ensure you use FormValidation.io's methods (`addField`, `removeField`, `revalidateField`, `revalidateForm`) to update the validation instance accordingly. Failure to do so may lead to incorrect validation or unexpected behavior.\n\n* **Conflicts with other libraries:**  In rare cases, conflicts with other JavaScript libraries might interfere with FormValidation.io's functionality. Try disabling other libraries temporarily to isolate the problem.  Consider the order in which scripts are loaded.\n\n\n### Debugging Tips\n\nEffective debugging is essential when resolving FormValidation.io issues.  Here are some helpful techniques:\n\n* **Use your browser's developer tools:** The browser's developer console provides valuable insights into JavaScript errors, network requests (for asynchronous validators), and the overall state of your application.\n\n* **Simplify your form:**  If you're encountering complex issues, create a minimal, reproducible example with only the problematic fields and validators.  This helps isolate the problem and reduces the complexity of debugging.\n\n* **Inspect the FormValidation instance:**  Use your browser's debugging tools to inspect the FormValidation instance. This allows you to examine the current configuration, validated fields, and any error messages.\n\n* **Check the FormValidation documentation and examples:** The official documentation contains detailed explanations and examples that can help you understand the library's functionality and troubleshoot common problems.\n\n\n### Troubleshooting Specific Issues\n\nWhile the above covers common scenarios, resolving specific issues may require additional investigation.  Here are some approaches:\n\n* **Asynchronous validator problems:** If an asynchronous validator is not working, use your browser's network tools to inspect the requests made to the server.  Check for errors in the server response or any network issues.\n\n* **Plugin-related issues:**  If a plugin is causing problems, temporarily disable it to see if that solves the issue.  Check the plugin's documentation for troubleshooting information.\n\n* **Version compatibility:** Ensure you are using a compatible version of FormValidation.io with your other libraries and dependencies.  Check the release notes and compatibility information on the FormValidation.io website.\n\n* **Community support:** The FormValidation.io community is a valuable resource for troubleshooting complex problems.  Consult forums or online communities for assistance.  Providing a clear description of your problem, including code snippets and error messages, helps others assist you efficiently.\n\nRemember to always consult the official FormValidation.io documentation for the most up-to-date information and troubleshooting guidance.\n\n\n## API Reference\n\nThis section provides a concise overview of the FormValidation.io API.  For complete and detailed information, refer to the comprehensive documentation available on the FormValidation.io website.\n\n\n### FormValidation Class\n\nThe `FormValidation` class is the core of the library. It's responsible for managing the validation process of a form.  Key methods include:\n\n* **`constructor(form, options)`:** Creates a new `FormValidation` instance.  `form` is a CSS selector or DOM element representing the form, and `options` is a configuration object.\n\n* **`on(event, handler)`:** Attaches an event handler to the instance.  Events include `core.form.valid`, `core.form.invalid`, `core.field.valid`, `core.field.invalid`, `core.form.submit`, etc.\n\n* **`off(event, handler)`:** Detaches an event handler.\n\n* **`validate()`:** Validates the entire form.\n\n* **`validateField(fieldName)`:** Validates a specific field.\n\n* **`revalidateField(fieldName)`:** Revalidates a specific field.\n\n* **`revalidateForm()`:** Revalidates the entire form.\n\n* **`destroy()`:** Destroys the instance and removes all event listeners.\n\n* **`getFields()`:** Returns an object containing all validated fields and their statuses.\n\n* **`getFieldElements(fieldName)`:** Returns a list of DOM elements associated with a field.\n\n* **`updateField(fieldName, options)`:** Updates the validation rules for a specific field.\n\n* **`addField(fieldName, options)`:** Adds a new field to be validated.\n\n* **`removeField(fieldName)`:** Removes a field from the validation process.\n\n* `getLocale()`: Returns the currently set locale.\n\n* `setLocale(locale)`: Sets the locale for error messages.\n\n\n### Validator Methods\n\nValidators are functions that perform specific validation checks.  While you primarily define validators in the configuration, understanding their underlying methods is beneficial.  Many validators (especially custom ones) will utilise the following pattern where `value` is the field's value and `validator` is the validator's configuration:\n\n* **`validate(value, validator)`:** This is the core function of a validator. It receives the field's value and the validator's configuration as arguments and returns an object with `valid` (boolean) and `message` (string) properties.  This method is commonly used within custom validators and extended validators.\n\n\n### Utility Methods\n\nFormValidation.io provides several utility methods for common tasks:\n\n* **`FormValidation.registerValidator(name, validator)`:** Registers a custom validator.  `name` is the validator's name, and `validator` is the validation function.\n\n* **`FormValidation.extendValidator(name, options)`:** Extends an existing validator with additional logic.  `name` specifies the validator to extend, and `options` contain the extension logic.\n\n* **`FormValidation.utils.isValidDate(dateString, format)`:** Checks if a date string is valid given a specific format.\n\n* **`FormValidation.utils.format(value, format)`:** Formats a value according to a specific format (for date, number, etc.).\n\n* **`FormValidation.utils.getElement(selector)`:** Gets the DOM element matching the given selector.\n\n\nThis is a condensed overview.  The complete API documentation provides detailed explanations, examples, and parameter descriptions for each method and property.  Always refer to the official documentation for the most accurate and up-to-date information.\n\n","srcMarkdownNoYaml":"\n## Getting Started\n\n### Installation\n\nFormValidation.io can be installed via several methods.  The recommended approach is using npm or yarn for seamless integration with modern JavaScript workflows:\n\n```bash\nnpm install formvalidation\n# or\nyarn add formvalidation\n```\n\nAlternatively, you can download the library directly from the [FormValidation.io website](https://formvalidation.io/) and include it in your project using a `<script>` tag.  Remember to include the CSS file as well for styling:\n\n```html\n<link rel=\"stylesheet\" href=\"path/to/formvalidation.min.css\"/>\n<script src=\"path/to/formvalidation.min.js\"></script>\n```\n\nReplace `\"path/to/...\"` with the actual path to the downloaded files.  Ensure the script tag is placed before the closing `</body>` tag of your HTML document.  Using a CDN is also possible but less recommended for maintaining control over updates and potential caching issues.\n\n\n### Basic Usage\n\nFormValidation.io is designed to be intuitive.  After installation, initialize the library on your form element. This involves creating a `FormValidation` instance, providing it with the form's selector, and optionally, specifying configuration options (covered in the next section).  The core process consists of these steps:\n\n1. **Select the form:**  Identify your form using a CSS selector (e.g., `#myForm`, `.myForm`).\n\n2. **Create a FormValidation instance:** Use the constructor to create an instance, passing the form selector and configuration options as arguments.\n\n3. **Define Fields:**  Specify the validation rules for each field within the configuration.\n\n4. **Register Fields:**  FormValidation automatically registers fields within the form; you usually don't need to manually add them.\n\n5. **Submit the form:** When the form is submitted, FormValidation validates the fields and prevents submission if any validation fails.\n\n### First Example\n\nLet's create a simple form with a required field:\n\n```html\n<form id=\"myForm\">\n  <div class=\"mb-3\">\n    <label for=\"name\">Name:</label>\n    <input type=\"text\" class=\"form-control\" id=\"name\" name=\"name\" />\n  </div>\n  <button type=\"submit\" class=\"btn btn-primary\">Submit</button>\n</form>\n\n<script>\n  document.addEventListener('DOMContentLoaded', function() {\n    FormValidation.formValidation(\n        document.getElementById('myForm'),\n        {\n          fields: {\n            name: {\n              validators: {\n                notEmpty: {\n                  message: 'The name is required'\n                }\n              }\n            }\n          }\n        }\n    );\n  });\n</script>\n```\n\nThis code snippet initializes FormValidation on the form with id \"myForm\".  The `fields.name` section defines the validation rules for the `name` field, requiring it to be not empty.  A message will be displayed if the field is left blank.  Remember to include the FormValidation library as shown in the \"Installation\" section.\n\n\n### Configuration Options\n\nThe FormValidation constructor accepts a configuration object as its second argument.  This object allows you to customize various aspects of the validation process.  Key configuration options include:\n\n* **`fields`:** (Required) An object defining validation rules for each field in the form.  The keys are field names (usually the input's `name` attribute), and the values are objects specifying validators.  Each validator is an object with a `validator` key (specifying the validator type like `notEmpty`, `email`, `regexp`, etc.) and a `message` key for the error message.\n\n* **`plugins`:** An array of plugin instances to enhance the library's functionality (e.g., adding a feedback icon).\n\n* **`locale`:**  Specifies the language for error messages (defaults to 'en').  You'll need to include the appropriate locale file if you choose a language other than English.\n\n* **`events`:** Allows for custom event handling (e.g., to react to validation success or failure).\n\n* **`submitButtons`:**  Specifies the buttons triggering form submission (useful for forms with multiple submit buttons).  Defaults to all buttons of type `submit`.\n\nA detailed explanation of all configuration options and available validators can be found in the [FormValidation.io documentation](https://formvalidation.io/guide/introduction/).\n\n\n## Core Concepts\n\n### Declarative Validation\n\nFormValidation.io employs a declarative approach to validation.  Instead of writing imperative validation code, you define validation rules directly within the configuration object. This makes the validation logic more readable and maintainable, especially for complex forms.  Rules are specified using a JSON-like structure, making it easy to manage and update validation requirements. The declarative style promotes separation of concerns, keeping validation logic distinct from the rest of the application's code. This enhances code organization and simplifies testing.\n\n\n### Validator Types\n\nFormValidation.io provides a rich set of built-in validator types to handle various validation scenarios.  These validators cover common checks like:\n\n* **`notEmpty`:** Checks if a field is not empty.\n* **`stringLength`:**  Verifies the length of a string value.\n* **`email`:** Validates an email address format.\n* **`url`:** Checks if a value is a valid URL.\n* **`regexp`:**  Uses a regular expression for custom validation patterns.\n* **`numeric`:**  Ensures the value is a number.\n* **`date`:** Validates date formats.\n* **`identical`:** Compares two fields for equality.\n* **`different`:**  Ensures two fields have different values.\n\n\nThese validators can be combined and customized to create complex validation rules.  See the complete list and details in the [FormValidation.io documentation](https://formvalidation.io/guide/validators/).  Custom validators can also be created to extend the library's capabilities.\n\n### Rules\n\nValidation rules are defined within the `fields` configuration option.  Each field has an associated object that specifies its validators.  A rule consists of a validator type and its options (e.g., `message`, `min`, `max`). Multiple validators can be applied to a single field.  For example:\n\n```javascript\nfields: {\n  password: {\n    validators: {\n      notEmpty: {\n        message: 'The password is required'\n      },\n      stringLength: {\n        min: 8,\n        max: 20,\n        message: 'The password must be between 8 and 20 characters long'\n      }\n    }\n  }\n}\n```\n\nThis defines two rules for the `password` field: one checking for emptiness and another verifying the password length.\n\n\n### Error Handling\n\nFormValidation.io handles errors gracefully. When validation fails, error messages are automatically displayed near the corresponding fields. The library provides flexibility in customizing the error message presentation. You can adjust the message placement, styling, and even create custom error message elements.  The default behavior is to display messages below the input fields, but this can be modified using CSS or plugins.  The `message` property within each validator defines the error message to be shown.\n\n### Event Handling\n\nFormValidation.io offers several events that allow you to react to different validation stages.  You can listen for events like:\n\n* `core.form.valid`: Triggered when the form is valid.\n* `core.field.invalid`: Fired when a field is invalid.\n* `core.field.valid`: Fired when a field is valid.\n* `core.form.submit`: Fired before the form is submitted.  This event can be used to prevent submission if validation fails.\n\nThese events are useful for providing feedback to the user, performing additional actions based on validation results, or integrating with other parts of your application.  Event handling is typically done using the `on` method of the FormValidation instance.\n\n\n### Asynchronous Validation\n\nFormValidation.io supports asynchronous validation. This is crucial when performing validation checks that require external requests (e.g., checking if a username already exists). Asynchronous validators are defined similarly to synchronous ones, but they return a Promise that resolves to either true (valid) or false (invalid). For example:\n\n```javascript\nfields: {\n  username: {\n    validators: {\n      async: {\n        message: 'This username is already taken',\n        check: function(value) {\n          return new Promise(function(resolve, reject) {\n            // Perform async check (e.g., AJAX request)\n            setTimeout(function() {\n              // Simulate an async check\n              resolve(value !== 'test');\n            }, 1000);\n          });\n        }\n      }\n    }\n  }\n}\n```\n\nThis example shows an asynchronous validator that checks if a username is already taken.  Remember to handle potential errors during the asynchronous operation within the `Promise`.\n\n\n## Built-in Validators\n\n### Required\n\nThe `notEmpty` validator checks if a field has a value.  It's the most basic validator and ensures that a field isn't left blank.\n\n```javascript\nvalidators: {\n  notEmpty: {\n    message: 'This field is required'\n  }\n}\n```\n\nThis will display \"This field is required\" if the field is empty.  Note that whitespace-only values are also considered empty.\n\n\n### Length\n\nThe `stringLength` validator verifies that the length of a string falls within a specified range.  It uses the `min` and `max` options to define the minimum and maximum allowed lengths.\n\n```javascript\nvalidators: {\n  stringLength: {\n    min: 5,\n    max: 25,\n    message: 'The string must be between 5 and 25 characters long'\n  }\n}\n```\n\nThis example ensures the string length is between 5 and 25 characters.  If either `min` or `max` is omitted, only one boundary is checked.\n\n\n### Min/Max\n\nThe `numeric` validator, when combined with `min` and `max` options, checks if a numeric value falls within a specified range.  It's important to note that this validator first checks if the input is a valid number.\n\n```javascript\nvalidators: {\n  numeric: {\n    min: 10,\n    max: 100,\n    message: 'The value must be between 10 and 100'\n  }\n}\n```\n\nThis ensures the numeric input is between 10 and 100 (inclusive).  Similar to `stringLength`, omitting `min` or `max` checks only one boundary.\n\n\n### Email\n\nThe `email` validator checks if a value is a valid email address using a regular expression.\n\n```javascript\nvalidators: {\n  email: {\n    message: 'Please enter a valid email address'\n  }\n}\n```\n\nThis will validate the format of the entered email, checking for the presence of \"@\" and a valid domain.\n\n\n### URL\n\nThe `url` validator verifies if a value is a valid URL.\n\n```javascript\nvalidators: {\n  url: {\n    message: 'Please enter a valid URL'\n  }\n}\n```\n\nThis checks for a valid URL structure, including protocol (http:// or https://), domain, and potentially a path.\n\n\n### Regex\n\nThe `regexp` validator uses a regular expression to perform custom validation checks.\n\n```javascript\nvalidators: {\n  regexp: {\n    regexp: /^[a-zA-Z]+$/,\n    message: 'The value can only contain letters'\n  }\n}\n```\n\nThis example allows only alphabetic characters using a regular expression. You can use any valid regular expression to define your custom validation pattern.\n\n\n### Numeric\n\nThe `numeric` validator ensures that a value is a number.\n\n```javascript\nvalidators: {\n  numeric: {\n    message: 'The value must be a number'\n  }\n}\n```\n\nThis will check if the input can be parsed as a valid number.\n\n\n### Date\n\nThe `date` validator checks if a value is a valid date.  You can specify a format using the `format` option (refer to the documentation for supported formats).\n\n```javascript\nvalidators: {\n  date: {\n    format: 'YYYY-MM-DD',\n    message: 'Please enter a valid date in YYYY-MM-DD format'\n  }\n}\n```\n\nThis example expects the date to be in 'YYYY-MM-DD' format.\n\n\n### Alpha\n\nThe `alpha` validator checks if a value contains only alphabetic characters.\n\n```javascript\nvalidators: {\n  alpha: {\n    message: 'The value can only contain letters'\n  }\n}\n```\n\nThis only allows letters (a-z, A-Z).\n\n\n### Alphanumeric\n\nThe `alphanumeric` validator checks if a value contains only alphanumeric characters (letters and numbers).\n\n```javascript\nvalidators: {\n  alphanumeric: {\n    message: 'The value can only contain letters and numbers'\n  }\n}\n```\n\nThis allows letters and numbers (a-z, A-Z, 0-9).\n\n\n### CreditCard\n\nThe `creditCard` validator checks if a value is a valid credit card number using the Luhn algorithm.\n\n```javascript\nvalidators: {\n  creditCard: {\n    message: 'Please enter a valid credit card number'\n  }\n}\n```\n\nThis performs a basic check for credit card number validity.\n\n\n### IBAN\n\nThe `iban` validator checks if a value is a valid IBAN (International Bank Account Number).\n\n```javascript\nvalidators: {\n  iban: {\n    message: 'Please enter a valid IBAN'\n  }\n}\n```\n\nThis validator verifies the structure and checksum of the provided IBAN.  Note that country-specific IBAN validation rules are applied.\n\nRemember to consult the [FormValidation.io documentation](https://formvalidation.io/guide/validators/) for detailed information on options and usage of each validator.\n\n\n## Custom Validators\n\n### Creating Custom Validators\n\nFormValidation.io allows you to create custom validators to extend its functionality beyond the built-in ones.  A custom validator is a function that receives the field's value as input and returns a promise resolving to `true` (valid) or `false` (invalid).  It should also provide an error message.  Here's the structure:\n\n```javascript\nfunction myCustomValidator(value) {\n  // Perform your custom validation logic here\n  const isValid =  value.length >= 10; // Example: Check if length is at least 10\n  return new Promise((resolve, reject) => {\n      resolve({ valid: isValid, message: isValid ? '' : 'Value must be at least 10 characters long' });\n  });\n}\n```\n\nThis example creates a validator that checks if the input string's length is at least 10 characters.  The function returns a promise that resolves to an object containing `valid` (a boolean indicating validity) and `message` (the error message if invalid).  For synchronous validation, you can return the object directly instead of a Promise.\n\n\n### Registering Custom Validators\n\nOnce you've created a custom validator, you need to register it with FormValidation.io before using it in your form's configuration.  This is done using the `registerValidator` method:\n\n```javascript\nFormValidation.registerValidator('myCustom', myCustomValidator);\n```\n\nThis registers the `myCustomValidator` function under the name `myCustom`.  You can now use this custom validator in your `fields` configuration:\n\n```javascript\nfields: {\n  myField: {\n    validators: {\n      myCustom: {\n        message: 'Custom validation failed'\n      }\n    }\n  }\n}\n```\n\nNow, FormValidation will apply your `myCustom` validator to the `myField`.  If the validation fails, the custom message (\"Custom validation failed\") will be displayed.\n\n\n### Extending Built-in Validators\n\nInstead of creating entirely new validators, you can sometimes extend existing ones by providing custom logic within the `check` method of the validator. This can avoid redundant code and keeps your codebase more organized.\n\nLet's say we want to extend the `stringLength` validator to allow only uppercase letters:\n\n```javascript\nFormValidation.extendValidator('stringLength', {\n  validate: function(value, validator) {\n    if (!/^[A-Z]+$/.test(value)) {\n      return {\n        valid: false,\n        message: validator.message + ' and must be uppercase'\n      }\n    }\n    return validator.validate(value, validator);\n  }\n});\n```\n\nThis code snippet extends the `stringLength` validator.  The custom `validate` function first checks if the value contains only uppercase letters. If not, it returns an appropriate error message. Otherwise, it falls back to the default `stringLength` validator's validation logic.  This approach maintains the original validator's core functionality while adding specific conditions. Remember to replace `validator.message` with a suitable error message construction.  You may need to adapt this based on the validator's structure and the version of FormValidation.io you're using.\n\n\n## Advanced Usage\n\n### Working with Forms\n\nFormValidation.io seamlessly integrates with various form types and structures. While the basic usage focuses on single forms, it effectively handles complex scenarios.  You can target forms with multiple submit buttons by specifying the `submitButtons` option in the configuration.  For forms with dynamic elements, ensure you trigger revalidation using the appropriate FormValidation methods (`revalidateField`, `revalidateForm`) after updating the DOM.  Handling nested forms might require creating separate FormValidation instances for each nested form.\n\n\n### Conditional Validation\n\nConditional validation allows you to dynamically adjust validation rules based on the values of other fields.  This is achieved by using JavaScript functions within the validator options. These functions receive the entire form's data as an argument and can return modified validator configurations.\n\n```javascript\nfields: {\n  fieldA: {\n    validators: {\n      notEmpty: {\n        message: 'Field A is required',\n        enabled: function(form) {\n          return form.fieldB === 'value1'; // Validate only if fieldB is 'value1'\n        }\n      }\n    }\n  }\n}\n```\n\nIn this example, the `notEmpty` validator for `fieldA` is only enabled if the value of `fieldB` is 'value1'.\n\n\n### Dynamic Validation\n\nDynamic validation refers to adjusting validation rules during runtime.  You can achieve this by programmatically modifying the FormValidation instance's configuration using methods like `updateField`, `removeField`, and `addField`.  This is particularly useful when dealing with forms that change structure or validation requirements based on user interaction. Remember to revalidate the affected fields or the entire form after making configuration changes.\n\n\n### Field Groups\n\nFor forms containing logically grouped fields (e.g., address fields), consider using field groups. This improves organization and allows for applying common validation rules to an entire group.  Field groups can be managed similarly to individual fields, applying validators to the entire group.  The exact implementation details may depend on your specific grouping strategy in your form.\n\n\n### Nested Objects\n\nWhen dealing with forms that represent complex nested data structures, represent these structures using nested objects in your validation configuration. This allows for structured validation, ensuring that validation is applied accurately to each nested property.  Be mindful of the naming convention used for the fields to match the nested object structure.\n\n\n### Localization\n\nFormValidation.io supports internationalization through locale files.  You can specify the desired locale in the configuration (`locale` option).  FormValidation.io includes several locales; additional locales may be found in community contributions.  If a specific locale file is not included, validation messages will default to English.\n\n\n### Accessibility\n\nEnsure your forms are accessible by following accessibility best practices.  This includes using appropriate ARIA attributes, providing clear and concise error messages, and ensuring sufficient color contrast.  Proper ARIA attributes ensure screen readers can interpret the form's structure and validation states accurately.\n\n\n### Integration with Frameworks (React, Vue, Angular)\n\nFormValidation.io can be easily integrated into popular JavaScript frameworks. While there aren't framework-specific packages, the library's core functionality remains consistent across different environments.  You'll typically manage the FormValidation instance within your component's lifecycle methods (e.g., `componentDidMount`, `mounted`, `ngOnInit`), ensuring proper initialization and cleanup.  The integration involves using FormValidation's API within the component's logic, binding the form's data to your framework's state management system and handling validation results within your component's rendering.  Refer to the FormValidation.io documentation for more detailed guidance on integrating with specific frameworks.\n\n\n## Troubleshooting\n\n### Common Errors\n\nSeveral common errors arise when using FormValidation.io.  Understanding these can significantly expedite problem resolution.\n\n* **`FormValidation is not defined`:** This error typically indicates that the FormValidation library hasn't been correctly included in your project. Ensure the script tag is included in your HTML file, and the path to the library is accurate.  Check your browser's developer console for any loading errors.\n\n* **Validation not working:**  Double-check your field names in the configuration (`fields` option) to ensure they exactly match the `name` attributes of your form inputs.  Confirm that you've correctly specified the validators and their options.  If using asynchronous validators, verify the promise resolution is handled correctly.  Review the browser's developer console for any JavaScript errors.\n\n* **Incorrect error messages:** Verify the `message` property within each validator is correctly set.  If using localization, ensure the correct locale file is included and the `locale` option is set appropriately.\n\n* **Unexpected behavior with dynamic forms:** When dynamically adding or removing form elements, ensure you use FormValidation.io's methods (`addField`, `removeField`, `revalidateField`, `revalidateForm`) to update the validation instance accordingly. Failure to do so may lead to incorrect validation or unexpected behavior.\n\n* **Conflicts with other libraries:**  In rare cases, conflicts with other JavaScript libraries might interfere with FormValidation.io's functionality. Try disabling other libraries temporarily to isolate the problem.  Consider the order in which scripts are loaded.\n\n\n### Debugging Tips\n\nEffective debugging is essential when resolving FormValidation.io issues.  Here are some helpful techniques:\n\n* **Use your browser's developer tools:** The browser's developer console provides valuable insights into JavaScript errors, network requests (for asynchronous validators), and the overall state of your application.\n\n* **Simplify your form:**  If you're encountering complex issues, create a minimal, reproducible example with only the problematic fields and validators.  This helps isolate the problem and reduces the complexity of debugging.\n\n* **Inspect the FormValidation instance:**  Use your browser's debugging tools to inspect the FormValidation instance. This allows you to examine the current configuration, validated fields, and any error messages.\n\n* **Check the FormValidation documentation and examples:** The official documentation contains detailed explanations and examples that can help you understand the library's functionality and troubleshoot common problems.\n\n\n### Troubleshooting Specific Issues\n\nWhile the above covers common scenarios, resolving specific issues may require additional investigation.  Here are some approaches:\n\n* **Asynchronous validator problems:** If an asynchronous validator is not working, use your browser's network tools to inspect the requests made to the server.  Check for errors in the server response or any network issues.\n\n* **Plugin-related issues:**  If a plugin is causing problems, temporarily disable it to see if that solves the issue.  Check the plugin's documentation for troubleshooting information.\n\n* **Version compatibility:** Ensure you are using a compatible version of FormValidation.io with your other libraries and dependencies.  Check the release notes and compatibility information on the FormValidation.io website.\n\n* **Community support:** The FormValidation.io community is a valuable resource for troubleshooting complex problems.  Consult forums or online communities for assistance.  Providing a clear description of your problem, including code snippets and error messages, helps others assist you efficiently.\n\nRemember to always consult the official FormValidation.io documentation for the most up-to-date information and troubleshooting guidance.\n\n\n## API Reference\n\nThis section provides a concise overview of the FormValidation.io API.  For complete and detailed information, refer to the comprehensive documentation available on the FormValidation.io website.\n\n\n### FormValidation Class\n\nThe `FormValidation` class is the core of the library. It's responsible for managing the validation process of a form.  Key methods include:\n\n* **`constructor(form, options)`:** Creates a new `FormValidation` instance.  `form` is a CSS selector or DOM element representing the form, and `options` is a configuration object.\n\n* **`on(event, handler)`:** Attaches an event handler to the instance.  Events include `core.form.valid`, `core.form.invalid`, `core.field.valid`, `core.field.invalid`, `core.form.submit`, etc.\n\n* **`off(event, handler)`:** Detaches an event handler.\n\n* **`validate()`:** Validates the entire form.\n\n* **`validateField(fieldName)`:** Validates a specific field.\n\n* **`revalidateField(fieldName)`:** Revalidates a specific field.\n\n* **`revalidateForm()`:** Revalidates the entire form.\n\n* **`destroy()`:** Destroys the instance and removes all event listeners.\n\n* **`getFields()`:** Returns an object containing all validated fields and their statuses.\n\n* **`getFieldElements(fieldName)`:** Returns a list of DOM elements associated with a field.\n\n* **`updateField(fieldName, options)`:** Updates the validation rules for a specific field.\n\n* **`addField(fieldName, options)`:** Adds a new field to be validated.\n\n* **`removeField(fieldName)`:** Removes a field from the validation process.\n\n* `getLocale()`: Returns the currently set locale.\n\n* `setLocale(locale)`: Sets the locale for error messages.\n\n\n### Validator Methods\n\nValidators are functions that perform specific validation checks.  While you primarily define validators in the configuration, understanding their underlying methods is beneficial.  Many validators (especially custom ones) will utilise the following pattern where `value` is the field's value and `validator` is the validator's configuration:\n\n* **`validate(value, validator)`:** This is the core function of a validator. It receives the field's value and the validator's configuration as arguments and returns an object with `valid` (boolean) and `message` (string) properties.  This method is commonly used within custom validators and extended validators.\n\n\n### Utility Methods\n\nFormValidation.io provides several utility methods for common tasks:\n\n* **`FormValidation.registerValidator(name, validator)`:** Registers a custom validator.  `name` is the validator's name, and `validator` is the validation function.\n\n* **`FormValidation.extendValidator(name, options)`:** Extends an existing validator with additional logic.  `name` specifies the validator to extend, and `options` contain the extension logic.\n\n* **`FormValidation.utils.isValidDate(dateString, format)`:** Checks if a date string is valid given a specific format.\n\n* **`FormValidation.utils.format(value, format)`:** Formats a value according to a specific format (for date, number, etc.).\n\n* **`FormValidation.utils.getElement(selector)`:** Gets the DOM element matching the given selector.\n\n\nThis is a condensed overview.  The complete API documentation provides detailed explanations, examples, and parameter descriptions for each method and property.  Always refer to the official documentation for the most accurate and up-to-date information.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["../../styles.css"],"html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"},"include-in-header":["../../favicon.html","../../header.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"},"../../footer.html"],"output-file":"formvalidationio.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.39","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"license":"MIT","author-meta":"Muthukrishnan","title":"Formvalidation.io - Documentation","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}