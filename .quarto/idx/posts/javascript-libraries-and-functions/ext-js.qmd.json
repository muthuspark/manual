{"title":"Ext JS - Documentation","markdown":{"yaml":{"title":"Ext JS - Documentation","description":"Complete documentation and tutorial for Ext JS JavaScript library. Learn installation, usage examples, API reference, and best practices.","date":"2025-02-09","categories":["JavaScript Libraries and Functions"]},"headingText":"Getting Started","containsRefs":false,"markdown":"\n\n### Installation and Setup\n\nExt JS can be integrated into your project via several methods, offering flexibility depending on your workflow and project requirements.  The most common approaches include using a CDN, npm, or yarn.\n\n**Using a CDN:**  The quickest way to get started is by including the Ext JS library via a CDN link in your HTML file. This method is ideal for quick prototyping or small projects.  Refer to the Sencha website for the most up-to-date CDN links and instructions.  Be aware that using a CDN relies on an external resource, so network availability impacts your application's performance.\n\n**Using npm (or yarn):** For larger projects, using a package manager like npm (Node Package Manager) or yarn is strongly recommended. This ensures proper version control and dependency management. You'll need Node.js installed on your system. To install Ext JS, use the following command in your terminal:\n\n```bash\nnpm install sencha-extjs\n```\n\n(or `yarn add sencha-extjs` for yarn).  After installation, you'll need to configure your build process (e.g., using Webpack or a similar tool) to incorporate Ext JS into your application.  Refer to the Sencha documentation for detailed instructions on building and optimizing your Ext JS application using npm.\n\n\n### Creating Your First Ext JS Application\n\nThe simplest Ext JS application consists of a single `Ext.Application` instance and a minimal view. Let's create a basic \"Hello, World!\" application:\n\n```javascript\nExt.application({\n    name: 'MyApp',\n    launch: function() {\n        Ext.create('Ext.panel.Panel', {\n            renderTo: Ext.getBody(),\n            width: 300,\n            height: 200,\n            title: 'My First Ext JS App',\n            html: 'Hello, World!'\n        });\n    }\n});\n```\n\nThis code creates a simple panel displaying \"Hello, World!\".  `Ext.application` creates the application instance. The `launch` function is called when the application is ready.  `Ext.create` instantiates a panel, which is rendered to the document body (`Ext.getBody()`).  This code snippet requires the inclusion of the Ext JS library (either via CDN or via your chosen package manager).  Save this code as an HTML file (e.g., `index.html`), ensure the Ext JS library is properly included, and open the file in a web browser to see the result.\n\n\n### Understanding the MVC Architecture\n\nExt JS employs a Model-View-Controller (MVC) architecture to structure applications. This pattern promotes code organization, reusability, and maintainability.\n\n* **Model:** Represents the data of your application. Models handle data fetching, persistence, and validation.  They often interact with back-end services (e.g., REST APIs).\n\n* **View:**  The visual representation of the data. Views are responsible for rendering data and handling user interactions.  They don't contain business logic.\n\n* **Controller:** Acts as an intermediary between the Model and the View. Controllers handle user actions, update the Model, and refresh the View accordingly.\n\nExt JS provides classes and utilities to implement the MVC pattern effectively, facilitating the creation of well-structured and scalable applications.  Understanding this architecture is crucial for effectively using Ext JS.\n\n\n### Exploring the Ext JS Class System\n\nExt JS utilizes a powerful and flexible class system based on inheritance and prototypes.  This system is fundamental to extending existing components and creating custom ones.  Key concepts include:\n\n* **Ext.define():** Used to define new classes.  It allows specifying a class name, parent class (for inheritance), config options, and methods.\n\n* **Inheritance:** Ext JS supports single inheritance.  You can extend existing classes to create new ones with added functionality or modified behavior.\n\n* **Mixins:** Allows including functionality from multiple classes without using inheritance.  Useful for adding cross-cutting concerns.\n\n* **Statics:**  Properties and methods that belong to the class itself, not instances of the class.\n\nMastering the Ext JS class system is essential for developing complex and customized applications.  The documentation provides detailed examples and explanations of these concepts.  Experiment with creating simple custom classes to solidify your understanding.\n\n\n## Core Components\n\n### Panels and Containers\n\nPanels and containers are fundamental building blocks in Ext JS, providing the structure for your application's layout.  Panels are rectangular components that can contain other components.  Containers manage the layout and arrangement of child components within them.  Key container classes include:\n\n* **`Ext.panel.Panel`:** The basic panel, offering features like title bars, borders, and content areas.  Often used as a foundation for more complex components.\n\n* **`Ext.layout.container.Fit`:**  A layout that causes its single child component to fill the available space.  Simple and efficient for single-component containers.\n\n* **`Ext.layout.container.Border`:**  Divides the container into five regions (north, south, east, west, center).  Suitable for applications requiring structured layouts with docked components.\n\n* **`Ext.layout.container.Accordion`:** Arranges child panels vertically, allowing only one panel to be expanded at a time.\n\nUnderstanding the different container layouts and how to nest them is crucial for creating effective user interfaces.\n\n\n### Forms and Fields\n\nExt JS provides a comprehensive set of form components for creating data entry interfaces.  Forms are built using field components, each representing a single input element.  Key features include:\n\n* **`Ext.form.Panel`:** The container for form fields.  Manages field submission, validation, and data handling.\n\n* **Field Types:**  Ext JS offers a wide variety of field types, including text fields (`Ext.form.field.Text`), number fields (`Ext.form.field.Number`), date fields (`Ext.form.field.Date`), combo boxes (`Ext.form.field.ComboBox`), and more.  Each field type provides specific validation and input features.\n\n* **Validation:**  Ext JS provides built-in validation capabilities for form fields, ensuring data integrity.  You can define custom validation rules using regular expressions or custom functions.\n\n* **Data Binding:**  Forms can be easily bound to data models, simplifying data entry and retrieval.\n\n\n### Grids and Data Management\n\nGrids are essential for displaying tabular data.  Ext JS's grid component (`Ext.grid.Grid`) is highly flexible and powerful, offering features like sorting, filtering, paging, and editing.  Key aspects include:\n\n* **Data Sources:**  Grids can be populated using various data sources, including arrays, JSON data, and remote server calls.  The `Ext.data.Store` class manages data loading and manipulation.\n\n* **Columns:**  Columns define how data is displayed in the grid.  You can customize column headers, data rendering, and alignment.\n\n* **Features:**  Ext JS provides a rich set of grid features, including cell editing, row selection, grouping, and summary rows.\n\n* **Data Proxies:** Manage communication with the data source (e.g., using REST APIs).\n\n\n### Windows and Dialogs\n\nWindows and dialogs are used to display modal or modeless pop-up windows.  They're crucial for creating interactive user experiences.  Key components include:\n\n* **`Ext.window.Window`:** Represents a basic window.  Offers features like title bars, close buttons, resizing, and draggability.\n\n* **Modal vs. Modeless:**  Modal windows prevent interaction with the underlying application until closed, while modeless windows allow concurrent interaction.\n\n* **Dialog Creation:**  Ext JS provides helper methods for creating common dialog types, such as message boxes and confirmation dialogs.\n\n\n### Menus and Toolbars\n\nMenus and toolbars enhance user interaction by providing easy access to commands and options.\n\n* **`Ext.menu.Menu`:** Creates context menus and drop-down menus.  Can contain menu items, separators, and sub-menus.\n\n* **`Ext.toolbar.Toolbar`:**  Provides a container for buttons, menu items, and other toolbar components.  Typically located at the top or bottom of a window or panel.\n\n* **Customization:** Menus and toolbars can be highly customized to meet specific application requirements.\n\n\n### Buttons and Icons\n\nButtons are fundamental interactive components that trigger actions.  Ext JS provides various button types and options for customization.\n\n* **`Ext.button.Button`:**  The base class for buttons.  Allows setting text labels, icons, and handlers for click events.\n\n* **Icon Integration:**  Ext JS integrates seamlessly with icon libraries (e.g., Font Awesome) for visually appealing buttons.\n\n* **Button Handlers:**  Define functions to execute when a button is clicked, often triggering controller actions.\n\n\n## Data Handling\n\n### Data Models and Stores\n\nExt JS uses a robust data handling system centered around Models and Stores.  Models represent individual data records, while Stores manage collections of Models and provide interfaces for data manipulation and access.\n\n* **`Ext.data.Model`:** Defines the structure and properties of a single data record.  Models typically define fields (properties) and may include validation rules.\n\n* **`Ext.data.Store`:**  A collection of Models.  Provides methods for loading, sorting, filtering, and updating data. Stores interact with data sources (like servers) through Proxies.  Common store configurations include `autoLoad` (automatically loads data on creation) and `pageSize` (for pagination).\n\n* **Field Definitions:** When defining a Model, you specify the fields (properties) of each record using an array of objects.  Each object defines a name, type (e.g., string, number, date), and other options.\n\n\n### Working with AJAX and Proxies\n\nProxies act as intermediaries between Stores and data sources, typically handling asynchronous communication via AJAX.  They abstract the details of data fetching and saving.\n\n* **`Ext.data.proxy.Ajax`:** The most common proxy type, used for communicating with remote servers via AJAX requests.\n\n* **Configuring Proxies:**  Proxies require configuration to specify the URL for data retrieval (`api.read`), data creation (`api.create`), updating (`api.update`), and deleting (`api.destroy`).  The `reader` config option specifies how to parse the server's response.  Common readers include `Ext.data.reader.Json` and `Ext.data.reader.Xml`.\n\n* **API Calls:** The `api` config property of the proxy defines the URLs for different CRUD (Create, Read, Update, Delete) operations.  The proxy handles converting the Store's requests into AJAX calls and processing the server's responses.\n\n\n### Data Binding and Templating\n\nExt JS simplifies data binding, enabling components to automatically update when underlying data changes and vice-versa.  Templating allows for customized data rendering within components.\n\n* **Two-Way Data Binding:** Changes in the Model are reflected in the View, and vice-versa. This simplifies maintaining data consistency.\n\n* **`Ext.XTemplate`:** A powerful templating engine for creating dynamic HTML based on data.  Allows using placeholders (`{fieldName}`) within HTML templates to insert data from Models.\n\n* **Data Binding in Grids:** Grids automatically bind to Stores, displaying data from the Models.  Cell editors allow modifying the data directly within the grid, automatically updating the Models and Store.\n\n\n### Data Validation and Error Handling\n\nExt JS supports data validation at both the Model and form levels.  Error handling mechanisms provide ways to gracefully handle validation failures and data loading errors.\n\n* **Model Validation:**  Define validation rules within your `Ext.data.Model` definition.  Rules can check for required fields, data types, and custom constraints.\n\n* **Form Validation:**  Ext JS forms automatically validate fields based on their configurations and associated Model validation.  Error messages are displayed to the user.\n\n* **Error Handling in Proxies:**  Proxies can handle errors during AJAX calls.  You can define custom error handling functions to gracefully handle failures (e.g., displaying informative messages to the user).\n\n\n### Server-Side Data Integration\n\nExt JS integrates seamlessly with various server-side technologies.  The choice of technology depends on your project requirements.  Common approaches include:\n\n* **REST APIs:**  The most common approach, using HTTP methods (GET, POST, PUT, DELETE) to interact with server-side resources.\n\n* **JSON Data:**  JSON is the typical data format for communication between the client (Ext JS) and the server.\n\n* **Other Technologies:**  Ext JS can also integrate with other technologies like GraphQL, SOAP, or custom protocols, but REST APIs are widely preferred due to their simplicity and flexibility.  Proper server-side design is crucial for efficient data handling and a smooth user experience.  Consider techniques like pagination and efficient data filtering to improve performance when dealing with large datasets.\n\n\n## UI Components\n\n### Buttons\n\nButtons provide a fundamental way for users to interact with your application. Ext JS offers a flexible `Ext.button.Button` class with numerous configuration options.\n\n* **Text:** The button's displayed text.\n* **Icon:**  Specify an icon using a URL or icon class from an icon library (e.g., Font Awesome).\n* **Handlers:**  Functions to execute when the button is clicked.  These are typically defined using the `handler` config option.\n* **Disabled State:**  Buttons can be programmatically enabled or disabled using the `setDisabled()` method.\n* **Button Types:**  Ext JS provides various button types (e.g., split buttons, segmented buttons) through subclasses of `Ext.button.Button`.\n\n\n### Text Fields\n\nText fields (`Ext.form.field.Text`) allow users to input and edit text.\n\n* **Validation:**  You can specify validation rules (e.g., required, minimum length) to ensure data integrity.\n* **Input Masks:**  Apply masks to restrict the allowed characters.\n* **Placeholders:**  Provide hints to the user about the expected input.\n* **Event Handlers:**  Listen to events like `change` or `blur` to respond to user input.\n\n\n### Number Fields\n\nNumber fields (`Ext.form.field.Number`) are specifically designed for numerical input.\n\n* **Validation:**  Built-in validation for numeric values, including range checks and decimal precision.\n* **Step Values:**  Define the increment/decrement step for input.\n* **AllowDecimals:**  Specify whether decimal values are allowed.\n\n\n### Date Fields\n\nDate fields (`Ext.form.field.Date`) handle date input.\n\n* **Format:**  Customize the date format displayed to the user and used for internal representation.\n* **Picker:**  The date picker allows users to select dates visually.\n* **Validation:**  Validate date formats and ranges.\n\n\n### Checkboxes and Radio Buttons\n\nCheckboxes (`Ext.form.field.Checkbox`) and radio buttons (`Ext.form.field.Radio`) allow users to select one or multiple options.\n\n* **Value:**  The value submitted when checked.\n* **Grouping:**  Radio buttons are typically grouped to ensure only one can be selected at a time.\n* **Checked State:**  Programmatically control the checked state using the `setChecked()` method.\n\n\n### Combo Boxes and Dropdowns\n\nCombo boxes (`Ext.form.field.ComboBox`) and dropdowns provide a list of options for selection.\n\n* **Data:**  Provide data as an array of objects or use a store for dynamic data loading.\n* **Display Field:**  The field from the data source used to display items in the dropdown.\n* **Value Field:**  The field from the data source to store as the selected value.\n\n\n### List Views and Data Grids\n\nList views (`Ext.view.View`) display lists of items; data grids (`Ext.grid.Grid`) are specifically designed for tabular data.\n\n* **Stores:**  Both use stores to manage data.\n* **Templates:**  Customizable templates for rendering items (List view) or cells (Data Grid).\n* **Features:**  Data grids offer advanced features like sorting, filtering, paging, editing, and grouping.\n\n\n### Trees and Tree Grids\n\nTrees (`Ext.tree.Panel`) and tree grids (`Ext.tree.Panel` with grid features) display hierarchical data.\n\n* **Nodes:**  Represent items in the tree.\n* **Data Sources:**  Can be populated from arrays or stores.\n* **Expansion/Collapse:**  Allow users to expand and collapse branches of the tree.\n\n\n### Tabs\n\nTabs (`Ext.tab.Panel`) allow organizing content into multiple tabbed panels.\n\n* **Items:**  The tabs' content.\n* **Active Tab:**  Specify the initially active tab.\n* **Closable Tabs:**  Allow users to close individual tabs.\n\n\n### Accordions\n\nAccordions (`Ext.panel.Accordion`) display panels in an expandable/collapsible format.\n\n* **Items:**  The panels to be displayed.\n* **Multi-expand:** Allow multiple panels to be expanded at once.\n\n\n### Progress Bars and Load Masks\n\nProgress bars (`Ext.ProgressBar`) and load masks (`Ext.LoadMask`) indicate ongoing operations.\n\n* **Percentage:**  Progress bars display the percentage of completion.\n* **Message:**  Load masks display messages while loading.\n\n\n### Charts\n\nExt JS provides integration with various charting libraries to render various types of charts.\n\n\n### Custom Components\n\nExt JS's class system allows for creating custom components by extending existing ones or building them from scratch.\n\n\n### Component Layouts\n\nLayouts control how components are arranged within containers.  Ext JS offers various layouts:\n\n* **Fit:**  A single child component fills the available space.\n* **Border:**  Divides the container into five regions (north, south, east, west, center).\n* **Accordion:**  Organizes components vertically, allowing only one to be expanded at a time.\n* **HBox/VBox:**  Arranges components horizontally or vertically.\n* **Column:**  Arranges components into columns.\n\n\n\n\n## Advanced Topics\n\n### Extending Ext JS Classes\n\nExt JS's class system allows extending existing classes to add functionality or modify behavior. This is achieved using `Ext.define()` and specifying the parent class.\n\n```javascript\nExt.define('MyApp.MyCustomButton', {\n    extend: 'Ext.button.Button',\n    config: {\n        customProperty: 'defaultValue'\n    },\n    onClick: function() {\n        // Custom click handling logic\n        console.log('Custom button clicked!');\n        this.callParent(arguments); // Call the parent class's onClick method\n    }\n});\n```\n\nThis example extends `Ext.button.Button`, adding a custom property and overriding the `onClick` method.  `callParent` ensures that the original functionality is also executed.\n\n\n### Creating Custom Components\n\nBuilding entirely new components involves defining classes using `Ext.define()`, specifying the component's properties, methods, and render logic.  Consider using existing components as a starting point for inheritance.\n\n```javascript\nExt.define('MyApp.MyCustomComponent', {\n    extend: 'Ext.Component',\n    renderTpl: [\n        '<div class=\"my-custom-component\">',\n        '<tpl if=\"title\">',\n        '<h1>{title}</h1>',\n        '</tpl>',\n        '<p>{text}</p>',\n        '</div>'\n    ],\n    config: {\n        title: null,\n        text: null\n    },\n    applyText: function(text) {\n       return text || \"Default Text\";\n    }\n});\n```\n\nThis creates a simple component rendering a title and text.  `renderTpl` defines the HTML template, and `config` specifies configurable properties.\n\n\n### Working with Events and Listeners\n\nExt JS uses an event-driven architecture. Components emit events, and you can add listeners to respond to these events.\n\n```javascript\nconst myButton = Ext.create('Ext.button.Button', {\n    text: 'Click Me',\n    listeners: {\n        click: function() {\n            console.log('Button clicked!');\n        }\n    }\n});\n\n// Alternatively using on():\nmyButton.on('click', function() {\n    console.log('Button clicked using on()!');\n});\n```\n\nThese examples demonstrate attaching a click listener to a button.  `listeners` is a config option; `on()` adds listeners dynamically.\n\n\n### Internationalization and Localization\n\nExt JS supports internationalization (i18n) and localization (l10n) for creating multilingual applications.  This usually involves using JSON files for storing translated text and loading the appropriate translations based on the user's locale.\n\n* **Locale Configuration:** Configure Ext JS to load locale-specific resource files.\n* **Translation Files:** Create JSON files containing translations for different languages.\n* **Accessing Translations:** Use `Ext.String.format` to include translated strings in your UI.\n\n\n### Performance Optimization\n\nOptimizing Ext JS applications focuses on minimizing render time, efficient data handling, and avoiding unnecessary DOM manipulations.\n\n* **Lazy Loading:** Load components and data only when needed.\n* **Efficient Data Handling:** Use appropriate data stores and proxies for efficient data management.\n* **DOM Manipulation:** Minimize direct DOM manipulation. Use Ext JS's built-in methods for updating the UI.\n* **Batch Updates:**  Aggregate multiple updates to the DOM into single operations.\n* **Profiling:** Use browser developer tools to identify performance bottlenecks.\n\n\n### Debugging and Troubleshooting\n\nDebugging Ext JS applications involves using browser developer tools (e.g., Chrome DevTools) to inspect component state, network requests, and JavaScript errors.  Ext JS's logging mechanisms can be valuable for tracking application behavior.\n\n* **Browser DevTools:** Use the debugger to step through code, inspect variables, and examine network traffic.\n* **Ext JS Logging:**  Use `Ext.log.log()`, `Ext.log.info()`, `Ext.log.warn()`, and `Ext.log.error()` for debugging messages.  Configure the logging level to control verbosity.  (Consider using a logging framework for larger applications.)\n\n\n### Testing and Unit Testing\n\nThorough testing is essential for building robust applications.  Ext JS applications can be tested using various methods, including unit testing frameworks like Jasmine or Jest.\n\n* **Unit Testing:**  Test individual components and functions in isolation.\n* **Integration Testing:**  Test how different components interact.\n* **End-to-End Testing:**  Test the entire application workflow.  Use testing frameworks to automate tests.\n\n\n### Deployment and Distribution\n\nDeploying Ext JS applications involves building optimized code, serving the application, and managing dependencies.\n\n* **Build Process:**  Use build tools like Sencha Cmd or Webpack to optimize your application for production.  This typically involves minification, code obfuscation, and combining files.\n* **Server-Side Deployment:**  Deploy the built application to a web server.\n* **Dependency Management:**  Ensure all required libraries (including Ext JS) are included and properly versioned.  CDNs or local copies are common approaches.\n\n\n## Ext JS Modern Toolkit\n\n### Overview of Modern Toolkit\n\nThe Ext JS Modern toolkit is a framework for building modern, touch-friendly web applications. It leverages the power of HTML5, CSS3, and JavaScript to create responsive and performant user interfaces that work seamlessly across a wide range of devices, including desktops, tablets, and smartphones.  It uses a completely different rendering engine and component architecture compared to the Classic toolkit. The Modern toolkit is designed with mobile-first principles in mind and offers a sleek, modern look and feel out of the box.  It prioritizes touch interactions and adapts easily to various screen sizes.\n\n\n### Key Differences from Classic Toolkit\n\nThe Modern and Classic toolkits are distinct and not directly compatible.  Key differences include:\n\n* **Rendering Engine:** Modern uses a modern HTML5 rendering engine, while Classic uses a more traditional approach that relies heavily on DOM manipulation.  This results in significant performance and responsiveness advantages for Modern.\n\n* **Component Architecture:**  Modern has a completely redesigned component architecture, leading to different component APIs and behaviors compared to Classic.  While many components have similar names (e.g., `Ext.panel.Panel`), their implementation and configuration options can differ significantly.\n\n* **Look and Feel:** The Modern toolkit offers a modern, cleaner aesthetic, designed to be visually appealing on modern devices. Classic's look can appear somewhat dated in comparison.\n\n* **Touch Support:**  Modern is inherently touch-friendly, while Classic requires additional configuration or workarounds for optimal touch support.\n\n* **MVC vs. MVVM:** While both toolkits support MVC, Modern is often better suited for MVVM (Model-View-ViewModel) architectural patterns, enhancing data binding and maintainability.\n\nMigrating from Classic to Modern often requires substantial refactoring and rewriting of code, as they are fundamentally different frameworks.\n\n\n### Component-Specific Details\n\nMany components in the Modern toolkit mirror those in the Classic toolkit, but with different APIs and behaviors.  You will need to refer to the Modern toolkit documentation for detailed information about specific components.  Key considerations include:\n\n* **Configuration Options:**  Configuration options for equivalent components often differ significantly between the toolkits.\n* **Event Handling:**  Event names and listener handling might vary.\n* **Layout Managers:**  Layout management differs, and you should understand the Modern toolkit's layout system.  Common layouts include `fit`, `vbox`, `hbox`, and `center`.\n* **Styling:**  Styling techniques are also different. Modern uses CSS classes and theming mechanisms differently than Classic.\n\n\n### Modern Toolkit Examples\n\nA simple \"Hello, World!\" example using the Modern toolkit:\n\n```javascript\nExt.application({\n    name: 'MyApp',\n    launch: function() {\n        Ext.create('Ext.Container', {\n            fullscreen: true,\n            items: [{\n                xtype: 'panel',\n                html: 'Hello, World!'\n            }]\n        });\n    }\n});\n```\n\nThis code creates a simple panel displaying \"Hello, World!\" that fills the entire screen.  Note the use of `fullscreen: true` and `xtype` for component creation.  Explore the extensive examples provided in the official Sencha documentation to see how various Modern components are used to create more complex applications.  The documentation will also cover the various layout options available and how to integrate data handling with modern components like grids and lists.\n\n\n## Ext JS Classic Toolkit\n\n### Overview of Classic Toolkit\n\nThe Ext JS Classic toolkit is a mature and feature-rich framework for building web applications. While the Modern toolkit is now the recommended approach for new projects, Classic remains a powerful option for maintaining and extending existing applications.  It employs a different rendering mechanism than the Modern toolkit, relying heavily on DOM manipulation.  While still functional, it generally lags behind Modern in terms of performance, especially on mobile devices.  The Classic toolkit's architecture is largely based on the MVC (Model-View-Controller) pattern and offers a wide range of components and utilities for building complex web applications.  However, its design might appear less modern compared to the streamlined approach of the Modern toolkit.\n\n\n### Component-Specific Details\n\nMany components in the Classic toolkit have counterparts in the Modern toolkit, but their APIs and behaviors can differ significantly.  Detailed information about specific components is available in the Ext JS Classic toolkit documentation.  Key differences to note from the Modern toolkit include:\n\n* **Rendering:** The Classic toolkit uses a different rendering engine than the Modern toolkit. This often results in different performance characteristics and requires a different approach to styling and theming.\n\n* **Layout Managers:**  Classic employs a different set of layout managers, such as `border`, `fit`, `form`, `column`, and `accordion`.  Understanding how these layouts work is crucial for arranging components effectively.\n\n* **Event Handling:** The way events are handled might differ slightly from the Modern toolkit. While both use event listeners, the specifics of event names and listener registration can vary.\n\n* **Data Handling:** While both Classic and Modern use `Ext.data.Store` and `Ext.data.Model`, there may be subtle differences in configuration options and behavior.\n\n* **Styling:** Classic utilizes CSS classes and styling methods that are different from the Modern toolkit.\n\n\n### Classic Toolkit Examples\n\nA simple \"Hello, World!\" example using the Classic toolkit:\n\n```javascript\nExt.onReady(function() {\n    Ext.create('Ext.Panel', {\n        renderTo: Ext.getBody(),\n        width: 300,\n        height: 200,\n        title: 'My First Ext JS App',\n        html: 'Hello, World!'\n    });\n});\n```\n\nThis code creates a simple panel, renders it to the document body, and displays \"Hello, World!\".  `Ext.onReady` ensures the code runs after the DOM is fully loaded.  The `renderTo` config option specifies the target element.  Note that creating more complex applications will require a more robust architecture using Models, Views, and Controllers.  The Classic toolkit documentation provides extensive examples that showcase various components and their interactions, including forms, grids, and advanced layouts.  These examples should be consulted to learn more about the intricate details of building applications with the Classic toolkit.\n\n\n## API Reference\n\nThe Ext JS API is extensive and well-documented.  This section provides an overview of the key parts of the API reference.  For the most up-to-date and comprehensive information, always consult the official Sencha Ext JS API documentation.\n\n### Class Reference\n\nThe class reference provides detailed information on all the classes available in Ext JS.  For each class, the documentation typically includes:\n\n* **Class Name:** The fully qualified name of the class (e.g., `Ext.panel.Panel`).\n* **Inheritance Hierarchy:** The class's inheritance lineage, showing which classes it extends.\n* **Members:** A list of the class's properties, methods, and events.\n* **Description:** A detailed description of the class's purpose and functionality.\n* **Example Code:**  Code snippets demonstrating how to use the class.\n* **Config Options:**  A detailed description of the configurable options for the class (see Config Options Reference).\n\n\nYou can typically access the class reference through the official documentation website by searching for the class name or browsing the class hierarchy.\n\n\n### Method Reference\n\nThe method reference details the available methods for each class.  For each method, you'll typically find:\n\n* **Method Name:** The name of the method (e.g., `show()`, `hide()`, `addListener()`).\n* **Parameters:** A description of the method's parameters, including their data types and purpose.\n* **Return Value:**  Information about the value returned by the method.\n* **Description:** A detailed explanation of what the method does.\n* **Example Code:**  Illustrative code snippets.\n\n\nThe method reference is typically integrated into the class reference, listed under the \"Methods\" section for each class.\n\n\n### Config Options Reference\n\nConfig options allow you to customize the behavior and appearance of Ext JS components.  The config options reference provides detailed information on these options.  Each config option description typically includes:\n\n* **Option Name:** The name of the config option (e.g., `title`, `width`, `height`, `listeners`).\n* **Data Type:** The expected data type of the config option (e.g., string, number, boolean, object, array, function).\n* **Description:** A detailed explanation of what the option does.\n* **Default Value:** The default value if the option is not explicitly set.\n* **Example Code:**  Illustrative code showing how to use the config option.\n\n\nConfig options are usually documented within the class reference, often in a dedicated section or table.\n\n\n### Events Reference\n\nThe events reference lists the events fired by each class.  This is crucial for understanding how to respond to changes in component state or user interactions.  For each event, the documentation provides:\n\n* **Event Name:** The name of the event (e.g., `click`, `resize`, `afterrender`, `beforehide`).\n* **Description:**  A detailed explanation of when the event is fired.\n* **Parameters:**  Any parameters passed with the event.\n* **Example Code:**  Code snippets demonstrating how to add listeners for the event.\n\n\nSimilar to methods and config options, the events reference is typically found within the class reference, under a dedicated \"Events\" section.  Understanding the events fired by components allows you to build dynamic and responsive applications.  You can use the `addListener` method (or its shorthand `on`) to attach event handlers.\n\n","srcMarkdownNoYaml":"\n## Getting Started\n\n### Installation and Setup\n\nExt JS can be integrated into your project via several methods, offering flexibility depending on your workflow and project requirements.  The most common approaches include using a CDN, npm, or yarn.\n\n**Using a CDN:**  The quickest way to get started is by including the Ext JS library via a CDN link in your HTML file. This method is ideal for quick prototyping or small projects.  Refer to the Sencha website for the most up-to-date CDN links and instructions.  Be aware that using a CDN relies on an external resource, so network availability impacts your application's performance.\n\n**Using npm (or yarn):** For larger projects, using a package manager like npm (Node Package Manager) or yarn is strongly recommended. This ensures proper version control and dependency management. You'll need Node.js installed on your system. To install Ext JS, use the following command in your terminal:\n\n```bash\nnpm install sencha-extjs\n```\n\n(or `yarn add sencha-extjs` for yarn).  After installation, you'll need to configure your build process (e.g., using Webpack or a similar tool) to incorporate Ext JS into your application.  Refer to the Sencha documentation for detailed instructions on building and optimizing your Ext JS application using npm.\n\n\n### Creating Your First Ext JS Application\n\nThe simplest Ext JS application consists of a single `Ext.Application` instance and a minimal view. Let's create a basic \"Hello, World!\" application:\n\n```javascript\nExt.application({\n    name: 'MyApp',\n    launch: function() {\n        Ext.create('Ext.panel.Panel', {\n            renderTo: Ext.getBody(),\n            width: 300,\n            height: 200,\n            title: 'My First Ext JS App',\n            html: 'Hello, World!'\n        });\n    }\n});\n```\n\nThis code creates a simple panel displaying \"Hello, World!\".  `Ext.application` creates the application instance. The `launch` function is called when the application is ready.  `Ext.create` instantiates a panel, which is rendered to the document body (`Ext.getBody()`).  This code snippet requires the inclusion of the Ext JS library (either via CDN or via your chosen package manager).  Save this code as an HTML file (e.g., `index.html`), ensure the Ext JS library is properly included, and open the file in a web browser to see the result.\n\n\n### Understanding the MVC Architecture\n\nExt JS employs a Model-View-Controller (MVC) architecture to structure applications. This pattern promotes code organization, reusability, and maintainability.\n\n* **Model:** Represents the data of your application. Models handle data fetching, persistence, and validation.  They often interact with back-end services (e.g., REST APIs).\n\n* **View:**  The visual representation of the data. Views are responsible for rendering data and handling user interactions.  They don't contain business logic.\n\n* **Controller:** Acts as an intermediary between the Model and the View. Controllers handle user actions, update the Model, and refresh the View accordingly.\n\nExt JS provides classes and utilities to implement the MVC pattern effectively, facilitating the creation of well-structured and scalable applications.  Understanding this architecture is crucial for effectively using Ext JS.\n\n\n### Exploring the Ext JS Class System\n\nExt JS utilizes a powerful and flexible class system based on inheritance and prototypes.  This system is fundamental to extending existing components and creating custom ones.  Key concepts include:\n\n* **Ext.define():** Used to define new classes.  It allows specifying a class name, parent class (for inheritance), config options, and methods.\n\n* **Inheritance:** Ext JS supports single inheritance.  You can extend existing classes to create new ones with added functionality or modified behavior.\n\n* **Mixins:** Allows including functionality from multiple classes without using inheritance.  Useful for adding cross-cutting concerns.\n\n* **Statics:**  Properties and methods that belong to the class itself, not instances of the class.\n\nMastering the Ext JS class system is essential for developing complex and customized applications.  The documentation provides detailed examples and explanations of these concepts.  Experiment with creating simple custom classes to solidify your understanding.\n\n\n## Core Components\n\n### Panels and Containers\n\nPanels and containers are fundamental building blocks in Ext JS, providing the structure for your application's layout.  Panels are rectangular components that can contain other components.  Containers manage the layout and arrangement of child components within them.  Key container classes include:\n\n* **`Ext.panel.Panel`:** The basic panel, offering features like title bars, borders, and content areas.  Often used as a foundation for more complex components.\n\n* **`Ext.layout.container.Fit`:**  A layout that causes its single child component to fill the available space.  Simple and efficient for single-component containers.\n\n* **`Ext.layout.container.Border`:**  Divides the container into five regions (north, south, east, west, center).  Suitable for applications requiring structured layouts with docked components.\n\n* **`Ext.layout.container.Accordion`:** Arranges child panels vertically, allowing only one panel to be expanded at a time.\n\nUnderstanding the different container layouts and how to nest them is crucial for creating effective user interfaces.\n\n\n### Forms and Fields\n\nExt JS provides a comprehensive set of form components for creating data entry interfaces.  Forms are built using field components, each representing a single input element.  Key features include:\n\n* **`Ext.form.Panel`:** The container for form fields.  Manages field submission, validation, and data handling.\n\n* **Field Types:**  Ext JS offers a wide variety of field types, including text fields (`Ext.form.field.Text`), number fields (`Ext.form.field.Number`), date fields (`Ext.form.field.Date`), combo boxes (`Ext.form.field.ComboBox`), and more.  Each field type provides specific validation and input features.\n\n* **Validation:**  Ext JS provides built-in validation capabilities for form fields, ensuring data integrity.  You can define custom validation rules using regular expressions or custom functions.\n\n* **Data Binding:**  Forms can be easily bound to data models, simplifying data entry and retrieval.\n\n\n### Grids and Data Management\n\nGrids are essential for displaying tabular data.  Ext JS's grid component (`Ext.grid.Grid`) is highly flexible and powerful, offering features like sorting, filtering, paging, and editing.  Key aspects include:\n\n* **Data Sources:**  Grids can be populated using various data sources, including arrays, JSON data, and remote server calls.  The `Ext.data.Store` class manages data loading and manipulation.\n\n* **Columns:**  Columns define how data is displayed in the grid.  You can customize column headers, data rendering, and alignment.\n\n* **Features:**  Ext JS provides a rich set of grid features, including cell editing, row selection, grouping, and summary rows.\n\n* **Data Proxies:** Manage communication with the data source (e.g., using REST APIs).\n\n\n### Windows and Dialogs\n\nWindows and dialogs are used to display modal or modeless pop-up windows.  They're crucial for creating interactive user experiences.  Key components include:\n\n* **`Ext.window.Window`:** Represents a basic window.  Offers features like title bars, close buttons, resizing, and draggability.\n\n* **Modal vs. Modeless:**  Modal windows prevent interaction with the underlying application until closed, while modeless windows allow concurrent interaction.\n\n* **Dialog Creation:**  Ext JS provides helper methods for creating common dialog types, such as message boxes and confirmation dialogs.\n\n\n### Menus and Toolbars\n\nMenus and toolbars enhance user interaction by providing easy access to commands and options.\n\n* **`Ext.menu.Menu`:** Creates context menus and drop-down menus.  Can contain menu items, separators, and sub-menus.\n\n* **`Ext.toolbar.Toolbar`:**  Provides a container for buttons, menu items, and other toolbar components.  Typically located at the top or bottom of a window or panel.\n\n* **Customization:** Menus and toolbars can be highly customized to meet specific application requirements.\n\n\n### Buttons and Icons\n\nButtons are fundamental interactive components that trigger actions.  Ext JS provides various button types and options for customization.\n\n* **`Ext.button.Button`:**  The base class for buttons.  Allows setting text labels, icons, and handlers for click events.\n\n* **Icon Integration:**  Ext JS integrates seamlessly with icon libraries (e.g., Font Awesome) for visually appealing buttons.\n\n* **Button Handlers:**  Define functions to execute when a button is clicked, often triggering controller actions.\n\n\n## Data Handling\n\n### Data Models and Stores\n\nExt JS uses a robust data handling system centered around Models and Stores.  Models represent individual data records, while Stores manage collections of Models and provide interfaces for data manipulation and access.\n\n* **`Ext.data.Model`:** Defines the structure and properties of a single data record.  Models typically define fields (properties) and may include validation rules.\n\n* **`Ext.data.Store`:**  A collection of Models.  Provides methods for loading, sorting, filtering, and updating data. Stores interact with data sources (like servers) through Proxies.  Common store configurations include `autoLoad` (automatically loads data on creation) and `pageSize` (for pagination).\n\n* **Field Definitions:** When defining a Model, you specify the fields (properties) of each record using an array of objects.  Each object defines a name, type (e.g., string, number, date), and other options.\n\n\n### Working with AJAX and Proxies\n\nProxies act as intermediaries between Stores and data sources, typically handling asynchronous communication via AJAX.  They abstract the details of data fetching and saving.\n\n* **`Ext.data.proxy.Ajax`:** The most common proxy type, used for communicating with remote servers via AJAX requests.\n\n* **Configuring Proxies:**  Proxies require configuration to specify the URL for data retrieval (`api.read`), data creation (`api.create`), updating (`api.update`), and deleting (`api.destroy`).  The `reader` config option specifies how to parse the server's response.  Common readers include `Ext.data.reader.Json` and `Ext.data.reader.Xml`.\n\n* **API Calls:** The `api` config property of the proxy defines the URLs for different CRUD (Create, Read, Update, Delete) operations.  The proxy handles converting the Store's requests into AJAX calls and processing the server's responses.\n\n\n### Data Binding and Templating\n\nExt JS simplifies data binding, enabling components to automatically update when underlying data changes and vice-versa.  Templating allows for customized data rendering within components.\n\n* **Two-Way Data Binding:** Changes in the Model are reflected in the View, and vice-versa. This simplifies maintaining data consistency.\n\n* **`Ext.XTemplate`:** A powerful templating engine for creating dynamic HTML based on data.  Allows using placeholders (`{fieldName}`) within HTML templates to insert data from Models.\n\n* **Data Binding in Grids:** Grids automatically bind to Stores, displaying data from the Models.  Cell editors allow modifying the data directly within the grid, automatically updating the Models and Store.\n\n\n### Data Validation and Error Handling\n\nExt JS supports data validation at both the Model and form levels.  Error handling mechanisms provide ways to gracefully handle validation failures and data loading errors.\n\n* **Model Validation:**  Define validation rules within your `Ext.data.Model` definition.  Rules can check for required fields, data types, and custom constraints.\n\n* **Form Validation:**  Ext JS forms automatically validate fields based on their configurations and associated Model validation.  Error messages are displayed to the user.\n\n* **Error Handling in Proxies:**  Proxies can handle errors during AJAX calls.  You can define custom error handling functions to gracefully handle failures (e.g., displaying informative messages to the user).\n\n\n### Server-Side Data Integration\n\nExt JS integrates seamlessly with various server-side technologies.  The choice of technology depends on your project requirements.  Common approaches include:\n\n* **REST APIs:**  The most common approach, using HTTP methods (GET, POST, PUT, DELETE) to interact with server-side resources.\n\n* **JSON Data:**  JSON is the typical data format for communication between the client (Ext JS) and the server.\n\n* **Other Technologies:**  Ext JS can also integrate with other technologies like GraphQL, SOAP, or custom protocols, but REST APIs are widely preferred due to their simplicity and flexibility.  Proper server-side design is crucial for efficient data handling and a smooth user experience.  Consider techniques like pagination and efficient data filtering to improve performance when dealing with large datasets.\n\n\n## UI Components\n\n### Buttons\n\nButtons provide a fundamental way for users to interact with your application. Ext JS offers a flexible `Ext.button.Button` class with numerous configuration options.\n\n* **Text:** The button's displayed text.\n* **Icon:**  Specify an icon using a URL or icon class from an icon library (e.g., Font Awesome).\n* **Handlers:**  Functions to execute when the button is clicked.  These are typically defined using the `handler` config option.\n* **Disabled State:**  Buttons can be programmatically enabled or disabled using the `setDisabled()` method.\n* **Button Types:**  Ext JS provides various button types (e.g., split buttons, segmented buttons) through subclasses of `Ext.button.Button`.\n\n\n### Text Fields\n\nText fields (`Ext.form.field.Text`) allow users to input and edit text.\n\n* **Validation:**  You can specify validation rules (e.g., required, minimum length) to ensure data integrity.\n* **Input Masks:**  Apply masks to restrict the allowed characters.\n* **Placeholders:**  Provide hints to the user about the expected input.\n* **Event Handlers:**  Listen to events like `change` or `blur` to respond to user input.\n\n\n### Number Fields\n\nNumber fields (`Ext.form.field.Number`) are specifically designed for numerical input.\n\n* **Validation:**  Built-in validation for numeric values, including range checks and decimal precision.\n* **Step Values:**  Define the increment/decrement step for input.\n* **AllowDecimals:**  Specify whether decimal values are allowed.\n\n\n### Date Fields\n\nDate fields (`Ext.form.field.Date`) handle date input.\n\n* **Format:**  Customize the date format displayed to the user and used for internal representation.\n* **Picker:**  The date picker allows users to select dates visually.\n* **Validation:**  Validate date formats and ranges.\n\n\n### Checkboxes and Radio Buttons\n\nCheckboxes (`Ext.form.field.Checkbox`) and radio buttons (`Ext.form.field.Radio`) allow users to select one or multiple options.\n\n* **Value:**  The value submitted when checked.\n* **Grouping:**  Radio buttons are typically grouped to ensure only one can be selected at a time.\n* **Checked State:**  Programmatically control the checked state using the `setChecked()` method.\n\n\n### Combo Boxes and Dropdowns\n\nCombo boxes (`Ext.form.field.ComboBox`) and dropdowns provide a list of options for selection.\n\n* **Data:**  Provide data as an array of objects or use a store for dynamic data loading.\n* **Display Field:**  The field from the data source used to display items in the dropdown.\n* **Value Field:**  The field from the data source to store as the selected value.\n\n\n### List Views and Data Grids\n\nList views (`Ext.view.View`) display lists of items; data grids (`Ext.grid.Grid`) are specifically designed for tabular data.\n\n* **Stores:**  Both use stores to manage data.\n* **Templates:**  Customizable templates for rendering items (List view) or cells (Data Grid).\n* **Features:**  Data grids offer advanced features like sorting, filtering, paging, editing, and grouping.\n\n\n### Trees and Tree Grids\n\nTrees (`Ext.tree.Panel`) and tree grids (`Ext.tree.Panel` with grid features) display hierarchical data.\n\n* **Nodes:**  Represent items in the tree.\n* **Data Sources:**  Can be populated from arrays or stores.\n* **Expansion/Collapse:**  Allow users to expand and collapse branches of the tree.\n\n\n### Tabs\n\nTabs (`Ext.tab.Panel`) allow organizing content into multiple tabbed panels.\n\n* **Items:**  The tabs' content.\n* **Active Tab:**  Specify the initially active tab.\n* **Closable Tabs:**  Allow users to close individual tabs.\n\n\n### Accordions\n\nAccordions (`Ext.panel.Accordion`) display panels in an expandable/collapsible format.\n\n* **Items:**  The panels to be displayed.\n* **Multi-expand:** Allow multiple panels to be expanded at once.\n\n\n### Progress Bars and Load Masks\n\nProgress bars (`Ext.ProgressBar`) and load masks (`Ext.LoadMask`) indicate ongoing operations.\n\n* **Percentage:**  Progress bars display the percentage of completion.\n* **Message:**  Load masks display messages while loading.\n\n\n### Charts\n\nExt JS provides integration with various charting libraries to render various types of charts.\n\n\n### Custom Components\n\nExt JS's class system allows for creating custom components by extending existing ones or building them from scratch.\n\n\n### Component Layouts\n\nLayouts control how components are arranged within containers.  Ext JS offers various layouts:\n\n* **Fit:**  A single child component fills the available space.\n* **Border:**  Divides the container into five regions (north, south, east, west, center).\n* **Accordion:**  Organizes components vertically, allowing only one to be expanded at a time.\n* **HBox/VBox:**  Arranges components horizontally or vertically.\n* **Column:**  Arranges components into columns.\n\n\n\n\n## Advanced Topics\n\n### Extending Ext JS Classes\n\nExt JS's class system allows extending existing classes to add functionality or modify behavior. This is achieved using `Ext.define()` and specifying the parent class.\n\n```javascript\nExt.define('MyApp.MyCustomButton', {\n    extend: 'Ext.button.Button',\n    config: {\n        customProperty: 'defaultValue'\n    },\n    onClick: function() {\n        // Custom click handling logic\n        console.log('Custom button clicked!');\n        this.callParent(arguments); // Call the parent class's onClick method\n    }\n});\n```\n\nThis example extends `Ext.button.Button`, adding a custom property and overriding the `onClick` method.  `callParent` ensures that the original functionality is also executed.\n\n\n### Creating Custom Components\n\nBuilding entirely new components involves defining classes using `Ext.define()`, specifying the component's properties, methods, and render logic.  Consider using existing components as a starting point for inheritance.\n\n```javascript\nExt.define('MyApp.MyCustomComponent', {\n    extend: 'Ext.Component',\n    renderTpl: [\n        '<div class=\"my-custom-component\">',\n        '<tpl if=\"title\">',\n        '<h1>{title}</h1>',\n        '</tpl>',\n        '<p>{text}</p>',\n        '</div>'\n    ],\n    config: {\n        title: null,\n        text: null\n    },\n    applyText: function(text) {\n       return text || \"Default Text\";\n    }\n});\n```\n\nThis creates a simple component rendering a title and text.  `renderTpl` defines the HTML template, and `config` specifies configurable properties.\n\n\n### Working with Events and Listeners\n\nExt JS uses an event-driven architecture. Components emit events, and you can add listeners to respond to these events.\n\n```javascript\nconst myButton = Ext.create('Ext.button.Button', {\n    text: 'Click Me',\n    listeners: {\n        click: function() {\n            console.log('Button clicked!');\n        }\n    }\n});\n\n// Alternatively using on():\nmyButton.on('click', function() {\n    console.log('Button clicked using on()!');\n});\n```\n\nThese examples demonstrate attaching a click listener to a button.  `listeners` is a config option; `on()` adds listeners dynamically.\n\n\n### Internationalization and Localization\n\nExt JS supports internationalization (i18n) and localization (l10n) for creating multilingual applications.  This usually involves using JSON files for storing translated text and loading the appropriate translations based on the user's locale.\n\n* **Locale Configuration:** Configure Ext JS to load locale-specific resource files.\n* **Translation Files:** Create JSON files containing translations for different languages.\n* **Accessing Translations:** Use `Ext.String.format` to include translated strings in your UI.\n\n\n### Performance Optimization\n\nOptimizing Ext JS applications focuses on minimizing render time, efficient data handling, and avoiding unnecessary DOM manipulations.\n\n* **Lazy Loading:** Load components and data only when needed.\n* **Efficient Data Handling:** Use appropriate data stores and proxies for efficient data management.\n* **DOM Manipulation:** Minimize direct DOM manipulation. Use Ext JS's built-in methods for updating the UI.\n* **Batch Updates:**  Aggregate multiple updates to the DOM into single operations.\n* **Profiling:** Use browser developer tools to identify performance bottlenecks.\n\n\n### Debugging and Troubleshooting\n\nDebugging Ext JS applications involves using browser developer tools (e.g., Chrome DevTools) to inspect component state, network requests, and JavaScript errors.  Ext JS's logging mechanisms can be valuable for tracking application behavior.\n\n* **Browser DevTools:** Use the debugger to step through code, inspect variables, and examine network traffic.\n* **Ext JS Logging:**  Use `Ext.log.log()`, `Ext.log.info()`, `Ext.log.warn()`, and `Ext.log.error()` for debugging messages.  Configure the logging level to control verbosity.  (Consider using a logging framework for larger applications.)\n\n\n### Testing and Unit Testing\n\nThorough testing is essential for building robust applications.  Ext JS applications can be tested using various methods, including unit testing frameworks like Jasmine or Jest.\n\n* **Unit Testing:**  Test individual components and functions in isolation.\n* **Integration Testing:**  Test how different components interact.\n* **End-to-End Testing:**  Test the entire application workflow.  Use testing frameworks to automate tests.\n\n\n### Deployment and Distribution\n\nDeploying Ext JS applications involves building optimized code, serving the application, and managing dependencies.\n\n* **Build Process:**  Use build tools like Sencha Cmd or Webpack to optimize your application for production.  This typically involves minification, code obfuscation, and combining files.\n* **Server-Side Deployment:**  Deploy the built application to a web server.\n* **Dependency Management:**  Ensure all required libraries (including Ext JS) are included and properly versioned.  CDNs or local copies are common approaches.\n\n\n## Ext JS Modern Toolkit\n\n### Overview of Modern Toolkit\n\nThe Ext JS Modern toolkit is a framework for building modern, touch-friendly web applications. It leverages the power of HTML5, CSS3, and JavaScript to create responsive and performant user interfaces that work seamlessly across a wide range of devices, including desktops, tablets, and smartphones.  It uses a completely different rendering engine and component architecture compared to the Classic toolkit. The Modern toolkit is designed with mobile-first principles in mind and offers a sleek, modern look and feel out of the box.  It prioritizes touch interactions and adapts easily to various screen sizes.\n\n\n### Key Differences from Classic Toolkit\n\nThe Modern and Classic toolkits are distinct and not directly compatible.  Key differences include:\n\n* **Rendering Engine:** Modern uses a modern HTML5 rendering engine, while Classic uses a more traditional approach that relies heavily on DOM manipulation.  This results in significant performance and responsiveness advantages for Modern.\n\n* **Component Architecture:**  Modern has a completely redesigned component architecture, leading to different component APIs and behaviors compared to Classic.  While many components have similar names (e.g., `Ext.panel.Panel`), their implementation and configuration options can differ significantly.\n\n* **Look and Feel:** The Modern toolkit offers a modern, cleaner aesthetic, designed to be visually appealing on modern devices. Classic's look can appear somewhat dated in comparison.\n\n* **Touch Support:**  Modern is inherently touch-friendly, while Classic requires additional configuration or workarounds for optimal touch support.\n\n* **MVC vs. MVVM:** While both toolkits support MVC, Modern is often better suited for MVVM (Model-View-ViewModel) architectural patterns, enhancing data binding and maintainability.\n\nMigrating from Classic to Modern often requires substantial refactoring and rewriting of code, as they are fundamentally different frameworks.\n\n\n### Component-Specific Details\n\nMany components in the Modern toolkit mirror those in the Classic toolkit, but with different APIs and behaviors.  You will need to refer to the Modern toolkit documentation for detailed information about specific components.  Key considerations include:\n\n* **Configuration Options:**  Configuration options for equivalent components often differ significantly between the toolkits.\n* **Event Handling:**  Event names and listener handling might vary.\n* **Layout Managers:**  Layout management differs, and you should understand the Modern toolkit's layout system.  Common layouts include `fit`, `vbox`, `hbox`, and `center`.\n* **Styling:**  Styling techniques are also different. Modern uses CSS classes and theming mechanisms differently than Classic.\n\n\n### Modern Toolkit Examples\n\nA simple \"Hello, World!\" example using the Modern toolkit:\n\n```javascript\nExt.application({\n    name: 'MyApp',\n    launch: function() {\n        Ext.create('Ext.Container', {\n            fullscreen: true,\n            items: [{\n                xtype: 'panel',\n                html: 'Hello, World!'\n            }]\n        });\n    }\n});\n```\n\nThis code creates a simple panel displaying \"Hello, World!\" that fills the entire screen.  Note the use of `fullscreen: true` and `xtype` for component creation.  Explore the extensive examples provided in the official Sencha documentation to see how various Modern components are used to create more complex applications.  The documentation will also cover the various layout options available and how to integrate data handling with modern components like grids and lists.\n\n\n## Ext JS Classic Toolkit\n\n### Overview of Classic Toolkit\n\nThe Ext JS Classic toolkit is a mature and feature-rich framework for building web applications. While the Modern toolkit is now the recommended approach for new projects, Classic remains a powerful option for maintaining and extending existing applications.  It employs a different rendering mechanism than the Modern toolkit, relying heavily on DOM manipulation.  While still functional, it generally lags behind Modern in terms of performance, especially on mobile devices.  The Classic toolkit's architecture is largely based on the MVC (Model-View-Controller) pattern and offers a wide range of components and utilities for building complex web applications.  However, its design might appear less modern compared to the streamlined approach of the Modern toolkit.\n\n\n### Component-Specific Details\n\nMany components in the Classic toolkit have counterparts in the Modern toolkit, but their APIs and behaviors can differ significantly.  Detailed information about specific components is available in the Ext JS Classic toolkit documentation.  Key differences to note from the Modern toolkit include:\n\n* **Rendering:** The Classic toolkit uses a different rendering engine than the Modern toolkit. This often results in different performance characteristics and requires a different approach to styling and theming.\n\n* **Layout Managers:**  Classic employs a different set of layout managers, such as `border`, `fit`, `form`, `column`, and `accordion`.  Understanding how these layouts work is crucial for arranging components effectively.\n\n* **Event Handling:** The way events are handled might differ slightly from the Modern toolkit. While both use event listeners, the specifics of event names and listener registration can vary.\n\n* **Data Handling:** While both Classic and Modern use `Ext.data.Store` and `Ext.data.Model`, there may be subtle differences in configuration options and behavior.\n\n* **Styling:** Classic utilizes CSS classes and styling methods that are different from the Modern toolkit.\n\n\n### Classic Toolkit Examples\n\nA simple \"Hello, World!\" example using the Classic toolkit:\n\n```javascript\nExt.onReady(function() {\n    Ext.create('Ext.Panel', {\n        renderTo: Ext.getBody(),\n        width: 300,\n        height: 200,\n        title: 'My First Ext JS App',\n        html: 'Hello, World!'\n    });\n});\n```\n\nThis code creates a simple panel, renders it to the document body, and displays \"Hello, World!\".  `Ext.onReady` ensures the code runs after the DOM is fully loaded.  The `renderTo` config option specifies the target element.  Note that creating more complex applications will require a more robust architecture using Models, Views, and Controllers.  The Classic toolkit documentation provides extensive examples that showcase various components and their interactions, including forms, grids, and advanced layouts.  These examples should be consulted to learn more about the intricate details of building applications with the Classic toolkit.\n\n\n## API Reference\n\nThe Ext JS API is extensive and well-documented.  This section provides an overview of the key parts of the API reference.  For the most up-to-date and comprehensive information, always consult the official Sencha Ext JS API documentation.\n\n### Class Reference\n\nThe class reference provides detailed information on all the classes available in Ext JS.  For each class, the documentation typically includes:\n\n* **Class Name:** The fully qualified name of the class (e.g., `Ext.panel.Panel`).\n* **Inheritance Hierarchy:** The class's inheritance lineage, showing which classes it extends.\n* **Members:** A list of the class's properties, methods, and events.\n* **Description:** A detailed description of the class's purpose and functionality.\n* **Example Code:**  Code snippets demonstrating how to use the class.\n* **Config Options:**  A detailed description of the configurable options for the class (see Config Options Reference).\n\n\nYou can typically access the class reference through the official documentation website by searching for the class name or browsing the class hierarchy.\n\n\n### Method Reference\n\nThe method reference details the available methods for each class.  For each method, you'll typically find:\n\n* **Method Name:** The name of the method (e.g., `show()`, `hide()`, `addListener()`).\n* **Parameters:** A description of the method's parameters, including their data types and purpose.\n* **Return Value:**  Information about the value returned by the method.\n* **Description:** A detailed explanation of what the method does.\n* **Example Code:**  Illustrative code snippets.\n\n\nThe method reference is typically integrated into the class reference, listed under the \"Methods\" section for each class.\n\n\n### Config Options Reference\n\nConfig options allow you to customize the behavior and appearance of Ext JS components.  The config options reference provides detailed information on these options.  Each config option description typically includes:\n\n* **Option Name:** The name of the config option (e.g., `title`, `width`, `height`, `listeners`).\n* **Data Type:** The expected data type of the config option (e.g., string, number, boolean, object, array, function).\n* **Description:** A detailed explanation of what the option does.\n* **Default Value:** The default value if the option is not explicitly set.\n* **Example Code:**  Illustrative code showing how to use the config option.\n\n\nConfig options are usually documented within the class reference, often in a dedicated section or table.\n\n\n### Events Reference\n\nThe events reference lists the events fired by each class.  This is crucial for understanding how to respond to changes in component state or user interactions.  For each event, the documentation provides:\n\n* **Event Name:** The name of the event (e.g., `click`, `resize`, `afterrender`, `beforehide`).\n* **Description:**  A detailed explanation of when the event is fired.\n* **Parameters:**  Any parameters passed with the event.\n* **Example Code:**  Code snippets demonstrating how to add listeners for the event.\n\n\nSimilar to methods and config options, the events reference is typically found within the class reference, under a dedicated \"Events\" section.  Understanding the events fired by components allows you to build dynamic and responsive applications.  You can use the `addListener` method (or its shorthand `on`) to attach event handlers.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["../../styles.css"],"html-math-method":{"method":"mathjax","url":"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"},"include-in-header":["../../favicon.html","../../header.html","../../schema.html"],"include-after-body":[{"text":"<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3609399560636561\" crossorigin=\"anonymous\"></script>\n"},"../../footer.html"],"output-file":"ext-js.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.8.25","theme":"pandoc","mermaid":{"theme":"neutral"},"minimal":true,"title-block-banner":true,"page-navigation":true,"license":"MIT","author-meta":"Muthukrishnan","title":"Ext JS - Documentation","description":"Complete documentation and tutorial for Ext JS JavaScript library. Learn installation, usage examples, API reference, and best practices.","date":"2025-02-09","categories":["JavaScript Libraries and Functions"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}